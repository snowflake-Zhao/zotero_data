bbs.theithome.com


More Effecitve C++
作者 : Scott Meyers 译序、导读 : 侯捷 Item 1~28 : ZHC Item 29~35 : WQ 附 1 : 侯捷 附 2 : WQ 附 3、附 4 : 陈崴
1. 译序(侯捷) ................................................................................................................................3
2. 导读 ................................................................................................................................................4
2.1 本书所谈的 C++ .................................................................................................................4 2.2 惯例与术语 ..........................................................................................................................6 2.3 臭虫报告,意见提供,内容更新 ....................................................................................7
3. 基础议题 ........................................................................................................................................8
3.1 ITEM M1:指针与引用的区别 ...............................................................................................8 3.2 ITEM M2:尽量使用 C++风格的类型转换........................................................................10 3.3 ITEM M3:不要对数组使用多态.........................................................................................14 3.4 ITEM M4:避免无用的缺省构造函数 ................................................................................16
4. 运算符 ..........................................................................................................................................20
bbs.theithome.com


4.1 ITEM M5:谨慎定义类型转换函数.....................................................................................21 4.2 ITEM M6:自增(INCREMENT)、自减(DECREMENT)操作符前缀形式与后缀形式的区别 27 4.3 ITEM M7:不要重载“&&”,“||”, 或“,”.............................................................................29 4.4 ITEM M8:理解各种不同含义的 NEW 和 DELETE .............................................................32
5. 异常 ..............................................................................................................................................37
5.1 ITEM M9:使用析构函数防止资源泄漏 ............................................................................38 5.2 ITEM M10:在构造函数中防止资源泄漏 ..........................................................................42
5.3 ITEM M11:禁止异常信息(EXCEPTIONS)传递到析构函数外 .....................................51 5.4 ITEM M12:理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的 差异 54
5.5 ITEM M13:通过引用(REFERENCE)捕获异常 ...............................................................60 5.6 ITEM M14:审慎使用异常规格(EXCEPTION SPECIFICATIONS) .......................................... 64 5.7 ITEM M15:了解异常处理的系统开销 ..............................................................................69
6. 效率 ..............................................................................................................................................71
6.1 ITEM M16:牢记 80-20 准则(80-20 RULE) ..............................................................72 6.2 ITEM M17:考虑使用 LAZY EVALUATION(懒惰计算法) ..............................................74 6.3 ITEM M18:分期摊还期望的计算.......................................................................................81 6.4 ITEM M19:理解临时对象的来源.......................................................................................85 6.5 ITEM M20:协助完成返回值优化.......................................................................................87 6.6 ITEM M21:通过重载避免隐式类型转换 ..........................................................................91 6.7 ITEM M22:考虑用运算符的赋值形式(OP=)取代其单独形式(OP)......................93 6.8 ITEM M23:考虑变更程序库 ...............................................................................................96 6.9 ITEM M24:理解虚拟函数、多继承、虚基类和 RTTI 所需的代价..............................98
7. 技巧(TECHNIQUES,又称 IDIOMS 或 PATTERN)..................................................... 106
7.1 ITEM M25:将构造函数和非成员函数虚拟化................................................................ 107 7.2 ITEM M26:限制某个类所能产生的对象数量................................................................ 111 7.3 ITEM M27:要求或禁止在堆中产生对象 ........................................................................ 125 7.4 ITEM M28:灵巧(SMART)指针...................................................................................... 134 7.5 ITEM M29:引用计数.......................................................................................................... 149 7.6 ITEM M30:代理类.............................................................................................................. 177 7.7 ITEM M31:让函数根据一个以上的对象来决定怎么虚拟 ........................................... 190
8. 杂项 ............................................................................................................................................ 212
8.1 ITEM M32:在未来时态下开发程序................................................................................. 212 8.2 ITEM M33:将非尾端类设计为抽象类 ............................................................................ 216 8.3 ITEM M34:如何在同一程序中混合使用 C++和 C........................................................ 226 8.4 ITEM M35:让自己习惯使用标准 C++语言.................................................................... 231
9. 附录 ............................................................................................................................................ 237
9.1 推荐读物 .......................................................................................................................... 237 9.2 一个 AUTO_PTR 的实现实例 .......................................................................................... 241 9.3 在 C++ 中计算物件个数(OBJECTS COUNTING IN C++)译者:陈崴 ................... 244
9.4 为智能指标实作 OPERATOR->*(IMPLEMENTING OPERATOR->* FOR SMART POINTERS)
译者:陈崴 .................................................................................................................................... 254
bbs.theithome.com


基础的重要性(程序员之路)
学习编程有几年了,感觉走了不少弯路,而不少的学弟学妹又在重蹈我当初的覆辙,不免有些痛心。最近在网
上也看了许多前辈们的经验建议,再结合自己的学习经历在这里谈谈基础的重要性,希望帮助大家少走些弯
路。
什么是基础呢?就是要把我们大学所学的离散数学,算法与数据结构,操作系统,计算机体系结构,编译原理
等课程学好,对计算机的体系,CPU本身,操作系统内核,系统平台,面向对象编程,程序的性能等要有深层次的掌握。
初学者可能体会不到这些基础的重要性,学习jsp,donet,mfc,vb的朋友甚至会对这些嗤之以鼻,但是一开始没学
好基础就去学jsp或donet会产生很坏的影响,而且陷入其中不能自拔。
我上大二的时候还对编程没什么概念,就上了门C++也不知道能干什么,老师说MFC也不知道是什么东西,
看别的同学在学asp.net就跟着学了,然后就了解到.net,j2ee,php是什么了,就觉得软件开发就是用这些了,而上
的那些专业课又与我们学的sqlserver啊,css啊,ajax啊,毫无关系,就感慨啊,还不如回家自学去就为一个文凭吗?
还不如去培训,浪费这么多钱.于是天天基本上没去上什么课,天天就在做网站,几个学期就做了三个网站。感觉做
这些网站就是学到些技巧,没什么进步,这些技巧就好比别人的名字,告诉你你就知道了,网上也都可以搜到。那时
候就觉得把.net学好就行了,搞j2ee的比较难,搞api编程就别想了,操作系统更是望尘莫及了。后来随着学习
的深入和看了网上许多前辈们的建议才对这些基础的重要性有所体会。
虽然.net或java的开发并不直接用到汇编,操作系统这些,但是不掌握这些基础是有很大问题的,因为你只知
其然不知其所有然,在mfc和.net里面控件一拖什么都做好了,很方便,但是出了问题可能就解决不了,有些在
网上搜都搜不到。这就是基础没打好,不知道它的原理就不知道出错的原因。在学.net的时候常会讨论那些控件
该不该用别人说尽量别用也不知道为什么?不让用是因为你在高层开发,你不知道它的原理出错了你可能解决不
了,但其实是应该用的,不然人家开发它干嘛,但要在了解它的原理后去用就会很方便。
要编写出优秀的代码同样要扎实的基础,如果数据结构和算法学的不好,怎么对程序的性能进行优化,怎样
从类库中选择合适的数据结构。如果不了解操作系统,怎样能了解这些开发工具的原理,它们都是基于操作系统
的。不了解汇编,编译原理,怎么知道程序运行时要多长时间要多少内存,就不能编出高效的代码。
如果没有学好基础一开始就去学.net,java这些越往后就会觉得越吃力,它们涉及的技术太多了,而且不但
在更新,对于三层啊,mvc,orm这些架构,你只会用也不明白为什么用,就感觉心里虚,感觉没学好。而你把
面向对象,软件工程,设计模式这些基础学好了再去看这些就可以一不变应万变。
大家不要被新名词、新技术所迷惑.NET、XML等等技术固然诱人,可是如果自己的基础不扎实,就像是在
云里雾里行走一样,只能看到眼前,不能看到更远的地方。这些新鲜的技术掩盖了许多底层的原理,要想真正
的学习技术还是走下云端,扎扎实实的把基础知识学好,有了这些基础,要掌握那些新技术也就很容易了。
开始编程应该先学C/C++,系统api编程,因为它们更接近底层,学习他们更能搞清楚原理。学好了c/C++
编程和基础,再去学习mfc,.net这些就会比较轻松,而且很踏实。假设学习VB编程需要4个月,学习基础课程和
VC的程序设计需要1年。那么如果你先学VB,再来学习后者,时间不会减少,还是1年,而反过来,如果先学习
后者,再来学VB,也许你只需要1个星期就能学得非常熟练。
bbs.theithome.com


教的表面看来是马步冲权实则都是内功心法,郭靖拜师洪七之后开始练习降龙十八掌凭借的就是这深厚的内
功,吞食蝮蛇宝血又加上练习了周博通传授的九阴真经和外加功夫双手互博技之后,终于练就行走江湖的武
功,由此可见马玉道长传授给了郭靖的是最基础的,也是最重要的观念,编程也好比盖高楼,根基没打好早晚有
一天会挎掉的,而且盖得越高,损失也越惨重。这些底层知识和课本不是没有用也不是高深的不能学,而是我
们必须掌握的基础。
这些是个人的愚见,说的不是很清楚,大家可以看看这些前辈们的经验,相信看完后大家一定会有所体会
说了这么多无非是想告诫大家要打好扎实的基础,不要只顾追求时髦的技术,打好基础再去学那些技术或是
参加些培训,对自身的发展会更好的。
基础这么重要怎样学好它呢?我觉得学好它们应该对照这些基础课程所涉及的方面,多看一些经典书籍,像算
法导论,编程珠玑,代码大全(具体介绍在本论坛每本书的版块里)等,这些经典书籍不仅能帮助我们打好基础,而且
对我们的程序人生也能产生莫大的影响,相信认真研究看完这些书籍后,我们的程序之路会十分顺畅。然而这
些书籍并不好读,有些甚至相当难读,国内的大学用这些书当教材的也不多,这些书又偏向理论,自己读起来难免会
有些枯燥无味。于是就想到建一个论坛,大家共同讨论学习这些书籍,就会学的更踏实更牢固更有趣,这样就能
为以后的学习打下扎实的基础。
1.为计算机初学者或基础不太扎实的朋友指明方向,要注重内功
2.为学习者推荐经典书籍,指明应看哪些书籍,怎样练内功
3.为学习者提供一个交流的地方,更容易学好,不会那么枯燥
4.对每本书分章分别讨论,更专,会学的更踏实更牢固
5.讨论的都是经典书籍,每一本都会让我们受益匪浅,对每本书分别讨论是很有意义的。
本论坛特色: bbs.theithome.com
的。为了方便大家阅读,我把这些前辈们的建议的文章整理成了pdf,大家在下面下载吧!希望对大家有帮助。pdf
地址:http://bbs.theithome.com/read-htm-tid-123.html
编程就好比练功,如果学习.net,mfc,vb等具体的语言和工具是外功(招式),对基础的学习就是内功,只注重
招式而内功不扎实是不可能成为高手的。很多人会认为《射雕英雄传》中马玉道长什么都没有教郭靖,马道长
bbs.theithome.com


1. 译序(侯捷)
C++ 是一个难学易用的语言! C++ 的难学,不仅在其广博的语法,以及语法背後的语意,以及语意背後的深层思维, 以及深层思维背後的物件模型;C++ 的难学,还在於它提供了四种不同(但相辅相成)的程 式设计思维模式:procedural-based,object-based,object-oriented,generic paradigm。 世上没有白吃的午餐。又要有效率,又要有弹性,又要前瞻望远,又要回溯相容,又要 能治大国,又要能烹小鲜,学习起来当然就不可能太简单。 在如此庞大复杂的机制下,万千使用者前仆後续的动力是:一旦学成,妙用无穷。C++ 相 关书籍之多,车载斗量;如天上繁星,如过江之鲫。广博如四库全书者有之(The C++ Programming Language、C++ Primer),深奥如重山复水者有之(The Annotated C++ Reference Manual, Inside the C++ Object Model),细说历史者有之(The Design and Evolution of C++, Ruminations on C++),独沽一味者有之(Polymorphism in C++, Genericity in C++), 独树一帜者有之(Design Patterns,Large Scale C++ Software Design, C++ FAQs),程式 库大全有之(The C++ Standard Library),另辟蹊径者有之(Generic Programming and the STL),工程经验之累积亦有之(Effective C++, More Effective C++, Exceptional C++)。 这其中,「工程经验之累积」对已具 C++ 相当基础的程式员而言,有著致命的吸引力与 立竿见影的帮助。Scott Meyers 的 Effective C++ 和 More Effective C++ 是此类佼佼, Herb Sutter 的 Exceptional C++ 则是後起之秀。 这类书籍的一个共通特色是轻薄短小,并且高密度地纳入作者浸淫於 C++/OOP 领域多 年而广泛的经验。它们不但开展读者的视野,也为读者提供各种 C++/OOP 常见问题或易犯 错误的解决模型。某些小范围主题诸如「在 base classes 中使用 virtual destructor」、 「令 operator= 传回*this 的 reference」,可能在百科型 C++ 语言书籍中亦曾概略提过, 但此类书籍以深度探索的方式,让我们了解问题背後的成因、最佳的解法、以及其他可能的 牵扯。至於大范围主题,例如 smart pointers, reference counting, proxy classes,double dispatching, 基本上已属 design patterns 的层级! 这些都是经验的累积和心血的结晶。 我很高兴将以下三本极佳书籍,规划为一个系列,以精装的形式呈现给您: 1. Effective C++ 2/e, by Scott Meyers, AW 1998 2. More Effective C++, by Scott Meyers, AW 1996 3. Exceptional C++, by Herb Sutter, AW 1999 不论外装或内容,中文版比其英文版兄弟毫不逊色。本书不但与原文本页页对译, 保留索引,并加上精装、书签条、译注、书籍交叉参考 1、完整范例码 2、读者服务 3。 这套书对於您的程式设计生涯,可带来重大帮助。制作这套书籍使我感觉非常快 乐。我祈盼(并相信)您在阅读此书时拥有同样的心情。 侯捷 2000/05/15 于新竹.台湾 jjhou@ccca.nctu.edu.tw http://www.jjhou.com 1 Effective C++ 2/e 和 More Effective C++ 之中译,事实上是以 Scott Meyers 的另一 个产品 Effective C++ CD 为本,不仅资料更新,同时亦将 CD 版中两书之交叉参考保留下 来。这可为读者带来旁徵博引时的莫大帮助。 2 书中程式多为片段。我将陆续完成完整的范例程式,并在 Visual C++,C++Builder,GNU C++ 上测试。请至侯捷网站(http://www.jjhou.com)下载。 3 欢迎读者对本书范围所及的主题提出讨论,并感谢读者对本书的任何误失提出指正。 来信请寄侯捷电子信箱(jjhou@ccca.nctu.edu.tw)。
bbs.theithome.com


2. 导读
对 C++ 程式员而言,日子似乎有点过於急促。虽然只商业化不到 10 年,C++ 却俨然成 为几乎所有主要电算环境的系统程式语言霸主。面临程式设计方面极具挑战性问题的公司和 个人,不断投入 C++ 的怀抱。而那些尚未使用 C++ 的人,最常被询问的一个问题则是:你 打算什么时候开始用 C++。C++ 标准化已经完成,其所附带之标准程式库幅员广大,不仅涵 盖 C 函式库,也使之相形见绌。这么一个大型程式库使我们有可能在不必牺牲移植性的情 况下,或是在不必从头撰写常用演算法和资料结构的情况下,完成琳琅满目的各种复杂程式。 C++ 编译器的数量不断增加,它们所供应的语言性质不断扩充,它们所产生的码品质也不断 改善。C++ 开发工具和开发环境愈来愈丰富,威力愈来愈强大,稳健强固(robust)的程度 愈来愈高。商业化程式库几乎能够满足各个应用领域中的写码需求。 一旦语言进入成熟期,而我们对它的使用经验也愈来愈多,我们所需要的资讯也就随之 改变。1990 年人们想知道 C++ 是什么东西。到了 1992 年,他们想知道如何运用它。如今 C++ 程式员问的问题更高级:我如何能够设计出适应未来需求的软体?我如何能够改善程式 码的效率而不折损正确性和易用性?我如何能够实作出语言未能直接支援的精巧机能? 这本书中我要回答这些问题,以及其他许多类似问题。 本书告诉你如何更具实效地设计并实作 C++ 软体:让它行为更正确;面对异常情况时 更稳健强固;更有效率;更具移植性;将语言特性发挥得更好;更优雅地调整适应;在「混 合语言」开发环境中运作更好;更容易被正确运用;更不容易被误用。简单地说就是如何让 软体更好。 本书内容分为 35 个条款。每个条款都在特定主题上精简摘要出 C++ 程式设计社群所累 积的智慧。大部份条款以准则的型式呈现,附随的说明则阐述这条准则为什么存在,如果不 遵循会发生什么後果,以及什么情况下可以合理违反该准则。所有条款被我分为数大类。某 些条款关心特定的语言性质,特别是你可能罕有使用经验的一些新性质。例如条款 9~15 专 注於 exceptions(就像 Tom Cargill, Jack Reeves, Herb Sutter 所发表的那些杂志文章 一样)。其他条款解释如何结合语言的不同特性以达成更高阶目标。例如条款 25~31 描述如 何限制物件的个数或诞生地点,如何根据一个以上的物件型别产生出类似虚拟函式的东西, 如何产生 smart pointers 等等。其他条款解决更广泛的题目。条款 16~24 专注於效率上的 议题。不论哪一条款,提供的都是与其主题相关且意义重大的作法。在 More Effective C++ 一书中你将学习到如何更实效更精锐地使用 C++。大部份 C++ 教科书中对语言性质的大量描 述,只能算是本书的一个背景资讯而已。 这 种 处 理 方 式 意 味 , 你 应 该 在 阅 读 本 书 之 前 便 熟 悉 C++ 。 我 假 设 你 已 了 解 类 别 (classes)、保护层级(protection levels)、虚拟函式、非虚拟函式,我也假设你已通晓 templates 和 exceptions 背後的概念。我并不期望你是一位语言专家,所以涉及较罕见的 C++ 特性时,我会进一步做解释。
2.1 本书所谈的C++
我在本书所谈、所用的 C++,是 ISO/ANSI 标准委员会於 1997 年 11 月完成的 C++国际 标准最後草案(Final Draft International Standard)。这暗示了我所使用的某些语言特 性可能并不在你的编译器(s) 支援能力之列。别担心,我认为对你而言唯一所谓「新」特性, 应该只有 templates,而 templates 如今几乎已是各家编译器的必备机能。我也运用 exceptions,并大量集中於条款 9~15。如果你的编译器(s) 未能支援 exceptions,没什么 大不了,这并不影响本书其他部份带给你的好处。但是,听我说,纵使你不需用到 exceptions,亦应阅读条款 9~15,因为那些条款(及其相关篇幅)检验了某些不论什么场 合下你都应该了解的主题。 我承认,就算标准委员会授意某一语言特性或是赞同某一实务作法,并非就保证该语言 特性已出现在目前的编译器上,或该实务作法已可应用於既有的开发环境上。一旦面对「标 准委员会所议之理论」和「真正能够有效运作之实务」间的矛盾,我便两者都加以讨论,虽 然我其实比较更重视实务。由於两者我都讨论,所以当你的编译器(s) 和 C++ 标准不一致 时,本书可以协助你,告诉你如何使用目前既有的架构来模拟编译器(s) 尚未支援的语言特
bbs.theithome.com


性。而当你决定将一些原本绕道而行的解决办法以新支援的语言特性取代时,本书亦可引导 你。 注意当我说到编译器(s) 时,我使用复数。不同的编译器对 C++ 标准的满足程度各不 相同,所以我鼓励你在至少两种编译器(s) 平台上发展程式码。这么做可以帮助你避免不经 意地依赖某个编译器专属的语言延伸性质,或是误用某个编译器对标准规格的错误阐示。这 也可以帮助你避免使用过度先进的编译器技术,例如独家厂商才做得出的某种语言新特性。 如此特性往往实作不够精良(臭虫多,要不就是表现迟缓,或是两者兼具),而且 C++ 社群 往往对这些特性缺乏使用经验,无法给你应用上的忠告。雷霆万钧之势固然令人兴奋,但当 你的目标是要产出可靠的码,恐怕还是步步为营(并且能够与人合作)得好。 本书用了两个你可能不甚熟悉的 C++ 性质,它们都是晚近才加入 C++ 标准之中。某些 编译器支援它们,但如果你的编译器不支援,你可轻易以你所熟悉的其他性质来模拟它们。 第一个性质是型别 bool,其值必为关键字 true 或 false。如果你的编译器尚未支援 bool,有两个方法可以模拟它。第一个方法是使用一个 global enum:enum bool { false, true }; 这允许你将参数为 bool 或 int 的不同函式加以多载化(overloading)。缺点是,内建的「比 较运算子(comparison operators)」如==, <, >=, 等等仍旧传回 ints。 所以以下程式码的行为不如我们所预期: void f(int); void f(bool); int x, y; ... f( x < y ); // 呼叫 f(int),但其实它应该呼叫 f(bool) 一旦你改用真正支援 bool 的编译器,这种 enum 近似法可能会造成程式行为的 改变。 另一种作法是利用 typedef 来定义 bool,并以常数物件做为 true 和 false: typedef int bool; const bool false = 0; const bool true = 1; 这种手法相容於传统的 C/C++ 语意。使用这种模拟法的程式,在移植到一个支援有 bool 型别的编译器平台之後,行为并不会改变。缺点则是无法在函式多载化(overloading)时 区分 bool 和 int。以上两种近似法都有道理,请选择最适合你的一种。 第二个新性质,其实是四个转型运算子:static_cast, const_cast, dynamic_cast, 和 reinterpret_cast。如果你不熟悉这些转型运算子,请翻到条款 2 仔细阅读其中内容。 它们不只比它们所取代的 C 旧式转型做得更多,也更好。书中任何时候当我需要执行转型 动作,我都使用新式的转型运算子。 C++ 拥有比语言本身更丰富的东西。是的,C++ 还有一个伟大的标准程式库(见条款 E49)。我尽可能使用标准程式库所提供的 string 型别来取代 char* 指标,而且我也鼓励你 这么做。string objects 并不比 char*-based 字串难操作,它们的好处是可以免除你大部 份的记忆体管理工作。而且如果发生 exception 的话(见条款 9 和 10),string objects 比 较没有 memory leaks(记忆体遗失)的问题。 实作良好的 string 型别甚至可和对应的 char* 比赛效率,而且可能会赢(条款 29 会 告诉你个中故事)。如果你不打算使用标准的 string 型别,你当然会使用类似 string 的其 他 classes,是吧?是的,用它,因为任何东西都比直接使用 char* 来得好。 我将尽可能使用标准程式库提供的资料结构。这些资料结构来自 Standard Template Library("STL" — 见条款 35)。STL 包含 bitsets, vectors, lists, queues,stacks, maps, sets, 以及更多东西,你应该尽量使用这些标准化的资料结构,不要情不自禁地想写一个自 己的版本。你的编译器或许没有附 STL 给你,但不要因为这样就不使用它。感谢 Silicon Graphics 公司的热心,你可以从 SGI STL 网站下载一份免费产品,它可以和多种编译器搭 配。 如果你目前正在使用一个内含各种演算法和资料结构的程式库,而且用得相当愉快,那 么就没有必要只为了「标准」两个字而改用 STL。然而如果你在「使用 STL」和「自行撰写
bbs.theithome.com


同等功能的码」之间可以选择,你应该让自己倾向使用 STL。记得程式码的重用性吗?STL (以及标准程式库的其他组件)之中有许多码是十分值得重复运用的。
2.2 惯例与术语
任何时候如果我谈到 inheritance(继承),我的意思是 public inheritance(见条款 E35)。如果我不是指 public inheritance,我会明白地指明。绘制继承体系图时,我对 base-derived 关系的描述方式,是从 derived classes 往 base classes 画箭头。 例如,下面是条款 31 的一张继承体系图:
GameObject
SpaceShip Asteroid SpaceStation
这样的表现方式和我在 Effective C++ 第一版(注意,不是第二版)所采用的习惯不 同。现在我决定使用这种最广被接受的继承箭头画法:从 derived classes 画往 base classes,而且我很高兴事情终能归於一统。此类示意图中,抽象类别(abstract classes, 例如上图的 GameObject)被我加上阴影而具象类别(concrete classes,例如上图的 SpaceShip)未加阴影。 Inheritance(继承机制)会引发「pointers(或 references)拥有两个不同型别」的 议题,两个型别分别是静态型别(static type)和动态型别(dynamic type)。Pointer 或 reference 的「静态型别」是指其宣告时的型别,「动态型别」则由它们实际所指的物件来 决定。下面是根据上图所写的一个例子: GameObject *pgo = // pgo 的静态型别是 GameObject*, new SpaceShip; // 动态型别是 SpaceShip* Asteroid *pa = new Asteroid; // pa 的静态型别是 Asteroid*, // 动态型别也是 Asteroid*。 pgo = pa; // pgo 的静态型别仍然(永远)是 GameObject*, // 至於其动态型别如今是 Asteroid*。 GameObject& rgo = *pa; // rgo 的静态型别是 GameObject, // 动态型别是 Asteroid。 这些例子也示范了我喜欢的一种命名方式。pgo 是一个 pointer-to-GameObject;pa 是一个 pointer-to-Asteroid;rgo 是一个 reference-to-GameObject。我常常以此方式来 为 pointer 和 reference 命名。 我很喜欢两个参数名称:lhs 和 rhs,它们分别是"left-hand side" 和"right-hand side" 的缩写。为了了解这些名称背後的基本原理,请考虑一个用来表示分数(rational numbers) 的 class: class Rational { ... }; 如果我想要一个用以比较两个 Rational objects 的函式,我可能会这样宣告: bool operator==(const Rational& lhs, const Rational& rhs); 这使我得以写出这样的码: Rational r1, r2; ... if (r1 == r2) ... 在呼叫 operator== 的过程中,r1 位於"==" 左侧,被系结於 lhs,r2 位於"=="右侧, 被系结於 rhs。 我使用的其他缩写名称还包括:ctor 代表"constructor",dtor 代表"destructor", RTTI 代表 C++ 对 runtime type identification 的支援(在此性质中,dynamic_cast 是 最常被使用的一个零组件)。
bbs.theithome.com


当你配置记忆体而没有释放它,你就有了 memory leak(记忆体遗失)问题。Memory leaks 在 C 和 C++ 中都有,但是在 C++ 中,memory leaks 所遗失的还不只是记忆体,因为 C++ 会 在 物 件 被 产 生 时 , 自 动 呼 叫 constructors , 而 constructors 本 身 可 能 亦 配 有 资 源 (resources)。举个例子,考虑以下程式码: class Widget { ... }; // 某个 class — 它是什么并不重要。 Widget *pw = new Widget; // 动态配置一个 Widget 物件。 ... // 假设 pw 一直未被删除(deleted)。 这段码会遗失记忆体,因为 pw 所指的 Widget 物件从未被删除。如果 Widget constructor 配 置 了 其 他 资 源 ( 例 如 file descriptors, semaphores, window handles,database locks),这些资源原本应该在 Widget 物件被摧毁时释放,现在也像记 忆体一样都遗失掉了。为了强调在 C++ 中 memory leaks 往往也会遗失其他资源,我在书中 常以 resource leaks 一词取代 memory leaks。 你不会在本书中看到许多 inline 函式。并不是我不喜欢 inlining,事实上我相信 inline 函式是 C++ 的一项重要性质。然而决定一个函式是否应被 inlined,条件十分复杂、 敏感、而且与平台有关(见条款 E33)。所以我尽量避免 inlining,除非其中有个关键点非 使用 inlining 不可。当你在本书之中看到一个 non-inline 函式,并不意味我认为把它宣 告为 inline 是个坏主意,而只是说,它「是否为 inline」与当时讨论的主题无关。 有一些传统的 C++ 性质已明白地被标准委员会排除。这样的性质被明列於语言的最後撤除 名单,因为新性质已经加入,取代那些传统性质的原本工作,而且做得更好。这本书中我会 检视被撤除的性质,并说明其取代者。你应该避免使用被撤除的性质,但是过度在意倒亦不 必,因为编译器厂商为了挽留其客户,会尽力保存回溯相容性,所以那些被撤除的性质大约 还会存活好多年。 所谓 client,是指你所写的程式码的客户。或许是某些人(程式员),或许是某些物 (classes 或 functions)。举个例子,如果你写了一个 Date class(用来表现生日、最後 期限、耶稣再次降临日等等),任何使用了这个 class 的人,便是你的 client。任何一段使 用了 Date class 的码,也是你的 clients。Clients 是重要的。 事实上 clients 是游戏的主角。如果没有人使用你写的软体,你又何必写它呢?你会 发现我很在意如何让 clients 更轻松,通常这会导至你的行事更困难,因为好的软体「以 客为尊」。如果你讥笑我太过滥情,不妨反躬自省一下。你曾经使用过自己写的 classes 或 functions 吗?如果是,你就是你自己的 client,所以让 clients 更轻松,其实就是让自 己更轻松,利人利己。 当我讨论 class template 或 function templates 以及由它们所产生出来的 classes 或 functions 时,请容我保留偷懒的权利,不一一写出 templates 和其 instantiations(具 现体)之间的差异。举个例子,如果 Array 是个 class template,有个型别参数 T,我可 能会以 Array 代表此 template 的某个特定具现体(instantiation),虽然其实 Array<T> 才 是正式的 class 名称。同样道理,如果 swap 是个 function template,有个型别参数 T, 我可能会以 swap 而非 swap<T> 表示其具现体。如果这样的简短表示法在当时情况下不够清 楚,我便会在表示 template 具现体时加上 template 参数。
2.3 臭虫报告,意见提供,内容更新
我尽力让这本书技术精准、可读性高,而且有用,但是我知道一定仍有改善空间。 如果你发现任何错误— 技术性的、语言上的、错别字、或任何其他东西— 请告诉我。 我会试著在本书新刷中修正之。如果你是第一位告诉我的人,我会很高兴将你的大名登录到 本书致谢文(acknowledgments)内。如果你有改善建议,我也非常欢迎。 我将继续收集 C++ 程式设计的实效准则。如果你有任何这方面的想法并愿意与我分享, 我会十分高兴。请将你的建议、你的见解、你的批评、以及你的臭虫报告,寄至: Scott Meyers c/o Editor-in-Chief, Corporate and Professional Publishing Addison-Wesley Publishing Company 1 Jacob Way
bbs.theithome.com


Reading, MA 01867 U. S. A. 或者你也可以送电子邮件到 mec++@awl.com。 我维护有一份本书第一刷以来的修订记录,其中包括错误修正、文字修润、以及技术更 新。你可以从本书网站取得这份记录,以及其他与本书相关的资讯。你也可以透过 anonymous FTP,从 ftp.awl.com 的 cp/mec++ 目录中取得它。如果你希望拥有这份资料,但无法上网, 请寄申请函到上述地址,我会邮寄一份给你。 这篇序文有够长的,让我们开始正题吧。
3. 基础议题
基础议题。是的,pointers(指针)、references(引用)、casts(类型转换)、arrays (数组)、constructors(构造)- 再沒有比这些更基础的议题了。几乎最简单的 C++ 程序 也会用到其中大部份特性,而许多程序会用到上述所有特性。 尽管你可能已经十分熟悉语言的这一部份,有时候它们还是会令你吃惊。特别是对那些 从 C 转到 C++ 的程序员,因为 references, dynamic casts, default constructors 及其 它 non-C 性质背后的观念,往往带有一股幽暗阴郁的色彩。 這一章描述 pointers 和 references 的差异,並告诉你它们的适当使用时机。本章介 绍新的 C++ 类型转换(casts)语法,並解释为什么新式类型转换法比旧式的 C 类型转换法 优越。本章也检验 C 的数组概念以及 C++ 的多态(polymorphism)概念,並说明为什么將 这两者混合运用是不智之举。最后,本章讨论 default constructors(默认构造函数)的 正方和反方意见,並提出一些建议作法,让你回避语言的束缚(因为在你不需 default constructors 的情況下,C++ 也会给你一个。 只要留心下面各条款的各项忠告,你将向著一個很好的目标迈进:你所生产的软件可以 清楚而正确地表現出你的设计意图。
3.1 Item M1:指针与引用的区别
指针与引用看上去完全不同(指针用操作符“*”和“->”,引用使用操作符“. ”),但
是它们似乎有相同的功能。指针与引用都是让你间接引用其他对象。你如何决定在什么时候
使用指针,在什么时候使用引用呢?
首先,要认识到在任何情况下都不能使用指向空值的引用。一个引用必须总是指向某些
对象。因此如果你使用一个变量并让它指向一个对象,但是该变量在某些时候也可能不指向
任何对象,这时你应该把变量声明为指针,因为这样你可以赋空值给该变量。相反,如果变
量肯定指向一个对象,例如你的设计不允许变量为空,这时你就可以把变量声明为引用。
“但是,请等一下”,你怀疑地问,“这样的代码会产生什么样的后果?”
char *pc = 0; // 设置指针为空值
char& rc = *pc; // 让引用指向空值
这是非常有害的,毫无疑问。结果将是不确定的(编译器能产生一些输出,导致任何事
情都有可能发生)。应该躲开写出这样代码的人,除非他们同意改正错误。如果你担心这样
的代码会出现在你的软件里,那么你最好完全避免使用引用,要不然就去让更优秀的程序员
去做。我们以后将忽略一个引用指向空值的可能性。
因为引用肯定会指向一个对象,在 C++里,引用应被初始化。
bbs.theithome.com


string& rs; // 错误,引用必须被初始化
string s("xyzzy");
string& rs = s; // 正确,rs 指向 s
指针没有这样的限制。
string *ps; // 未初始化的指针
// 合法但危险
不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在
使用引用之前不需要测试它的合法性。
void printDouble(const double& rd)
{
cout << rd; // 不需要测试 rd,它
} // 肯定指向一个 double 值
相反,指针则应该总是被测试,防止其为空:
void printDouble(const double *pd)
{
if (pd) { // 检查是否为 NULL
cout << *pd;
}
}
指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是
引用则总是指向在初始化时被指定的对象,以后不能改变。
string s1("Nancy");
string s2("Clancy");
string& rs = s1; // rs 引用 s1
string *ps = &s1; // ps 指向 s1
rs = s2; // rs 仍旧引用 s1,
// 但是 s1 的值现在是
// "Clancy"
ps = &s2; // ps 现在指向 s2;
// s1 没有改变
总的来说,在以下情况下你应该使用指针,一是你考虑到存在不指向任何对象的可能(在
这种情况下,你能够设置指针为空),二是你需要能够在不同的时刻指向不同的对象(在这
种情况下,你能改变指针的指向)。如果总是指向一个对象并且一旦指向一个对象后就不会
改变指向,那么你应该使用引用。
bbs.theithome.com


还有一种情况,就是当你重载某个操作符时,你应该使用引用。最普通的例子是操作符
[]。这个操作符典型的用法是返回一个目标对象,其能被赋值。
vector<int> v(10); // 建立整形向量(vector),大小为 10;
// 向量是一个在标准 C 库中的一个模板(见条款 M35)
v[5] = 10; // 这个被赋值的目标对象就是操作符[]返回的值
如果操作符[]返回一个指针,那么后一个语句就得这样写:
*v[5] = 10;
但是这样会使得 v 看上去象是一个向量指针。因此你会选择让操作符返回一个引用。
(这有一个有趣的例外,参见条款 M30)
当你知道你必须指向一个对象并且不想改变其指向时,或者在重载操作符并为防止不必
要的语义误解时,你不应该使用指针。而在除此之外的其他情况下,则应使用指针。
3.2 Item M2:尽量使用C++风格的类型转换
仔细想想地位卑贱的类型转换功能(cast),其在程序设计中的地位就象 goto 语句一样
令人鄙视。但是它还不是无法令人忍受,因为当在某些紧要的关头,类型转换还是必需的,
这时它是一个必需品。
不过 C 风格的类型转换并不代表所有的类型转换功能。
一来它们过于粗鲁,能允许你在任何类型之间进行转换。不过如果要进行更精确的类型
转换,这会是一个优点。在这些类型转换中存在着巨大的不同,例如把一个指向 const 对象
的 指 针 ( pointer-to-const-object ) 转 换 成 指 向 非 const 对 象 的 指 针
(pointer-to-non-const-object)(即一个仅仅去除 const 的类型转换),把一个指向基类
的指针转换成指向子类的指针(即完全改变对象类型)。传统的 C 风格的类型转换不对上述
两种转换进行区分。(这一点也不令人惊讶,因为 C 风格的类型转换是为 C 语言设计的,而
不是为 C++语言设计的)。
二来 C 风格的类型转换在程序语句中难以识别。在语法上,类型转换由圆括号和标识符
组成,而这些可以用在 C++中的任何地方。这使得回答象这样一个最基本的有关类型转换
的问题变得很困难:“在这个程序中是否使用了类型转换?”。这是因为人工阅读很可能忽略
了类型转换的语句,而利用象 grep 的工具程序也不能从语句构成上区分出它们来。
C++通过引进四个新的类型转换操作符克服了 C 风格类型转换的缺点,这四个操作符是,
static_cast, const_cast, dynamic_cast, 和 reinterpret_cast。在大多数情况下,对于
这些操作符你只需要知道原来你习惯于这样写,
(type) expression
而现在你总应该这样写:
static_cast<type>(expression)
bbs.theithome.com


例如,假设你想把一个 int 转换成 double,以便让包含 int 类型变量的表达式产生出
浮点数值的结果。如果用 C 风格的类型转换,你能这样写:
int firstNumber, secondNumber;
...
double result = ((double)firstNumber)/secondNumber;
如果用上述新的类型转换方法,你应该这样写:
double result = static_cast<double>(firstNumber)/secondNumber;
这样的类型转换不论是对人工还是对程序都很容易识别。
static_cast 在功能上基本上与 C 风格的类型转换一样强大,含义也一样。它也有功能
上限制。例如,你不能用 static_cast 象用 C 风格的类型转换一样把 struct 转换成 int 类
型或者把 double 类型转换成指针类型,另外,static_cast 不能从表达式中去除 const 属
性,因为另一个新的类型转换操作符 const_cast 有这样的功能。
其它新的 C++类型转换操作符被用在需要更多限制的地方。const_cast 用于类型转换掉
表达式的 const 或 volatileness 属性。通过使用 const_cast,你向人们和编译器强调你通
过类型转换想做的只是改变一些东西的 constness 或者 volatileness 属性。这个含义被编
译器所约束。如果你试图使用 const_cast 来完成修改 constness 或者 volatileness 属性
之外的事情,你的类型转换将被拒绝。下面是一些例子:
class Widget { ... };
class SpecialWidget: public Widget { ... };
void update(SpecialWidget *psw);
SpecialWidget sw; // sw 是一个非 const 对象。
const SpecialWidget& csw = sw; // csw 是 sw 的一个引用
// 它是一个 const 对象
update(&csw); // 错误!不能传递一个 const SpecialWidget* 变量
// 给一个处理 SpecialWidget*类型变量的函数
update(const_cast<SpecialWidget*>(&csw));
// 正确,csw 的 const 被显示地转换掉(
// csw 和 sw 两个变量值在 update
//函数中能被更新)
update((SpecialWidget*)&csw);
// 同上,但用了一个更难识别
//的 C 风格的类型转换
Widget *pw = new SpecialWidget;
update(pw); // 错误!pw 的类型是 Widget*,但是
bbs.theithome.com


// update 函数处理的是 SpecialWidget*类型
update(const_cast<SpecialWidget*>(pw));
// 错误!const_cast 仅能被用在影响
// constness or volatileness 的地方上。,
// 不能用在向继承子类进行类型转换。
到目前为止,const_cast 最普通的用途就是转换掉对象的 const 属性。
第二种特殊的类型转换符是 dynamic_cast,它被用于安全地沿着类的继承关系向下进
行类型转换。这就是说,你能用 dynamic_cast 把指向基类的指针或引用转换成指向其派生
类或其兄弟类的指针或引用,而且你能知道转换是否成功。失败的转换将返回空指针(当对
指针进行类型转换时)或者抛出异常(当对引用进行类型转换时):
Widget *pw;
...
update(dynamic_cast<SpecialWidget*>(pw));
// 正确,传递给 update 函数一个指针
// 是指向变量类型为 SpecialWidget 的 pw 的指针
// 如果 pw 确实指向一个对象,
// 否则传递过去的将使空指针。
void updateViaRef(SpecialWidget& rsw);
updateViaRef(dynamic_cast<SpecialWidget&>(*pw));
//正确。 传递给 updateViaRef 函数
// SpecialWidget pw 指针,如果 pw
// 确实指向了某个对象
// 否则将抛出异常
dynamic_casts 在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型
上(参见条款 M24),也不能用它来转换掉 constness:
int firstNumber, secondNumber;
...
double result = dynamic_cast<double>(firstNumber)/secondNumber;
// 错误!没有继承关系
const SpecialWidget sw;
...
update(dynamic_cast<SpecialWidget*>(&sw));
// 错误! dynamic_cast 不能转换
// 掉 const。
bbs.theithome.com


如你想在没有继承关系的类型中进行转换,你可能想到 static_cast。如果是为了去除
const,你总得用 const_cast。
这四个类型转换符中的最后一个是 reinterpret_cast。使用这个操作符的类型转换,
其 的 转 换 结 果 几 乎 都 是 执 行 期 定 义 ( implementation-defined )。 因 此 , 使 用
reinterpret_casts 的代码很难移植。
reinterpret_casts 的最普通的用途就是在函数指针类型之间进行转换。例如,假设你
有一个函数指针数组:
typedef void (*FuncPtr)(); // FuncPtr is 一个指向函数
// 的指针,该函数没有参数
// 返回值类型为 void
FuncPtr funcPtrArray[10]; // funcPtrArray 是一个能容纳
// 10 个 FuncPtrs 指针的数组
让我们假设你希望(因为某些莫名其妙的原因)把一个指向下面函数的指针存入
funcPtrArray 数组:
int doSomething();
你不能不经过类型转换而直接去做,因为 doSomething 函数对于 funcPtrArray 数组来
说有一个错误的类型。在 FuncPtrArray 数组里的函数返回值是 void 类型,而 doSomething
函数返回值是 int 类型。
funcPtrArray[0] = &doSomething; // 错误!类型不匹配
reinterpret_cast 可以让你迫使编译器以你的方法去看待它们:
funcPtrArray[0] = // this compiles
reinterpret_cast<FuncPtr>(&doSomething);
转换函数指针的代码是不可移植的(C++不保证所有的函数指针都被用一样的方法表
示),在一些情况下这样的转换会产生不正确的结果(参见条款 M31),所以你应该避免转换
函数指针类型,除非你处于着背水一战和尖刀架喉的危急时刻。一把锋利的刀。一把非常锋
利的刀。
如果你使用的编译器缺乏对新的类型转换方式的支持,你可以用传统的类型转换方法代
替 static_cast, const_cast, 以及 reinterpret_cast。也可以用下面的宏替换来模拟新的
类型转换语法:
#define static_cast(TYPE,EXPR) ((TYPE)(EXPR))
#define const_cast(TYPE,EXPR) ((TYPE)(EXPR))
#define reinterpret_cast(TYPE,EXPR) ((TYPE)(EXPR))
你可以象这样使用使用:
double result = static_cast(double, firstNumber)/secondNumber;
bbs.theithome.com


update(const_cast(SpecialWidget*, &sw));
funcPtrArray[0] = reinterpret_cast(FuncPtr, &doSomething);
这些模拟不会象真实的操作符一样安全,但是当你的编译器可以支持新的的类型转换
时,它们可以简化你把代码升级的过程。
没有一个容易的方法来模拟 dynamic_cast 的操作,但是很多函数库提供了函数,安全
地在派生类与基类之间进行类型转换。如果你没有这些函数而你有必须进行这样的类型转
换,你也可以回到 C 风格的类型转换方法上,但是这样的话你将不能获知类型转换是否失败。
当然,你也可以定义一个宏来模拟 dynamic_cast 的功能,就象模拟其它的类型转换一样:
#define dynamic_cast(TYPE,EXPR) (TYPE)(EXPR)
请记住,这个模拟并不能完全实现 dynamic_cast 的功能,它没有办法知道转换是否失
败。
我知道,是的,我知道,新的类型转换操作符不是很美观而且用键盘键入也很麻烦。如
果你发现它们看上去实在令人讨厌,C 风格的类型转换还可以继续使用并且合法。然而,正
是因为新的类型转换符缺乏美感才能使它弥补了在含义精确性和可辨认性上的缺点。并且,
使用新类型转换符的程序更容易被解析(不论是对人工还是对于工具程序),它们允许编译
器检测出原来不能发现的错误。这些都是放弃 C 风格类型转换方法的强有力的理由。还有第
三个理由:也许让类型转换符不美观和键入麻烦是一件好事。
3.3 Item M3:不要对数组使用多态
类继承的最重要的特性是你可以通过基类指针或引用来操作派生类。这样的指针或引用
具有行为的多态性,就好像它们同时具有多种形态。C++允许你通过基类指针和引用来操作
派生类数组。不过这根本就不是一个特性,因为这样的代码几乎从不如你所愿地那样运行。
假设你有一个类 BST(比如是搜索树对象)和继承自 BST 类的派生类 BalancedBST:
class BST { ... };
class BalancedBST: public BST { ... };
在一个真实的程序里,这样的类应该是模板类,但是在这个例子里并不重要,加上模板
只会使得代码更难阅读。为了便于讨论,我们假设 BST 和 BalancedBST 只包含 int 类型数据。
有这样一个函数,它能打印出 BST 类数组中每一个 BST 对象的内容:
void printBSTArray(ostream& s,
const BST array[],
int numElements)
{
for (int i = 0; i < numElements; ) {
s << array[i]; //假设 BST 类
bbs.theithome.com


} //重载了操作符<<
}
当你传递给该函数一个含有 BST 对象的数组变量时,它能够正常运行:
BST BSTArray[10];
...
printBSTArray(cout, BSTArray, 10); // 运行正常
然而,请考虑一下,当你把含有 BalancedBST 对象的数组变量传递给 printBSTArray
函数时,会产生什么样的后果:
BalancedBST bBSTArray[10];
...
printBSTArray(cout, bBSTArray, 10); // 还会运行正常么?
你的编译器将会毫无警告地编译这个函数,但是再看一下这个函数的循环代码:
for (int i = 0; i < numElements; ) {
s << array[i];
}
这里的 array[I]只是一个指针算法的缩写:它所代表的是*(array)。我们知道 array
是一个指向数组起始地址的指针,但是 array 中各元素内存地址与数组的起始地址的间隔究
竟有多大呢?它们的间隔是 i*sizeof(一个在数组里的对象),因为在 array 数组[0]到[I]
间有 I 个对象。编译器为了建立正确遍历数组的执行代码,它必须能够确定数组中对象的大
小,这对编译器来说是很容易做到的。参数 array 被声明为 BST 类型,所以 array 数组中每
一个元素都是 BST 类型,因此每个元素与数组起始地址的间隔是 i*sizeof(BST)。
至少你的编译器是这么认为的。但是如果你把一个含有 BalancedBST 对象的数组变量传
递给 printBSTArray 函数,你的编译器就会犯错误。在这种情况下,编译器原先已经假设数
组中元素与 BST 对象的大小一致,但是现在数组中每一个对象大小却与 BalancedBST 一致。
派生类的长度通常都比基类要长。我们料想 BalancedBST 对象长度的比 BST 长。如果如此的
话,printBSTArray 函数生成的指针算法将是错误的,没有人知道如果用 BalancedBST 数组
来执行 printBSTArray 函数将会发生什么样的后果。不论是什么后果都是令人不愉快的。
如果你试图删除一个含有派生类对象的数组,将会发生各种各样的问题。以下是一种你
可能采用的但不正确的做法。
//删除一个数组, 但是首先记录一个删除信息
void deleteArray(ostream& logStream, BST array[])
{
logStream << "Deleting array at address "
<< static_cast<void*>(array) << '\n';
bbs.theithome.com


delete [] array;
}
BalancedBST *balTreeArray = // 建立一个 BalancedBST 对象数组
new BalancedBST[50];
...
deleteArray(cout, balTreeArray); // 记录这个删除操作
这里面也掩藏着你看不到的指针算法。当一个数组被删除时,每一个数组元素的析构函
数也会被调用。当编译器遇到这样的代码:
delete [] array;
它肯定象这样生成代码:
// 以与构造顺序相反的顺序来
// 解构 array 数组里的对象
for ( int i = 数组元素的个数 1; i >= 0;--i)
{
array[i].BST::~BST(); // 调用 array[i]的
} // 析构函数
因为你所编写的循环语句根本不能正确运行,所以当编译成可执行代码后,也不可能正
常运行。语言规范中说通过一个基类指针来删除一个含有派生类对象的数组,结果将是不确
定的。这实际意味着执行这样的代码肯定不会有什么好结果。多态和指针算法不能混合在一
起来用,所以数组与多态也不能用在一起。
值得注意的是如果你不从一个具体类(concrete classes)(例如 BST)派生出另一个
具体类(例如 BalancedBST),那么你就不太可能犯这种使用多态性数组的错误。正如条款
M33 所解释的,不从具体类派生出具体类有很多好处。我希望你阅读一下条款 M33 的内容。
(WQ 加注:VC++中,能够有正确的结果,因为它根本没有数组 new/delete 函数。)
3.4 Item M4:避免无用的缺省构造函数
缺省构造函数(指没有参数的构造函数)在 C++语言中是一种让你无中生有的方法。构
造函数能初始化对象,而缺省构造函数则可以不利用任何在建立对象时的外部数据就能初始
化对象。有时这样的方法是不错的。例如一些行为特性与数字相仿的对象被初始化为空值或
不确定的值也是合理的,还有比如链表、哈希表、图等等数据结构也可以被初始化为空容器。
但不是所有的对象都属于上述类型,对于很多对象来说,不利用外部数据进行完全的初
始化是不合理的。比如一个没有输入姓名的地址簿对象,就没有任何意义。在一些公司里,
所有的设备都必须标有一个公司 ID 号码,所以在建立对象以模型化一个设备时,不提供一
个合适的 ID 号码,所建立的对象就根本没有意义。
bbs.theithome.com


在一个完美的世界里,无需任何数据即可建立对象的类可以包含缺省构造函数,而需要
数据来建立对象的类则不能包含缺省构造函数。唉!可是我们的现实世界不是完美的,所以
我们必须考虑更多的因素。特别是如果一个类没有缺省构造函数,就会存在一些使用上的限
制。
请考虑一下有这样一个类,它表示公司的设备,这个类包含一个公司的 ID 代码,这个
ID 代码被强制做为构造函数的参数:
class EquipmentPiece {
public:
EquipmentPiece(int IDNumber);
...
};
因为 EquipmentPiece 类没有一个缺省构造函数,所以在三种情况下使用它,就会遇到
问题。第一中情况是建立数组时。一般来说,没有一种办法能在建立对象数组时给构造函数
传递参数。所以在通常情况下,不可能建立 EquipmentPiece 对象数组:
EquipmentPiece bestPieces[10]; // 错误!没有正确调用
// EquipmentPiece 构造函数
EquipmentPiece *bestPieces =
new EquipmentPiece[10]; // 错误!与上面的问题一样
不过还是有三种方法能回避开这个限制。对于使用非堆数组(non-heap arrays)(即不在堆
中给数组分配内存。译者注)的一种解决方法是在数组定义时提供必要的参数:
int ID1, ID2, ID3, ..., ID10; // 存储设备 ID 号的
// 变量
...
EquipmentPiece bestPieces[] = { // 正确, 提供了构造
EquipmentPiece(ID1), // 函数的参数
EquipmentPiece(ID2),
EquipmentPiece(ID3),
...,
EquipmentPiece(ID10)
};
不过很遗憾,这种方法不能用在堆数组(heap arrays)的定义上。
一个更通用的解决方法是利用指针数组来代替一个对象数组:
typedef EquipmentPiece* PEP; // PEP 指针指向
//一个 EquipmentPiece 对象
bbs.theithome.com


PEP bestPieces[10]; // 正确, 没有调用构造函数
PEP *bestPieces = new PEP[10]; // 也正确
在指针数组里的每一个指针被重新赋值,以指向一个不同的 EquipmentPiece 对象:
for (int i = 0; i < 10; ++i)
bestPieces[i] = new EquipmentPiece( ID Number );
不过这中方法有两个缺点,第一你必须删除数组里每个指针所指向的对象。如果你忘了,
就会发生内存泄漏。第二增加了内存分配量,因为正如你需要空间来容纳 EquipmentPiece
对象一样,你也需要空间来容纳指针。
如果你为数组分配 raw memory,你就可以避免浪费内存。使用 placement new 方法(参
见条款 M8)在内存中构造 EquipmentPiece 对象:
// 为大小为 10 的数组 分配足够的内存
// EquipmentPiece 对象; 详细情况请参见条款 M8
// operator new[] 函数
void *rawMemory =
operator new[](10*sizeof(EquipmentPiece));
// make bestPieces point to it so it can be treated as an
// EquipmentPiece array
EquipmentPiece *bestPieces =
static_cast<EquipmentPiece*>(rawMemory);
// construct the EquipmentPiece objects in the memory
// 使用"placement new" (参见条款 M8)
for (int i = 0; i < 10; ++i)
new (&bestPieces[i]) EquipmentPiece( ID Number );
注意你仍旧得为每一个 EquipmentPiece 对象提供构造函数参数。这个技术(和指针数
组的主意一样)允许你在没有缺省构造函数的情况下建立一个对象数组。它没有绕过对构造
函数参数的需求,实际上也做不到。如果能做到的话,就不能保证对象被正确初始化。
使用 placement new 的缺点除了是大多数程序员对它不熟悉外(能使用它就更难了),
还有就是当你不想让它继续存在使用时,必须手动调用数组对象的析构函数,然后调用操作
符 delete[] 来 释 放 raw memory (请 再 参 见 条 款 M8 ):( WQ 加 注 , 已 经 有 placement
delete/delete []操作符了,它会自动调用析构函数。)
// 以与构造 bestPieces 对象相反的顺序
// 解构它。
for (int i = 9; i >= 0; --i)
bbs.theithome.com


bestPieces[i].~EquipmentPiece();
// deallocate the raw memory
operator delete[](rawMemory);
如果你忘记了这个要求而使用了普通的数组删除方法,那么你程序的运行将是不可预测
的。这是因为:直接删除一个不是用 new 操作符来分配的内存指针,其结果没有被定义。
delete [] bestPieces; // 没有定义! bestPieces
//不是用 new 操作符分配的。
有关 new、placement new 和它们如何与构造函数、析构函数一起使用的更多信息,请
见条款 M8。
对于类里没有定义缺省构造函数所造成的第二个问题是它们无法在许多基于模板
(template-based)的容器类里使用。因为实例化一个模板时,模板的类型参数应该提供一
个缺省构造函数,这是一个常见的要求。这个要求总是来自于模板内部,被建立的模板参数
类型数组里。例如一个数组模板类:
template<class T>
class Array {
public:
Array(int size);
...
private:
T *data;
};
template<class T>
Array<T>::Array(int size)
{
data = new T[size]; // 为每个数组元素
... //依次调用 T::T()
}
在多数情况下,通过仔细设计模板可以杜绝对缺省构造函数的需求。例如标准的 vector
模板(生成一个类似于可扩展数组的类)对它的类型参数没有必须有缺省构造函数的要求。
不幸的是,很多模板类没有以仔细的态度去设计。这样,没有缺省构造函数的类就不能与许
多模板兼容。当 C++程序员深入领会了模板设计以后,这样的问题应该不再那么突出了。这
会花多长时间,完全在于个人的造化。
最后讲一下在设计虚基类时所面临的要提供缺省构造函数还是不提供缺省构造函数的
两难决策。不提供缺省构造函数的虚基类,很难与其进行合作。因为几乎所有的派生类在实
bbs.theithome.com


例化时都必须给虚基类构造函数提供参数。这就要求所有由没有缺省构造函数的虚基类继承
下来的派生类(无论有多远)都必须知道并理解提供给虚基类构造函数的参数的含义。派生类
的作者是不会企盼和喜欢这种规定的。
因为这些强加于没有缺省构造函数的类上的种种限制,一些人认为所有的类都应该有缺
省构造函数,即使缺省构造函数没有足够的数据来完整初始化一个对象。比如这个原则的拥
护者会这样修改 EquipmentPiece 类:
class EquipmentPiece {
public:
EquipmentPiece( int IDNumber = UNSPECIFIED);
...
private:
static const int UNSPECIFIED; // 其值代表 ID 值不确定。
};
这允许这样建立 EquipmentPiece 对象
EquipmentPiece e; //这样合法
这样的修改使得其他成员函数变得复杂,因为不再能确保 EquipmentPiece 对象进行了
有意义的初始化。假设它建立一个因没有 ID 而没有意义的 EquipmentPiece 对象,那么大多
数成员函数必须检测 ID 是否存在。如果不存在 ID,它们将必须指出怎么犯的错误。不过通
常不明确应该怎么去做,很多代码的实现什么也没有提供:只是抛出一个异常或调用一个函
数终止程序。当这种情形发生时,很难说提供缺省构造函数而放弃了一种保证机制的做法是
否能提高软件的总体质量。
提供无意义的缺省构造函数也会影响类的工作效率。如果成员函数必须测试所有的部分
是否都被正确地初始化,那么这些函数的调用者就得为此付出更多的时间。而且还得付出更
多的代码,因为这使得可执行文件或库变得更大。它们也得在测试失败的地方放置代码来处
理错误。如果一个类的构造函数能够确保所有的部分被正确初始化,所有这些弊病都能够避
免。缺省构造函数一般不会提供这种保证,所以在它们可能使类变得没有意义时,尽量去避
免使用它们。使用这种(没有缺省构造函数的)类的确有一些限制,但是当你使用它时,它
也给你提供了一种保证:你能相信这个类被正确地建立和高效地实现。
4. 运算符
运算符重载--你不得不喜欢它们!它们允许给予你的自定义类型有着和 C++内建类
型完全相样的语法,更有甚者,它们允许你将强大的能量注入到运算符背后的函数体中,而
这是在内建类型上从未听说过的。当然,你能够使得如同“+”和“==”这样的符号做任何
你想做的事,这个事实意味着使用运算符重载你可能写出的程序完全无法理解。C++的老
bbs.theithome.com


手知道如何驾驭运算符重载的威力而不至于滑落到“不可理解”的深渊。
遗憾的是,很容易导致滑落。单参数的构造函数和隐式类型转换操作符尤其棘手,因为
它们会被调用在没有任何的源代码显示了这样的调用的地方。这会导致程序的行为难于理
解。一个不同的问题发生在重载“&&”和“||”这样的运算符时,因为从内建类型到自定义
类型的类型转换函数在语法上产生了一个微妙的变化,而这一点非常容易被忽视。最后,许
多操作符通过标准的方式彼此的联系在一起,但重载操作符使得改变这种公认的联系成为可
能。
在下面的条款中,我集中解释重载的运算符何时并且如何被调用,它们如何运作,它们
应该如何彼此联系,以及如何获得这些方面的控制权。有了这一章的信息,你可以和专家一
样重载(或不重载)一个运算符。
4.1 Item M5:谨慎定义类型转换函数
C++编译器能够在两种数据类型之间进行隐式转换(implicit conversions),它继承
了 C 语言的转换方法,例如允许把 char 隐式转换为 int 和从 short 隐式转换为 double。因
此当你把一个 short 值传递给准备接受 double 参数值的函数时,依然可以成功运行。C 中
许多这种可怕的转换可能会导致数据的丢失,它们在 C++中依然存在,包括 int 到 short 的
转换和 double 到 char 的转换。
你对这些类型转换是无能为力的,因为它们是语言本身的特性。不过当你增加自己的类
型时,你就可以有更多的控制力,因为你能选择是否提供函数让编译器进行隐式类型转换。
有 两 种 函 数 允 许 编 译 器 进 行 这 些 的 转 换 : 单 参 数 构 造 函 数 ( single-argument
constructors)和隐式类型转换运算符。单参数构造函数是指只用一个参数即可以调用的构
造函数。该函数可以是只定义了一个参数,也可以是虽定义了多个参数但第一个参数以后的
所有参数都有缺省值。以下有两个例子:
class Name { // for names of things
public:
Name(const string& s); // 转换 string 到
// Name
...
};
class Rational { // 有理数类
public:
Rational(int numerator = 0, // 转换 int 到
int denominator = 1); // 有理数类
...
bbs.theithome.com


};
隐式类型转换运算符只是一个样子奇怪的成员函数:operator 关键字,其后跟一个类
型符号。你不用定义函数的返回类型,因为返回类型就是这个函数的名字。例如为了允许
Rational(有理数)类隐式地转换为 double 类型(在用有理数进行混合类型运算时,可能有
用),你可以如此声明 Rational 类:
class Rational {
public:
...
operator double() const; // 转换 Rational 类成
}; // double 类型
在下面这种情况下,这个函数会被自动调用:
Rational r(1, 2); // r 的值是 1/2
double d = 0.5 * r; // 转换 r 到 double,
// 然后做乘法
以上这些说明只是一个复习,我真正想说的是为什么你不需要定义各种类型转换函数。
根本问题是当你在不需要使用转换函数时,这些的函数缺却会被调用运行。结果,这些
不正确的程序会做出一些令人恼火的事情,而你又很难判断出原因。
让我们首先分析一下隐式类型转换运算符,它们是最容易处理的。假设你有一个如上所
述的 Rational 类,你想让该类拥有打印有理数对象的功能,就好像它是一个内置类型。因
此,你可能会这么写:
Rational r(1, 2);
cout << r; // 应该打印出"1/2"
再假设你忘了为 Rational 对象定义 operator<<。你可能想打印操作将失败,因为没有
合适的的 operator<<被调用。但是你错了。当编译器调用 operator<<时,会发现没有这样
的函数存在,但是它会试图找到一个合适的隐式类型转换顺序以使得函数调用正常运行。类
型转换顺序的规则定义是复杂的,但是在现在这种情况下,编译器会发现它们能调用
Rational::operator double 函数来把 r 转换为 double 类型。所以上述代码打印的结果是
一个浮点数,而不是一个有理数。这简直是一个灾难,但是它表明了隐式类型转换的缺点:
它们的存在将导致错误的发生。
解决方法是用不使用语法关键字的等同的函数来替代转换运算符。例如为了把
Rational 对象转换为 double,用 asDouble 函数代替 operator double 函数:
class Rational {
public:
bbs.theithome.com


...
double asDouble() const; //转变 Rational
}; // 成 double
这个成员函数能被显式调用:
Rational r(1, 2);
cout << r; // 错误! Rationa 对象没有
// operator<<
cout << r.asDouble(); // 正确, 用 double 类型
//打印 r
在多数情况下,这种显式转换函数的使用虽然不方便,但是函数被悄悄调用的情况不再
会发生,这点损失是值得的。一般来说,越有经验的 C++程序员就越喜欢避开类型转换运算
符。例如在 C++标准库(参见 Effective C++条款 49 和 M35)委员会工作的人员是在此领
域最有经验的,他们加在库函数中的 string 类型没有包括隐式地从 string 转换成 C 风格的
char*的功能,而是定义了一个成员函数 c_str 用来完成这个转换,这是巧合么?我看不是。
通过单参数构造函数进行隐式类型转换更难消除。而且在很多情况下这些函数所导致的
问题要甚于隐式类型转换运算符。
举一个例子,一个 array 类模板,这些数组需要调用者确定边界的上限与下限:
template<class T>
class Array {
public:
Array(int lowBound, int highBound);
Array(int size);
T& operator[](int index);
...
};
第一个构造函数允许调用者确定数组索引的范围,例如从 10 到 20。它是一个两参数构
造函数,所以不能做为类型转换函数。第二个构造函数让调用者仅仅定义数组元素的个数(使
用方法与内置数组的使用相似),不过不同的是它能做为类型转换函数使用,能导致无穷的
痛苦。
例如比较 Array<int>对象,部分代码如下:
bool operator==( const Array<int>& lhs,
const Array<int>& rhs);
Array<int> a(10);
bbs.theithome.com


Array<int> b(10);
...
for (int i = 0; i < 10; ++i)
if (a == b[i]) { // 哎呦! "a" 应该是 "a[i]"
do something for when
a[i] and b[i] are equal;
}
else {
do something for when they're not;
}
我们想用 a 的每个元素与 b 的每个元素相比较,但是当录入 a 时,我们偶然忘记了数组
下标。当然我们希望编译器能报出各种各样的警告信息,但是它根本没有。因为它把这个调
用看成用 Array<int>参数(对于 a)和 int(对于 b[i])参数调用 operator==函数,然而没有
operator==函数是这样的参数类型,我们的编译器注意到它能通过调用 Array<int>构造函
数能转换 int 类型到 Array<int>类型,这个构造函数只有一个 int 类型的参数。然后编译
器如此去编译,生成的代码就象这样:
for (int i = 0; i < 10; ++i)
if (a == static_cast< Array<int> >(b[i])) ...
每一次循环都把 a 的内容与一个大小为 b[i]的临时数组(内容是未定义的)比较。这
不仅不可能以正确的方法运行,而且还是效率低下的。因为每一次循环我们都必须建立和释
放 Array<int>对象(见条款 M19)。
通过不声明运算符(operator)的方法,可以克服隐式类型转换运算符的缺点,但是单
参数构造函数没有那么简单。毕竟,你确实想给调用者提供一个单参数构造函数。同时你也
希望防止编译器不加鉴别地调用这个构造函数。幸运的是,有一个方法可以让你鱼肉与熊掌
兼得。事实上是两个方法:一是容易的方法,二是当你的编译器不支持容易的方法时所必须
使用的方法。
容易的方法是利用一个最新编译器的特性,explicit 关键字。为了解决隐式类型转换
而特别引入的这个特性,它的使用方法很好理解。构造函数用 explicit 声明,如果这样做,
编译器会拒绝为了隐式类型转换而调用构造函数。显式类型转换依然合法:
template<class T>
class Array {
public:
...
explicit Array(int size); // 注意使用"explicit"
bbs.theithome.com


...
};
Array<int> a(10); // 正确, explicit 构造函数
// 在建立对象时能正常使用
Array<int> b(10); // 也正确
if (a == b[i]) ... // 错误! 没有办法
// 隐式转换
// int 到 Array<int>
if (a == Array<int>(b[i])) ... // 正确,显式从 int 到
// Array<int>转换
// (但是代码的逻辑
// 不合理)
if (a == static_cast< Array<int> >(b[i])) ...
// 同样正确,同样
// 不合理
if (a == (Array<int>)b[i]) ... //C 风格的转换也正确,
// 但是逻辑
// 依旧不合理
在例子里使用了 static_cast(参见条款 M2),两个“>”字符间的空格不能漏掉,如果
这样写语句:
if (a == static_cast<Array<int>>(b[i])) ...
这是一个不同的含义的语句。因为 C++编译器把“>>”做为一个符号来解释。在两个“>”
间没有空格,语句会产生语法错误。
如果你的编译器不支持 explicit,你不得不回到不使用成为隐式类型转换函数的单参
数构造函数。
我前面说过复杂的规则决定哪一个隐式类型转换是合法的,哪一个是不合法的。这些规
则中没有一个转换能够包含用户自定义类型(调用单参数构造函数或隐式类型转换运算符)。
你能利用这个规则来正确构造你的类,使得对象能够正常构造,同时去掉你不想要的隐式类
型转换。
再来想一下数组模板,你需要用整形变量做为构造函数参数来确定数组大小,但是同时
又必须防止从整数类型到临时数组对象的隐式类型转换。你要达到这个目的,先要建立一个
新类 ArraySize。这个对象只有一个目的就是表示将要建立数组的大小。你必须修改 Array
的单参数构造函数,用一个 ArraySize 对象来代替 int。代码如下:
template<class T>
bbs.theithome.com


class Array {
public:
class ArraySize { // 这个类是新的
public:
ArraySize(int numElements): theSize(numElements) {}
int size() const { return theSize; }
private:
int theSize;
};
Array(int lowBound, int highBound);
Array(ArraySize size); // 注意新的声明
...
};
这里把 ArraySize 嵌套入 Array 中,为了强调它总是与 Array 一起使用。你也必须声明
ArraySize 为公有,为了让任何人都能使用它。
想一下,当通过单参数构造函数定义 Array 对象,会发生什么样的事情:
Array<int> a(10);
你的编译器要求用 int 参数调用 Array<int>里的构造函数,但是没有这样的构造函数。
编译器意识到它能从 int 参数转换成一个临时 ArraySize 对象,ArraySize 对象只是
Array<int>构造函数所需要的,这样编译器进行了转换。函数调用(及其后的对象建立)也
就成功了。
事实上你仍旧能够安心地构造 Array 对象,不过这样做能够使你避免类型转换。考虑一
下以下代码:
bool operator==( const Array<int>& lhs,
const Array<int>& rhs);
Array<int> a(10);
Array<int> b(10);
...
for (int i = 0; i < 10; ++i)
if (a == b[i]) ... // 哎呦! "a" 应该是 "a[i]";
// 现在是一个错误。
为了调用 operator==函数,编译器要求 Array<int>对象在”==”右侧,但是不存在一
个参数为 int 的单参数构造函数。而且编译器无法把 int 转换成一个临时 ArraySize 对象然
后 通 过 这 个 临 时 对 象 建 立 必 须 的 Array<int> 对 象 , 因 为 这 将 调 用 两 个 用 户 定 义
bbs.theithome.com


(user-defined)的类型转换,一个从 int 到 ArraySize,一个从 ArraySize 到 Array<int>。
这种转换顺序被禁止的,所以当试图进行比较时编译器肯定会产生错误。
ArraySize 类的使用有些象一个有目的的帮手,这是一个更通用技术的应用实例。类似
于 ArraySize 的类经常被称为 proxy classes,因为这样类的每一个对象都为了支持其他对
象的工作。ArraySize 对象实际是一个整数类型的替代者,用来在建立 Array 对象时确定数
组大小。Proxy 对象能帮你更好地控制软件的在某些方面的行为,否则你就不能控制这些行
为,比如在上面的情况里,这种行为是指隐式类型转换,所以它值得你去学习和使用。你可
能会问你如何去学习它呢?一种方法是转向条款 M30;它专门讨论 proxy classes。
在你跳到条款 M30 之前,再仔细考虑一下本条款的内容。让编译器进行隐式类型转换所
造成的弊端要大于它所带来的好处,所以除非你确实需要,不要定义类型转换函数。
4.2 Item M6:自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别
很久以前(八十年代),没有办法区分++和--操作符的前缀与后缀调用。这个问题遭到
程序员的报怨,于是 C++语言得到了扩展,允许重载 increment 和 decrement 操作符的两
种形式。
然而有一个句法上的问题,重载函数间的区别决定于它们的参数类型上的差异,但是不
论是 increment 或 decrement 的前缀还是后缀都只有一个参数。为了解决这个语言问题,C++
规定后缀形式有一个 int 类型参数,当函数被调用时,编译器传递一个 0 做为 int 参数的值
给该函数:
class UPInt { // "unlimited precision int"
public:
UPInt& operator++(); // ++ 前缀
const UPInt operator++(int); // ++ 后缀
UPInt& operator--(); // -- 前缀
const UPInt operator--(int); // -- 后缀
UPInt& operator+=(int); // += 操作符,UPInts
// 与 ints 相运算
...
};
UPInt i;
++i; // 调用 i.operator++();
i++; // 调用 i.operator++(0);
--i; // 调用 i.operator--();
i--; // 调用 i.operator--(0);
bbs.theithome.com


这个规范有一些古怪,不过你会习惯的。而尤其要注意的是:这些操作符前缀与后缀形
式返回值类型是不同的。前缀形式返回一个引用,后缀形式返回一个 const 类型。下面我们
将讨论++操作符的前缀与后缀形式,这些说明也同样适用于--操作符。
从你开始做 C 程序员那天开始,你就记住 increment 的前缀形式有时叫做“增加然后取
回”,后缀形式叫做“取回然后增加”。这两句话非常重要,因为它们是 increment 前缀与后
缀的形式上的规范。
// 前缀形式:增加然后取回值
UPInt& UPInt::operator++()
{
*this += 1; // 增加
return *this; // 取回值
}
// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
UPInt oldValue = *this; // 取回值
++(*this); // 增加
return oldValue; // 返回被取回的值
}
后缀操作符函数没有使用它的参数。它的参数只是用来区分前缀与后缀函数调用。如果
你没有在函数里使用参数,许多编译器会显示警告信息,很令人讨厌。为了避免这些警告信
息,一种经常使用的方法时省略掉你不想使用的参数名称;如上所示。
很明显一个后缀 increment 必须返回一个对象(它返回的是增加前的值),但是为什么
是 const 对象呢?假设不是 const 对象,下面的代码就是正确的:
UPInt i;
i++++; // 两次 increment 后缀
这组代码与下面的代码相同:
i.operator++(0).operator++(0);
很明显,第一个调用的 operator++函数返回的对象调用了第二个 operator++函数。
有两个理由导致我们应该厌恶上述这种做法,第一是与内置类型行为不一致。当设计一
个类遇到问题时,一个好的准则是使该类的行为与 int 类型一致。而 int 类型不允许连续进
行两次后缀 increment:
int i;
i++++; // 错误!
bbs.theithome.com


第二个原因是使用两次后缀 increment 所产生的结果与调用者期望的不一致。如上所
示,第二次调用 operator++改变的值是第一次调用返回对象的值,而不是原始对象的值。
因此如果:
i++++;
是合法的,i 将仅仅增加了一次。这与人的直觉相违背,使人迷惑(对于 int 类型和 UPInt
都是一样),所以最好禁止这么做。
C++禁止 int 类型这么做,同时你也必须禁止你自己写的类有这样的行为。最容易的方
法是让后缀 increment 返回 const 对象。当编译器遇到这样的代码:
i++++; // same as
i.operator++(0).operator++(0);
它发现从第一个 operator++函数返回的 const 对象又调用 operator++函数,然而这个
函数是一个 non-const 成员函数,所以 const 对象不能调用这个函数。如果你原来想过让
一个函数返回 const 对象没有任何意义,现在你就知道有时还是有用的,后缀 increment
和 decrement 就是例子。(更多的例子参见 Effective C++ 条款 21)
如果你很关心效率问题,当你第一次看到后缀 increment 函数时,你可能觉得有些问题。
这个函数必须建立一个临时对象以做为它的返回值,(参见条款 M19),上述实现代码建立了
一 个 显 示 的 临 时 对 象 ( oldValue ), 这 个 临 时 对 象 必 须 被 构 造 并 在 最 后 被 析 构 。 前 缀
increment 函数没有这样的临时对象。由此得出一个令人惊讶的结论,如果仅为了提高代码
效率,UPInt 的调用者应该尽量使用前缀 increment,少用后缀 increment,除非确实需要
使用后缀 increment。让我们明确一下,当处理用户定义的类型时,尽可能地使用前缀
increment,因为它的效率较高。
我们再观察一下后缀与前缀 increment 操作符。它们除了返回值不同外,所完成的功能
是一样的,即值加一。简而言之,它们被认为功能一样。那么你如何确保后缀 increment
和前缀 increment 的行为一致呢?当不同的程序员去维护和升级代码时,有什么能保证它们
不会产生差异?除非你遵守上述代码里的原则,这才能得到确保。这个原则是后缀
increment 和 decrement 应该根据它们的前缀形式来实现。你仅仅需要维护前缀版本,因为
后缀形式自动与前缀形式的行为一致。
正如你所看到的,掌握前缀和后缀 increment 和 decrement 是容易的。一旦了解了他们
正确的返回值类型以及后缀操作符应该以前缀操作符为基础来实现的规则,就足够了。
4.3 Item M7:不要重载“&&”,“||”, 或“,”
与 C 一样,C++使用布尔表达式短路求值法(short-circuit evaluation)。这表示一旦
确定了布尔表达式的真假值,即使还有部分表达式没有被测试,布尔表达式也停止运算。例
如:
bbs.theithome.com


char *p;
...
if ((p != 0) && (strlen(p) > 10)) ...
这里不用担心当 p 为空时 strlen 无法正确运行,因为如果 p 不等于 0 的测试失败,strlen
不会被调用。同样:
int rangeCheck(int index)
{
if ((index < lowerBound) || (index > upperBound)) ...
...
}
如果 index 小于 lowerBound,它不会与 upperBound 进行比较。
很早以前,上述行为特性就被反复灌输给 C 和 C++的程序员,所以他们都知道该特性。
而且他们也依赖于短路求值法来写程序。例如在上述第一个代码中,当 p 为空指针时确保
strlen 不会被调用是很重要的,因为 C++标准说(正如 C 标准所说)用空指针调用 strlen,
结果不确定。
C++允许根据用户定义的类型,来定制&&和||操作符。方法是重载函数 operator&& 和
operator||,你能在全局重载或每个类里重载。然而如果你想使用这种方法,你必须知道你
正在极大地改变游戏规则。因为你以函数调用法替代了短路求值法。也就是说如果你重载了
操作符&&,对于你来说代码是这样的:
if (expression1 && expression2) ...
对于编译器来说,等同于下面代码之一:
if (expression1.operator&&(expression2)) ...
// when operator&& is a
// member function
if (operator&&(expression1, expression2)) ...
// when operator&& is a
// global function
这好像没有什么不同,但是函数调用法与短路求值法是绝对不同的。首先当函数被调用
时,需要运算其所有参数,所以调用函数 functions operator&& 和 operator||时,两个
参数都需要计算,换言之,没有采用短路计算法。第二是 C++语言规范没有定义函数参数的
计算顺序,所以没有办法知道表达式 1 与表达式 2 哪一个先计算。完全可能与具有从左参数
到右参数计算顺序的短路计算法相反。
因此如果你重载&&或||,就没有办法提供给程序员他们所期望和使用的行为特性,所以
不要重载&&和||。
bbs.theithome.com


同样的理由也适用于逗号操作符,但是在我们深入研究它之前,我还是暂停一下,让你
不要太惊讶,“逗号操作符?哪有逗号操作符?”确实存在。逗号操作符用于组成表达式,
你经常在 for 循环的更新部分(update part)里遇见它。例如下面来源于 Kernighan's and
Ritchie's 经典书籍 The C Programming Language 第二版(Prentice-Hall, 1988)的函数:
// reverse string s in place
void reverse(char s[])
{
for (int i = 0, j = strlen(s)-1;
i < j;
++i, --j) // 啊! 逗号操作符!
{
int c = s[i];
s[i] = s[j];
s[j] = c;
}
}
在 for 循环的最后一个部分里,i 被增加同时 j 被减少。在这里使用逗号很方便,因为
在最后一个部分里只能使用一个表达式,分开表达式来改变 i 和 j 的值是不合法的。
对于内建类型&&和||,C++有一些规则来定义它们如何运算。与此相同,也有规则来定
义逗号操作符的计算方法。一个包含逗号的表达式首先计算逗号左边的表达式,然后计算逗
号右边的表达式;整个表达式的结果是逗号右边表达式的值。所以在上述循环的最后部分里,
编译器首先计算++i,然后是—j,逗号表达式的结果是--j。
也许你想为什么你需要知道这些内容呢?因为你需要模仿这个行为特性,如果你想大胆
地写自己的逗号操作符函数。不幸的是你无法模仿。
如果你写一个非成员函数 operator,你不能保证左边的表达式先于右边的表达式计算,
因为函数(operator)调用时两个表达式做为参数被传递出去。但是你不能控制函数参数的
计算顺序。所以非成员函数的方法绝对不行。
剩下的只有写成员函数 operator 的可能性了。即使这里你也不能依靠于逗号左边表达
式先被计算的行为特性,因为编译器不一定必须按此方法去计算。因此你不能重载逗号操作
符,保证它的行为特性与其被料想的一样。重载它是完全轻率的行为。
你可能正在想这个重载恶梦究竟有没有完。毕竟如果你能重载逗号操作符,你还有什么
不能重载的呢?正如显示的,存在一些限制,你不能重载下面的操作符:
. .* :: ?:
new delete sizeof typeid
bbs.theithome.com


static_cast dynamic_cast const_cast reinterpret_cast
你能重载:
operator new operator delete
operator new[] operator delete[]
+ -*/%^ &| ~
! = < > += -= *= /= %=
^= &= |= << >> >>= <<= == !=
<= >= && || ++ -- , ->* ->
() []
(有关 new 和 delete 还有 operator new, operator delete, operator new[], and
operator delete[]的信息参见条款 M8)
当然能重载这些操作符不是去重载的理由。操作符重载的目的是使程序更容易阅读,书
写和理解,而不是用你的知识去迷惑其他人。如果你没有一个好理由重载操作符,就不要重
载。在遇到&&, ||, 和 ,时,找到一个好理由是困难的,因为无论你怎么努力,也不能让它
们的行为特性与所期望的一样。
4.4 Item M8:理解各种不同含义的new和delete
人们有时好像喜欢故意使 C++语言的术语难以理解。比如说 new 操作符(new operator)
和 new 操作(operator new)的区别。
当你写这样的代码:
string *ps = new string("Memory Management");
你使用的 new 是 new 操作符。这个操作符就象 sizeof 一样是语言内置的,你不能改变它的
含义,它的功能总是一样的。它要完成的功能分成两部分。第一部分是分配足够的内存以便
容纳所需类型的对象。第二部分是它调用构造函数初始化内存中的对象。new 操作符总是做
这两件事情,你不能以任何方式改变它的行为。
你所能改变的是如何为对象分配内存。new 操作符调用一个函数来完成必需的内存分
配,你能够重写或重载这个函数来改变它的行为。new 操作符为分配内存所调用函数的名字
是 operator new。
函数 operator new 通常这样声明:
void * operator new(size_t size);
返回值类型是 void*,因为这个函数返回一个未经处理(raw)的指针,未初始化的内
存。(如果你喜欢,你能写一种 operator new 函数,在返回一个指针之前能够初始化内存以
存储一些数值,但是一般不这么做。)参数 size_t 确定分配多少内存。你能增加额外的参数
重载函数 operator new,但是第一个参数类型必须是 size_t。(有关 operator new 更多的
bbs.theithome.com


信息参见 Effective C++ 条款 8 至条款 10。)
你一般不会直接调用 operator new,但是一旦这么做,你可以象调用其它函数一样调
用它:
void *rawMemory = operator new(sizeof(string));
操作符 operator new 将返回一个指针,指向一块足够容纳一个 string 类型对象的内存。
就象 malloc 一样,operator new 的职责只是分配内存。它对构造函数一无所知。
operator new 所了解的是内存分配。把 operator new 返回的未经处理的指针传递给一个对
象是 new 操作符的工作。当你的编译器遇见这样的语句:
string *ps = new string("Memory Management");
它生成的代码或多或少与下面的代码相似(更多的细节见 Effective C++条款 8 和条款 10,
还有我的文章 Counting object 里的注释。):
void *memory = // 得到未经处理的内存
operator new(sizeof(string)); // 为 String 对象
call string::string("Memory Management") //初始化
on *memory; // 内存中
// 的对象
string *ps = // 是 ps 指针指向
static_cast<string*>(memory); // 新的对象
注意第二步包含了构造函数的调用,你做为一个程序员被禁止这样去做。你的编译器则
没有这个约束,它可以做它想做的一切。因此如果你想建立一个堆对象就必须用 new 操作符,
不能直接调用构造函数来初始化对象。
z placement new
有时你确实想直接调用构造函数。在一个已存在的对象上调用构造函数是没有意义的,
因为构造函数用来初始化对象,而一个对象仅仅能在给它初值时被初始化一次。但是有时你
有一些已经被分配但是尚未处理的(raw)内存,你需要在这些内存中构造一个对象。你可以
使用一个特殊的 operator new ,它被称为 placement new。
下面的例子是 placement new 如何使用,考虑一下:
class Widget {
public:
Widget(int widgetSize);
...
};
Widget * constructWidgetInBuffer(void *buffer,
int widgetSize)
bbs.theithome.com


{
return new (buffer) Widget(widgetSize);
}
这个函数返回一个指针,指向一个 Widget 对象,对象在转递给函数的 buffer 里分配。
当程序使用共享内存或 memory-mapped I/O 时这个函数可能有用,因为在这样程序里对象必
须被放置在一个确定地址上或一块被例程分配的内存里。(参见条款 M4,一个如何使用
placement new 的一个不同例子。)
在 constructWidgetInBuffer 里面,返回的表达式是:
new (buffer) Widget(widgetSize)
这初看上去有些陌生,但是它是 new 操作符的一个用法,需要使用一个额外的变量(buffer),
当 new 操作符隐含调用 operator new 函数时,把这个变量传递给它。被调用的 operator new
函数除了待有强制的参数 size_t 外,还必须接受 void*指针参数,指向构造对象占用的内
存空间。这个 operator new 就是 placement new,它看上去象这样:
void * operator new(size_t, void *location)
{
return location;
}
这可能比你期望的要简单,但是这就是 placement new 需要做的事情。毕竟 operator new
的目的是为对象分配内存然后返回指向该内存的指针。在使用 placement new 的情况下,调
用者已经获得了指向内存的指针,因为调用者知道对象应该放在哪里。placement new 必须
做的就是返回转递给它的指针。(没有用的(但是强制的)参数 size_t 没有名字,以防止编
译器发出警告说它没有被使用;见条款 M6。) placement new 是标准 C++库的一部分(见
Effective C++ 条款 49)。为了使用 placement new,你必须使用语句#include <new>(或
者如果你的编译器还不支持这新风格的头文件名(再参见 Effective C++ 条款 49),
<new.h>)。
让我们从 placement new 回来片刻,看看 new 操作符(new operator)与 operator new
的关系,你想在堆上建立一个对象,应该用 new 操作符。它既分配内存又为对象调用构造函
数。如果你仅仅想分配内存,就应该调用 operator new 函数;它不会调用构造函数。如果
你想定制自己的在堆对象被建立时的内存分配过程,你应该写你自己的 operator new 函数,
然后使用 new 操作符,new 操作符会调用你定制的 operator new。如果你想在一块已经获得
指针的内存里建立一个对象,应该用 placement new。
(有关更多的不同的 new 与 delete 的观点参见 Effective C++ 条款 7 和我的文章
Counting objects。)
z Deletion and Memory Deallocation
bbs.theithome.com


为了避免内存泄漏,每个动态内存分配必须与一个等同相反的 deallocation 对应。函
数 operator delete 与 delete 操作符的关系与 operator new 与 new 操作符的关系一样。当
你看到这些代码:
string *ps;
...
delete ps; // 使用 delete 操作符
你的编译器会生成代码来析构对象并释放对象占有的内存。
Operator delete 用来释放内存,它被这样声明:
void operator delete(void *memoryToBeDeallocated);
因此,
delete ps;
导致编译器生成类似于这样的代码:
ps->~string(); // call the object's dtor
operator delete(ps); // deallocate the memory
// the object occupied
这有一个隐含的意思是如果你只想处理未被初始化的内存,你应该绕过 new 和 delete
操作符,而调用 operator new 获得内存和 operator delete 释放内存给系统:
void *buffer = // 分配足够的
operator new(50*sizeof(char)); // 内存以容纳 50 个 char
//没有调用构造函数
...
operator delete(buffer); // 释放内存
// 没有调用析构函数
这与在 C 中调用 malloc 和 free 等同。
如果你用 placement new 在内存中建立对象,你应该避免在该内存中用 delete 操作符。
因为 delete 操作符调用 operator delete 来释放内存,但是包含对象的内存最初不是被
operator new 分配的,placement new 只是返回转递给它的指针。谁知道这个指针来自何方?
而你应该显式调用对象的析构函数来解除构造函数的影响:
// 在共享内存中分配和释放内存的函数
void * mallocShared(size_t size);
void freeShared(void *memory);
void *sharedMemory = mallocShared(sizeof(Widget));
Widget *pw = // 如上所示,
constructWidgetInBuffer(sharedMemory, 10); // 使用
bbs.theithome.com


// placement new
...
delete pw; // 结果不确定! 共享内存来自
// mallocShared, 而不是 operator new
pw->~Widget(); // 正确。 析构 pw 指向的 Widget,
// 但是没有释放
//包含 Widget 的内存
freeShared(pw); // 正确。 释放 pw 指向的共享内存
// 但是没有调用析构函数
如上例所示,如果传递给 placement new 的 raw 内存是自己动态分配的(通过一些不常
用的方法),如果你希望避免内存泄漏,你必须释放它。(参见我的文章 Counting objects
里面关于 placement delete 的注释。)
z Arrays
到目前为止一切顺利,但是还得接着走。到目前为止我们所测试的都是一次建立一个对
象。怎样分配数组?会发生什么?
string *ps = new string[10]; // allocate an array of
// objects
被使用的 new 仍然是 new 操作符,但是建立数组时 new 操作符的行为与单个对象建立有
少许不同。第一是内存不再用 operator new 分配,代替以等同的数组分配函数,叫做
operator new[](经常被称为 array new)。它与 operator new 一样能被重载。这就允许你
控制数组的内存分配,就象你能控制单个对象内存分配一样(但是有一些限制性说明,参见
Effective C++ 条款 8)。
(operator new[]对于 C++来说是一个比较新的东西,所以你的编译器可能不支持它。
如果它不支持,无论在数组中的对象类型是什么,全局 operator new 将被用来给每个数组
分配内存。在这样的编译器下定制数组内存分配是困难的,因为它需要重写全局 operator
new。这可不是一个能轻易接受的任务。缺省情况下,全局 operator new 处理程序中所有的
动态内存分配,所以它行为的任何改变都将有深入和普遍的影响。而且全局 operator new
有一个正常的签名(normal signature)(也就单一的参数 size_t,参见 Effective C++条
款 9),所以如果你决定用自己的方法声明它,你立刻使你的程序与其它库不兼容(参见条
款 M27)基于这些考虑,在缺乏 operator new[]支持的编译器里为数组定制内存管理不是一
个合理的设计。)
第二个不同是 new 操作符调用构造函数的数量。对于数组,在数组里的每一个对象的构
造函数都必须被调用:
string *ps = // 调用 operator new[]为 10 个
bbs.theithome.com


new string[10]; // string 对象分配内存,
// 然后对每个数组元素调用
// string 对象的缺省构造函数。
同样当 delete 操作符用于数组时,它为每个数组元素调用析构函数,然后调用 operator
delete 来释放内存。
就象你能替换或重载 operator delete 一样,你也替换或重载 operator delete[]。在
它们重载的方法上有一些限制。请参考优秀的 C++教材。(有关优秀的 C++教材的信息,参见
本书 285 页的推荐)
new 和 delete 操作符是内置的,其行为不受你的控制,凡是它们调用的内存分配和释
放函数则可以控制。当你想定制 new 和 delete 操作符的行为时,请记住你不能真的做到这
一点。你只能改变它们为完成它们的功能所采取的方法,而它们所完成的功能则被语言固定
下来,不能改变。(You can modify how they do what they do, but what they do is fixed
by the language)
5. 异常
C++新增的异常(exception)机制改变了某些事情,这种改变是深刻的,彻底的,可能
是令人不舒服的。例如:使用未经处理的或原始的指针变得很危险;资源泄漏的可能性增加
了;写出具有你希望的行为的构造函数与析构函数变得更加困难。特别小心防止程序执行时
突然崩溃。执行程序和库程序尺寸增加了,同时运行速度降低了。
这就使我们所知道的事情。很多使用 C++的人都不知道在程序中使用异常,大多数人不
知道如何正确使用它。在异常被抛出后,使软件的行为具有可预测性和可靠性,在众多方法
中至今也没有一个一致的方法能做到这点。(为了深刻了解这个问题,参见 Tom Cargill 写
的 Exception Handling: A False Sense of Security。有关这些问题的进展情况的信息,
参见 Jack Reeves 写的 Coping with Exceptions 和 Herb Sutter 写的 Exception-Safe
Generic Containers。)
我们知道:程序能够在存在异常的情况下正常运行是因为它们按照要求进行了设计,而
不是因为巧合。异常安全(Exception-safe)的程序不是偶然建立的。一个没有按照要求进
行设计的程序在存在异常的情况下运行正常的概率与一个没有按照多线程要求进行设计的
程序在多线程的环境下运行正常的概率相同,概率为 0。
为什么使用异常呢?自从 C 语言被发明初来,C 程序员就满足于使用错误代码(Error
code),所以为什么还要弄来异常呢,特别是如果异常如我上面所说的那样存在着问题。答
案是简单的:异常不能被忽略。如果一个函数通过设置一个状态变量或返回错误代码来表示
一个异常状态,没有办法保证函数调用者将一定检测变量或测试错误代码。结果程序会从它
遇到的异常状态继续运行,异常没有被捕获,程序立即会终止执行。
bbs.theithome.com


C 程序员能够仅通过 setjmp 和 longjmp 来完成与异常处理相似的功能。但是当 longjmp
在 C++中使用时,它存在一些缺陷,当它调整堆栈时不能对局部对象调用析构函数。(WQ 加
注,VC++能保证这一点,但不要依赖这一点。)而大多数 C++程序员依赖于这些析构函
数的调用,所以 setjmp 和 longjmp 不能够替换异常处理。如果你需要一个方法,能够通知
不可被忽略的异常状态,并且搜索栈空间(searching the stack)以便找到异常处理代码
时,你还得确保局部对象的析构函数必须被调用,这时你就需要使用 C++的异常处理。
因为我们已经对使用异常处理的程序设计有了很多了解,下面这些条款仅是一个对于写
出异常安全(Exception-safe)软件的不完整的指导。然而它们给任何在 C++中使用异常处
理的人介绍了一些重要思想。通过留意下面这些指导,你能够提高自己软件的正确性,强壮
性和高效性,并且你将回避开许多在使用异常处理时经常遇到的问题。
5.1 Item M9:使用析构函数防止资源泄漏
对指针说再见。必须得承认:你永远都不会喜欢使用指针。
Ok,你不用对所有的指针说再见,但是你需要对用来操纵局部资源(local resources)
的指针说再见。假设,你正在为一个小动物收容所编写软件,小动物收容所是一个帮助小狗
小猫寻找主人的组织。每天收容所建立一个文件,包含当天它所管理的收容动物的资料信息,
你的工作是写一个程序读出这些文件然后对每个收容动物进行适当的处理(appropriate
processing)。
完成这个程序一个合理的方法是定义一个抽象类,ALA("Adorable Little Animal"),
然后为小狗和小猫建立派生类。一个虚拟函数 processAdoption 分别对各个种类的动物进行
处理:
class ALA {
public:
virtual void processAdoption() = 0;
...
};
class Puppy: public ALA {
public:
virtual void processAdoption();
...
};
class Kitten: public ALA {
public:
virtual void processAdoption();
bbs.theithome.com


...
};
你需要一个函数从文件中读去信息,然后根据文件中的信息产生一个 puppy(小狗)对
象或者 kitten(小猫)对象。这个工作非常适合于虚拟构造器(virtual constructor),在
条款 M25 详细描述了这种函数。为了完成我们的目标,我们这样声明函数:
// 从 s 中读去动物信息, 然后返回一个指针
// 指向新建立的某种类型对象
ALA * readALA(istream& s);
你的程序的关键部分就是这个函数,如下所示:
void processAdoptions(istream& dataSource)
{
while (dataSource) { // 还有数据时,继续循环
ALA *pa = readALA(dataSource); //得到下一个动物
pa->processAdoption(); //处理收容动物
delete pa; //删除 readALA 返回的对象
}
}
这个函数循环遍历 dataSource 内的信息,处理它所遇到的每个项目。唯一要记住的一
点是在每次循环结尾处删除 pa。这是必须的,因为每次调用 readALA 都建立一个堆对象。
如果不删除对象,循环将产生资源泄漏。
现 在 考 虑 一 下 , 如 果 pa->processAdoption 抛 出 了 一 个 异 常 , 将 会 发 生 什 么 ?
processAdoptions 没有捕获异常,所以异常将传递给 processAdoptions 的调用者。传递中,
processAdoptions 函数中的调用 pa->processAdoption 语句后的所有语句都被跳过,这就
是说 pa 没有被删除。结果,任何时候 pa->processAdoption 抛出一个异常都会导致
processAdoptions 内存泄漏。
堵塞泄漏很容易 :
void processAdoptions(istream& dataSource)
{
while (dataSource) {
ALA *pa = readALA(dataSource);
try {
pa->processAdoption();
}
catch (...) { // 捕获所有异常
bbs.theithome.com


delete pa; // 避免内存泄漏
// 当异常抛出时
throw; // 传送异常给调用者
}
delete pa; // 避免资源泄漏
} // 当没有异常抛出时
}
但是你必须用 try 和 catch 对你的代码进行小改动。更重要的是你必须写双份清除代码,
一个为正常的运行准备,一个为异常发生时准备。在这种情况下,必须写两个 delete 代码。
象其它重复代码一样,这种代码写起来令人心烦又难于维护,而且它看上去好像存在着问题。
不论我们是让 processAdoptions 正常返回还是抛出异常,我们都需要删除 pa,所以为什么
我们必须要在多个地方编写删除代码呢?
(WQ 加注,VC++支持 try...catch...final 结构的 SEH。)
我们可以把总被执行的清除代码放入 processAdoptions 函数内的局部对象的析构函数
里,这样可以避免重复书写清除代码。因为当函数返回时局部对象总是被释放,无论函数是
如何退出的。(仅有一种例外就是当你调用 longjmp 时。Longjmp 的这个缺点是 C++率先支持
异常处理的主要原因)
具体方法是用一个对象代替指针 pa,这个对象的行为与指针相似。当 pointer-like 对
象(类指针对象)被释放时,我们能让它的析构函数调用 delete。替代指针的对象被称为
smart pointers(灵巧指针),参见条款 M28 的解释,你能使得 pointer-like 对象非常灵巧。
在这里,我们用不着这么聪明的指针,我们只需要一个 pointer-lik 对象,当它离开生存空
间时知道删除它指向的对象。
写出这样一个类并不困难,但是我们不需要自己去写。标准 C++库函数包含一个类模板,
叫做 auto_ptr,这正是我们想要的。每一个 auto_ptr 类的构造函数里,让一个指针指向一
个堆对象(heap object),并且在它的析构函数里删除这个对象。下面所示的是 auto_ptr
类的一些重要的部分:
template<class T>
class auto_ptr {
public:
auto_ptr(T *p = 0): ptr(p) {} // 保存 ptr,指向对象
~auto_ptr() { delete ptr; } // 删除 ptr 指向的对象
private:
T *ptr; // raw ptr to object
};
bbs.theithome.com


auto_ptr 类的完整代码是非常有趣的,上述简化的代码实现不能在实际中应用。(我们
至少必须加上拷贝构造函数,赋值 operator 和将在条款 M28 讲述的 pointer-emulating 函
数),但是它背后所蕴含的原理应该是清楚的:用 auto_ptr 对象代替 raw 指针,你将不再为
堆对象不能被删除而担心,即使在抛出异常时,对象也能被及时删除。(因为 auto_ptr 的析
构函数使用的是单对象形式的 delete,所以 auto_ptr 不能用于指向对象数组的指针。如果
想让 auto_ptr 类似于一个数组模板,你必须自己写一个。在这种情况下,用 vector 代替
array 可能更好。)
使用 auto_ptr 对象代替 raw 指针,processAdoptions 如下所示:
void processAdoptions(istream& dataSource)
{
while (dataSource) {
auto_ptr<ALA> pa(readALA(dataSource));
pa->processAdoption();
}
}
这个版本的 processAdoptions 在两个方面区别于原来的 processAdoptions 函数。第一,
pa 被声明为一个 auto_ptr<ALA>对象,而不是一个 raw ALA*指针。第二,在循环的结尾没
有 delete 语句。其余部分都一样,因为除了析构的方式,auto_ptr 对象的行为就象一个普
通的指针。是不是很容易。
隐藏在 auto_ptr 后的思想是:用一个对象存储需要被自动释放的资源,然后依靠对象
的析构函数来释放资源,这种思想不只是可以运用在指针上,还能用在其它资源的分配和释
放上。想一下这样一个在 GUI 程序中的函数,它需要建立一个 window 来显式一些信息:
// 这个函数会发生资源泄漏,如果一个异常抛出
void displayInfo(const Information& info)
{
WINDOW_HANDLE w(createWindow());
在 w 对应的 window 中显式信息
destroyWindow(w);
}
很多 window 系统有 C-like 接口,使用象 like createWindow 和 destroyWindow 函数
来获取和释放 window 资源。如果在 w 对应的 window 中显示信息时,一个异常被抛出,w 所
对应的 window 将被丢失,就象其它动态分配的资源一样。
解决方法与前面所述的一样,建立一个类,让它的构造函数与析构函数来获取和释放资
源:
bbs.theithome.com


//一个类,获取和释放一个 window 句柄
class WindowHandle {
public:
WindowHandle(WINDOW_HANDLE handle): w(handle) {}
~WindowHandle() { destroyWindow(w); }
operator WINDOW_HANDLE() { return w; } // see below
private:
WINDOW_HANDLE w;
// 下面的函数被声明为私有,防止建立多个 WINDOW_HANDLE 拷贝
//有关一个更灵活的方法的讨论请参见条款 M28。
WindowHandle(const WindowHandle&);
WindowHandle& operator=(const WindowHandle&);
};
这看上去有些象 auto_ptr,只是赋值操作与拷贝构造被显式地禁止(参见条款 M27),
有一个隐含的转换操作能把 WindowHandle 转换为 WINDOW_HANDLE。这个能力对于使用
WindowHandle 对象非常重要,因为这意味着你能在任何地方象使用 raw WINDOW_HANDLE 一
样来使用 WindowHandle。(参见条款 M5 ,了解为什么你应该谨慎使用隐式类型转换操作)
通过给出的 WindowHandle 类,我们能够重写 displayInfo 函数,如下所示:
// 如果一个异常被抛出,这个函数能避免资源泄漏
void displayInfo(const Information& info)
{
WindowHandle w(createWindow());
在 w 对应的 window 中显式信息;
}
即使一个异常在 displayInfo 内被抛出,被 createWindow 建立的 window 也能被释放。
资源应该被封装在一个对象里,遵循这个规则,你通常就能避免在存在异常环境里发生
资源泄漏。但是如果你正在分配资源时一个异常被抛出,会发生什么情况呢?例如当你正处
于 resource-acquiring 类的构造函数中。还有如果这样的资源正在被释放时,一个异常被
抛出,又会发生什么情况呢?构造函数和析构函数需要特殊的技术。你能在条款 M10 和条款
M11 中获取有关的知识。
5.2 Item M10:在构造函数中防止资源泄漏
如果你正在开发一个具有多媒体功能的通讯录程序。这个通讯录除了能存储通常的文字
信息如姓名、地址、电话号码外,还能存储照片和声音(可以给出他们名字的正确发音)。
bbs.theithome.com


为了实现这个通信录,你可以这样设计:
class Image { // 用于图像数据
public:
Image(const string& imageDataFileName);
...
};
class AudioClip { // 用于声音数据
public:
AudioClip(const string& audioDataFileName);
...
};
class PhoneNumber { ... }; // 用于存储电话号码
class BookEntry { // 通讯录中的条目
public:
BookEntry(const string& name,
const string& address = "",
const string& imageFileName = "",
const string& audioClipFileName = "");
~BookEntry();
// 通过这个函数加入电话号码
void addPhoneNumber(const PhoneNumber& number);
...
private:
string theName; // 人的姓名
string theAddress; // 他们的地址
list<PhoneNumber> thePhones; // 他的电话号码
Image *theImage; // 他们的图像
AudioClip *theAudioClip; // 他们的一段声音片段
};
通讯录的每个条目都有姓名数据,所以你需要带有参数的构造函数(参见条款 M3),不
过其它内容(地址、图像和声音的文件名)都是可选的。注意应该使用链表类(list)存储
bbs.theithome.com


电话号码,这个类是标准 C++类库(STL)中的一个容器类(container classes)。(参见
Effective C++条款 49 和本书条款 M35)
编写 BookEntry 构造函数和析构函数,有一个简单的方法是:
BookEntry::BookEntry(const string& name,
const string& address,
const string& imageFileName,
Const string& audioClipFileName)
: theName(name), theAddress(address),
theImage(0), theAudioClip(0)
{
if (imageFileName != "") {
theImage = new Image(imageFileName);
}
if (audioClipFileName != "") {
theAudioClip = new AudioClip(audioClipFileName);
}
}
BookEntry::~BookEntry()
{
delete theImage;
delete theAudioClip;
}
构造函数把指针 theImage 和 theAudioClip 初始化为空,然后如果其对应的构造函数参
数不是空,就让这些指针指向真实的对象。析构函数负责删除这些指针,确保 BookEntry
对象不会发生资源泄漏。因为 C++确保删除空指针是安全的,所以 BookEntry 的析构函数在
删除指针前不需要检测这些指针是否指向了某些对象。
看上去好像一切良好,在正常情况下确实不错,但是在非正常情况下(例如在有异常发
生的情况下)它们恐怕就不会良好了。
请想一下如果 BookEntry 的构造函数正在执行中,一个异常被抛出,会发生什么情况
呢?:
if (audioClipFileName != "") {
theAudioClip = new AudioClip(audioClipFileName);
}
一个异常被抛出,可以是因为 operator new(参见条款 M8)不能给 AudioClip 分配足
bbs.theithome.com


够的内存,也可以因为 AudioClip 的构造函数自己抛出一个异常。不论什么原因,如果在
BookEntry 构造函数内抛出异常,这个异常将传递到建立 BookEntry 对象的地方(在构造函
数体的外面。 译者注)。
现在假设建立 theAudioClip 对象建立时,一个异常被抛出(而且传递程序控制权到
BookEntry 构造函数的外面),那么谁来负责删除 theImage 已经指向的对象呢?答案显然应
该是由 BookEntry 来做,但是这个想当然的答案是错的。~BookEntry()根本不会被调用,永
远不会。
C++仅仅能删除被完全构造的对象(fully contructed objects), 只有一个对象的构
造函数完全运行完毕,这个对象才被完全地构造。所以如果一个 BookEntry 对象 b 做为局部
对象建立,如下:
void testBookEntryClass()
{
BookEntry b("Addison-Wesley Publishing Company",
"One Jacob Way, Reading, MA 01867");
...
}
并且在构造 b 的过程中,一个异常被抛出,b 的析构函数不会被调用。而且如果你试图
采取主动手段处理异常情况,即当异常发生时调用 delete,如下所示:
void testBookEntryClass()
{
BookEntry *pb = 0;
try {
pb = new BookEntry("Addison-Wesley Publishing Company",
"One Jacob Way, Reading, MA 01867");
...
}
catch (...) { // 捕获所有异常
delete pb; // 删除 pb,当抛出异常时
throw; // 传递异常给调用者
}
delete pb; // 正常删除 pb
}
你会发现在 BookEntry 构造函数里为 Image 分配的内存仍旧被丢失了,这是因为如果
new 操作没有成功完成,程序不会对 pb 进行赋值操作。如果 BookEntry 的构造函数抛出一
bbs.theithome.com


个异常,pb 将是一个空值,所以在 catch 块中删除它除了让你自己感觉良好以外没有任何
作用。用灵巧指针(smart pointer)类 auto_ptr<BookEntry>(参见条款 M9)代替 raw
BookEntry*也不会也什么作用,因为 new 操作成功完成前,也没有对 pb 进行赋值操作。
C++拒绝为没有完成构造操作的对象调用析构函数是有一些原因的,而不是故意为你制
造困难。原因是:在很多情况下这么做是没有意义的,甚至是有害的。如果为没有完成构造
操作的对象调用析构函数,析构函数如何去做呢?仅有的办法是在每个对象里加入一些字节
来指示构造函数执行了多少步?然后让析构函数检测这些字节并判断该执行哪些操作。这样
的记录会减慢析构函数的运行速度,并使得对象的尺寸变大。C++避免了这种开销,但是代
价是不能自动地删除被部分构造的对象。(类似这种在程序行为与效率这间进行折衷处理的
例子还可以参见 Effective C++条款 13)
因为当对象在构造中抛出异常后 C++不负责清除对象,所以你必须重新设计你的构造函
数以让它们自己清除。经常用的方法是捕获所有的异常,然后执行一些清除代码,最后再重
新抛出异常让它继续转递。如下所示,在 BookEntry 构造函数中使用这个方法:
BookEntry::BookEntry(const string& name,
const string& address,
const string& imageFileName,
const string& audioClipFileName)
: theName(name), theAddress(address),
theImage(0), theAudioClip(0)
{
try { // 这 try block 是新加入的
if (imageFileName != "") {
theImage = new Image(imageFileName);
}
if (audioClipFileName != "") {
theAudioClip = new AudioClip(audioClipFileName);
}
}
catch (...) { // 捕获所有异常
delete theImage; // 完成必要的清除代码
delete theAudioClip;
throw; // 继续传递异常
}
}
bbs.theithome.com


不用为 BookEntry 中的非指针数据成员操心,在类的构造函数被调用之前数据成员就被
自动地初始化。所以如果 BookEntry 构造函数体开始执行,对象的 theName, theAddress 和
thePhones 数据成员已经被完全构造好了。这些数据可以被看做是完全构造的对象,所以它
们将被自动释放,不用你介入操作。当然如果这些对象的构造函数调用可能会抛出异常的函
数,那么那些构造函数必须自己去考虑捕获异常并在继续传递这些异常之前完成必需的清除
操作。
你可能已经注意到 BookEntry 构造函数的 catch 块中的语句与在 BookEntry 的析构函数
的语句几乎一样。这里的代码重复是绝对不可容忍的,所以最好的方法是把通用代码移入一
个私有 helper function 中,让构造函数与析构函数都调用它。
class BookEntry {
public:
... // 同上
private:
...
void cleanup(); // 通用清除代码
};
void BookEntry::cleanup()
{
delete theImage;
delete theAudioClip;
}
BookEntry::BookEntry(const string& name,
const string& address,
const string& imageFileName,
const string& audioClipFileName)
: theName(name), theAddress(address),
theImage(0), theAudioClip(0)
{
try {
... // 同上
}
catch (...) {
cleanup(); // 释放资源
throw; // 传递异常
bbs.theithome.com


}
}
BookEntry::~BookEntry()
{
cleanup();
}
这似乎行了,但是它没有考虑到下面这种情况。假设我们略微改动一下设计,让
theImage 和 theAudioClip 是常量(constant)指针类型:
class BookEntry {
public:
... // 同上
private:
...
Image * const theImage; // 指针现在是
AudioClip * const theAudioClip; // const 类型
};
必须通过 BookEntry 构造函数的成员初始化表来初始化这样的指针,因为再也没有其它
地方可以给 const 指针赋值(参见 Effective C++条款 12)。通常会这样初始化 theImage
和 theAudioClip:
// 一个可能在异常抛出时导致资源泄漏的实现方法
BookEntry::BookEntry(const string& name,
const string& address,
const string& imageFileName,
const string& audioClipFileName)
: theName(name), theAddress(address),
theImage(imageFileName != ""
? new Image(imageFileName)
: 0),
theAudioClip(audioClipFileName != ""
? new AudioClip(audioClipFileName)
: 0)
{}
这样做导致我们原先一直想避免的问题重新出现:如果 theAudioClip 初始化时一个异
常被抛出,theImage 所指的对象不会被释放。而且我们不能通过在构造函数中增加 try 和
bbs.theithome.com


catch 语句来解决问题,因为 try 和 catch 是语句,而成员初始化表仅允许有表达式(这也
是为什么我们必须在 theImage 和 theAudioClip 的初始化中使用?:以代替 if-then-else
的原因)。
无论如何,在异常传递之前完成清除工作的唯一的方法就是捕获这些异常,所以如果我
们不能在成员初始化表中放入 try 和 catch 语句,我们把它们移到其它地方。一种可能是在
私有成员函数中,用这些函数返回指针指向初始化过的 theImage 和 theAudioClip 对象。
class BookEntry {
public:
... // 同上
private:
... // 数据成员同上
Image * initImage(const string& imageFileName);
AudioClip * initAudioClip(const string&
audioClipFileName);
};
BookEntry::BookEntry(const string& name,
const string& address,
const string& imageFileName,
const string& audioClipFileName)
: theName(name), theAddress(address),
theImage(initImage(imageFileName)),
theAudioClip(initAudioClip(audioClipFileName))
{}
// theImage 被首先初始化,所以即使这个初始化失败也
// 不用担心资源泄漏,这个函数不用进行异常处理。
Image * BookEntry::initImage(const string& imageFileName)
{
if (imageFileName != "") return new Image(imageFileName);
else return 0;
}
// theAudioClip 被第二个初始化, 所以如果在 theAudioClip
// 初始化过程中抛出异常,它必须确保 theImage 的资源被释放。
// 因此这个函数使用 try...catch 。
AudioClip * BookEntry::initAudioClip(const string&
bbs.theithome.com


audioClipFileName)
{
try {
if (audioClipFileName != "") {
return new AudioClip(audioClipFileName);
}
else return 0;
}
catch (...) {
delete theImage;
throw;
}
}
上面的程序的确不错,也解决了令我们头疼不已的问题。不过也有缺点,在原则上应该
属于构造函数的代码却分散在几个函数里,这令我们很难维护。
更好的解决方法是采用条款 M9 的建议,把 theImage 和 theAudioClip 指向的对象做为
一个资源,被一些局部对象管理。这个解决方法建立在这样一个事实基础上:theImage 和
theAudioClip 是两个指针,指向动态分配的对象,因此当指针消失的时候,这些对象应该
被删除。auto_ptr 类就是基于这个目的而设计的。(参见条款 M9)因此我们把 theImage 和
theAudioClip raw 指针类型改成对应的 auto_ptr 类型。
class BookEntry {
public:
... // 同上
private:
...
const auto_ptr<Image> theImage; // 它们现在是
const auto_ptr<AudioClip> theAudioClip; // auto_ptr 对象
};
这样做使得 BookEntry 的构造函数即使在存在异常的情况下也能做到不泄漏资源,而且
让我们能够使用成员初始化表来初始化 theImage 和 theAudioClip,如下所示:
BookEntry::BookEntry(const string& name,
const string& address,
const string& imageFileName,
const string& audioClipFileName)
bbs.theithome.com


: theName(name), theAddress(address),
theImage(imageFileName != ""
? new Image(imageFileName)
: 0),
theAudioClip(audioClipFileName != ""
? new AudioClip(audioClipFileName)
: 0)
{}
在这里,如果在初始化 theAudioClip 时抛出异常,theImage 已经是一个被完全构造的
对象,所以它能被自动删除掉,就象 theName, theAddress 和 thePhones 一样。而且因为
theImage 和 theAudioClip 现在是包含在 BookEntry 中的对象,当 BookEntry 被删除时它
们能被自动地删除。因此不需要手工删除它们所指向的对象。可以这样简化 BookEntry 的析
构函数:
BookEntry::~BookEntry()
{} // nothing to do!
这表示你能完全去掉 BookEntry 的析构函数。
综上所述,如果你用对应的 auto_ptr 对象替代指针成员变量,就可以防止构造函数在
存在异常时发生资源泄漏,你也不用手工在析构函数中释放资源,并且你还能象以前使用非
const 指针一样使用 const 指针,给其赋值。
在对象构造中,处理各种抛出异常的可能,是一个棘手的问题,但是 auto_ptr(或者类
似于 auto_ptr 的类)能化繁为简。它不仅把令人不好理解的代码隐藏起来,而且使得程序在
面对异常的情况下也能保持正常运行。
5.3 Item M11:禁止异常信息(exceptions)传递到析构函数外
在有两种情况下会调用析构函数。第一种是在正常情况下删除一个对象,例如对象超出
了作用域或被显式地 delete。第二种是异常传递的堆栈辗转开解(stack-unwinding)过程
中,由异常处理系统删除一个对象。
在上述两种情况下,调用析构函数时异常可能处于激活状态也可能没有处于激活状态。
遗憾的是没有办法在析构函数内部区分出这两种情况。因此在写析构函数时你必须保守地假
设有异常被激活。因为如果在一个异常被激活的同时,析构函数也抛出异常,并导致程序控
制权转移到析构函数外,C++将调用 terminate 函数。这个函数的作用正如其名字所表示的:
它终止你程序的运行,而且是立即终止,甚至连局部对象都没有被释放。
下面举一个例子,一个 Session 类用来跟踪在线计算机的 sessions,session 就是运行
在从你一登录计算机开始一直到注销出系统为止的这段期间的某种东西。每个 Session 对象
bbs.theithome.com


关注的是它建立与释放的日期和时间:
class Session {
public:
Session();
~Session();
...
private:
static void logCreation(Session *objAddr);
static void logDestruction(Session *objAddr);
};
函数 logCreation 和 logDestruction 被分别用于记录对象的建立与释放。我们因此可
以这样编写 Session 的析构函数:
Session::~Session()
{
logDestruction(this);
}
一切看上去很好,但是如果 logDestruction 抛出一个异常,会发生什么事呢?异常没
有被 Session 的析构函数捕获住,所以它被传递到析构函数的调用者那里。但是如果析构函
数本身的调用就是源自于某些其它异常的抛出,那么 terminate 函数将被自动调用,彻底终
止你的程序。这不是你所希望发生的事情。程序没有记录下释放对象的信息,这是不幸的,
甚至是一个大麻烦。那么事态果真严重到了必须终止程序运行的地步了么?如果没有,你必
须防止在 logDestruction 内抛出的异常传递到 Session 析构函数的外面。唯一的方法是用
try 和 catch blocks。一种很自然的做法会这样编写函数:
Session::~Session()
{
try {
logDestruction(this);
}
catch (...) {
cerr << "Unable to log destruction of Session object "
<< "at address "
<< this
<< ".\n";
}
bbs.theithome.com


}
但是这样做并不比你原来的代码安全。如果在 catch 中调用 operator<<时导致一个异
常被抛出,我们就又遇到了老问题,一个异常被转递到 Session 析构函数的外面。
我们可以在 catch 中放入 try,但是这总得有一个限度,否则会陷入循环。因此我们在
释放 Session 时必须忽略掉所有它抛出的异常:
Session::~Session()
{
try {
logDestruction(this);
}
catch (...) { }
}
catch 表 面 上 好 像 没 有 做 任 何 事 情 , 这 是 一 个 假 象 , 实 际 上 它 阻 止 了 任 何 从
logDestruction 抛出的异常被传递到 session 析构函数的外面。我们现在能高枕无忧了,
无论 session 对象是不是在堆栈退栈(stack unwinding)中被释放,terminate 函数都不
会被调用。
不允许异常传递到析构函数外面还有第二个原因。如果一个异常被析构函数抛出而没有
在函数内部捕获住,那么析构函数就不会完全运行(它会停在抛出异常的那个地方上)。如
果析构函数不完全运行,它就无法完成希望它做的所有事情。例如,我们对 session 类做一
个修改,在建立 session 时启动一个数据库事务(database transaction),终止 session
时结束这个事务:
Session::Session() // 为了简单起见,,
{ // 这个构造函数没有
// 处理异常
logCreation(this);
startTransaction(); // 启动 database transaction
}
Session::~Session()
{
logDestruction(this);
endTransaction(); // 结束 database transaction
}
如果在这里 logDestruction 抛出一个异常,在 session 构造函数内启动的 transaction
就没有被终止。我们也许能够通过重新调整 session 析构函数内的函数调用顺序来消除问
bbs.theithome.com


题,但是如果 endTransaction 也抛出一个异常,我们除了回到使用 try 和 catch 外,别无
选择。
综上所述,我们知道禁止异常传递到析构函数外有两个原因,第一能够在异常转递的堆
栈辗转开解(stack-unwinding)的过程中,防止 terminate 被调用。第二它能帮助确保析
构函数总能完成我们希望它做的所有事情。(如果你仍旧不很信服我所说的理由,可以去看
Herb Sutter 的文章 Exception-Safe Generic Containers ,特别是“Destructors That Throw
and Why They’re Evil”这段)。
5.4 Item M12:理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异
从语法上看,在函数里声明参数与在 catch 子句中声明参数几乎没有什么差别:
class Widget { ... }; //一个类,具体是什么类
// 在这里并不重要
void f1(Widget w); // 一些函数,其参数分别为
void f2(Widget& w); // Widget, Widget&,或
void f3(const Widget& w); // Widget* 类型
void f4(Widget *pw);
void f5(const Widget *pw);
catch (Widget w) ... //一些 catch 子句,用来
catch (Widget& w) ... //捕获异常,异常的类型为
catch (const Widget& w) ... // Widget, Widget&, 或
catch (Widget *pw) ... // Widget*
catch (const Widget *pw) ...
你因此可能会认为用 throw 抛出一个异常到 catch 子句中与通过函数调用传递一个参数
两者基本相同。这里面确有一些相同点,但是他们也存在着巨大的差异。
让我们先从相同点谈起。你传递函数参数与异常的途径可以是传值、传递引用或传递指
针,这是相同的。但是当你传递参数和异常时,系统所要完成的操作过程则是完全不同的。
产生这个差异的原因是:你调用函数时,程序的控制权最终还会返回到函数的调用处,但是
当你抛出一个异常时,控制权永远不会回到抛出异常的地方。
有这样一个函数,参数类型是 Widget,并抛出一个 Widget 类型的异常:
// 一个函数,从流中读值到 Widget 中
istream operator>>(istream& s, Widget& w);
void passAndThrowWidget()
{
Widget localWidget;
bbs.theithome.com


cin >> localWidget; //传递 localWidget 到 operator>>
throw localWidget; // 抛出 localWidget 异常
}
当传递 localWidget 到函数 operator>>里,不用进行拷贝操作,而是把 operator>>内
的引用类型变量 w 指向 localWidget,任何对 w 的操作实际上都施加到 localWidget 上。这
与抛出 localWidget 异常有很大不同。不论通过传值捕获异常还是通过引用捕获(不能通过
指针捕获这个异常,因为类型不匹配)都将进行 lcalWidget 的拷贝操作,也就说传递到 catch
子句中的是 localWidget 的拷贝。必须这么做,因为当 localWidget 离开了生存空间后,其
析构函数将被调用。如果把 localWidget 本身(而不是它的拷贝)传递给 catch 子句,这个
子句接收到的只是一个被析构了的 Widget,一个 Widget 的“尸体”。这是无法使用的。因
此 C++规范要求被做为异常抛出的对象必须被复制。
即使被抛出的对象不会被释放,也会进行拷贝操作。例如如果 passAndThrowWidget 函
数声明 localWidget 为静态变量(static),
void passAndThrowWidget()
{
static Widget localWidget; // 现在是静态变量(static);
//一直存在至程序结束
cin >> localWidget; // 象以前那样运行
throw localWidget; // 仍将对 localWidget
} //进行拷贝操作
当抛出异常时仍将复制出 localWidget 的一个拷贝。这表示即使通过引用来捕获异常,
也不能在 catch 块中修改 localWidget;仅仅能修改 localWidget 的拷贝。对异常对象进行
强制复制拷贝,这个限制有助于我们理解参数传递与抛出异常的第二个差异:抛出异常运行
速度比参数传递要慢。
当异常对象被拷贝时,拷贝操作是由对象的拷贝构造函数完成的。该拷贝构造函数是对
象的静态类型(static type)所对应类的拷贝构造函数,而不是对象的动态类型(dynamic
type)对应类的拷贝构造函数。比如以下这经过少许修改的 passAndThrowWidget:
class Widget { ... };
class SpecialWidget: public Widget { ... };
void passAndThrowWidget()
{
SpecialWidget localSpecialWidget;
...
Widget& rw = localSpecialWidget; // rw 引用 SpecialWidget
bbs.theithome.com


throw rw; //它抛出一个类型为 Widget
// 的异常
}
这里抛出的异常对象是 Widget,即使 rw 引用的是一个 SpecialWidget。因为 rw 的静态
类型(static
type)是 Widget,而不是 SpecialWidget。你的编译器根本没有注意到 rw 引用的是一个
SpecialWidget。编译器所注意的是 rw 的静态类型(static type)。这种行为可能与你所期
待的不一样,但是这与在其他情况下 C++中拷贝构造函数的行为是一致的。(不过有一种技
术可以让你根据对象的动态类型 dynamic type 进行拷贝,参见条款 M25)
异常是其它对象的拷贝,这个事实影响到你如何在 catch 块中再抛出一个异常。比如下
面这两个 catch 块,乍一看好像一样:
catch (Widget& w) // 捕获 Widget 异常
{
... // 处理异常
throw; // 重新抛出异常,让它
} // 继续传递
catch (Widget& w) // 捕获 Widget 异常
{
... // 处理异常
throw w; // 传递被捕获异常的
} // 拷贝
这两个 catch 块的差别在于第一个 catch 块中重新抛出的是当前捕获的异常,而第二个
catch 块中重新抛出的是当前捕获异常的一个新的拷贝。如果忽略生成额外拷贝的系统开
销,这两种方法还有差异么?
当然有。第一个块中重新抛出的是当前异常(current exception),无论它是什么类型。
特别是如果这个异常开始就是做为 SpecialWidget 类型抛出的,那么第一个块中传递出去的
还是 SpecialWidget 异常,即使 w 的静态类型(static type)是 Widget。这是因为重新抛
出异常时没有进行拷贝操作。第二个 catch 块重新抛出的是新异常,类型总是 Widget,因
为 w 的静态类型(static type)是 Widget。一般来说,你应该用 throw 来重新抛出当前的
异常,因为这样不会改变被传递出去的异常类型,而且更有效率,因为不用生成一个新拷贝。
(顺便说一句,异常生成的拷贝是一个临时对象。正如条款 19 解释的,临时对象能让编译
器优化它的生存期(optimize it out of existence),不过我想你的编译器很难这么做,
因为程序中很少发生异常,所以编译器厂商不会在这方面花大量的精力。)
让 我 们 测 试 一 下 下 面 这 三 种 用 来 捕 获 Widget 异 常 的 catch 子 句 , 异 常 是 做 为
bbs.theithome.com


passAndThrowWidgetp 抛出的:
catch (Widget w) ... // 通过传值捕获异常
catch (Widget& w) ... // 通过传递引用捕获
// 异常
catch (const Widget& w) ... //通过传递指向 const 的引用
//捕获异常
我们立刻注意到了传递参数与传递异常的另一个差异。一个被异常抛出的对象(刚才解
释过,总是一个临时对象)可以通过普通的引用捕获;它不需要通过指向 const 对象的引用
(reference-to-const)捕获。在函数调用中不允许转递一个临时对象到一个非 const 引用
类型的参数里(参见条款 M19),但是在异常中却被允许。
让我们先不管这个差异,回到异常对象拷贝的测试上来。我们知道当用传值的方式传递
函数的参数,我们制造了被传递对象的一个拷贝(参见 Effective C++ 条款 22),并把这个
拷贝存储到函数的参数里。同样我们通过传值的方式传递一个异常时,也是这么做的。当我
们这样声明一个 catch 子句时:
catch (Widget w) ... // 通过传值捕获
会建立两个被抛出对象的拷贝,一个是所有异常都必须建立的临时对象,第二个是把临
时对象拷贝进 w 中(WQ 加注,重要:是两个!)。同样,当我们通过引用捕获异常时,
catch (Widget& w) ... // 通过引用捕获
catch (const Widget& w) ... //也通过引用捕获
这仍旧会建立一个被抛出对象的拷贝:拷贝同样是一个临时对象。相反当我们通过引用
传递函数参数时,没有进行对象拷贝。当抛出一个异常时,系统构造的(以后会析构掉)被
抛出对象的拷贝数比以相同对象做为参数传递给函数时构造的拷贝数要多一个。
我们还没有讨论通过指针抛出异常的情况。不过,通过指针抛出异常与通过指针传递参
数是相同的。不论哪种方法都是一个指针的拷贝被传递。但,你不能认为抛出的指针是一个
指向局部对象的指针,因为当异常离开局部变量的生存空间时,该局部变量已经被释放。
Catch 子句将获得一个指向已经不存在的对象的指针。这种行为在设计时应该予以避免。(WQ
加注,也就是说:必须是全局的或堆中的。)
对象从函数的调用处传递到函数参数里与从异常抛出点传递到 catch 子句里所采用的
方法不同,这只是参数传递与异常传递的区别的一个方面;第二个差异是在函数调用者或抛
出异常者与被调用者或异常捕获者之间的类型匹配的过程不同。比如在标准数学库(the
standard math library)中 sqrt 函数:
double sqrt(double); // from <cmath> or <math.h>
我们能这样计算一个整数的平方根,如下所示:
int i;
bbs.theithome.com


double sqrtOfi = sqrt(i);
毫无疑问,C++允许进行从 int 到 double 的隐式类型转换,所以在 sqrt 的调用中,i 被
悄悄地转变为 double 类型,并且其返回值也是 double。(有关隐式类型转换的详细讨论参
见条款 M5)一般来说,catch 子句匹配异常类型时不会进行这样的转换。见下面的代码:
void f(int value)
{
try {
if (someFunction()) { // 如果 someFunction()返回
throw value; //真,抛出一个整形值
...
}
}
catch (double d) { // 只处理 double 类型的异常
...
}
...
}
在 try 块中抛出的 int 异常不会被处理 double 异常的 catch 子句捕获。该子句只能捕
获类型真真正正为 double 的异常,不进行类型转换。因此如果要想捕获 int 异常,必须使
用带有 int 或 int&参数的 catch 子句。
不过在 catch 子句中进行异常匹配时可以进行两种类型转换。第一种是继承类与基类间
的转换。一个用来捕获基类的 catch 子句也可以处理派生类类型的异常。例如在标准 C++库
(STL)定义的异常类层次中的诊断部分(diagnostics portion )(参见 Effective C++ 条
款 49)。
捕获 runtime_errors 异常的 Catch 子句可以捕获 range_error 类型和 overflow_error
类型的异常;可以接收根类 exception 异常的 catch 子句能捕获其任意派生类异常。
这种派生类与基类(inheritance_based)间的异常类型转换可以作用于数值、引用以
及指针上:
catch (runtime_error) ... // can catch errors of type
catch (runtime_error&) ... // runtime_error,
catch (const runtime_error&) ... // range_error, or
// overflow_error
catch (runtime_error*) ... // can catch errors of type
catch (const runtime_error*) ... // runtime_error*,
bbs.theithome.com


// range_error*, or
// overflow_error*
第二种是允许从一个类型化指针(typed pointer)转变成无类型指针(untyped
pointer),所以带有 const void* 指针的 catch 子句能捕获任何类型的指针类型异常:
catch (const void*) ... //捕获任何指针类型异常
传递参数和传递异常间最后一点差别是 catch 子句匹配顺序总是取决于它们在程序中
出现的顺序。因此一个派生类异常可能被处理其基类异常的 catch 子句捕获,即使同时存在
有能直接处理该派生类异常的 catch 子句,与相同的 try 块相对应。例如:
try {
...
}
catch (logic_error& ex) { // 这个 catch 块 将捕获
... // 所有的 logic_error
} // 异常, 包括它的派生类
catch (invalid_argument& ex) { // 这个块永远不会被执行
... //因为所有的
} // invalid_argument
// 异常 都被上面的
// catch 子句捕获。
与上面这种行为相反,当你调用一个虚拟函数时,被调用的函数位于与发出函数调用的
对象的动态类型(dynamic type)最相近的类里。你可以这样说虚拟函数采用最优适合法,
而异常处理采用的是最先适合法。如果一个处理派生类异常的 catch 子句位于处理基类异常
的 catch 子句后面,编译器会发出警告。(因为这样的代码在 C++里通常是不合法的。)不过
你最好做好预先防范:不要把处理基类异常的 catch 子句放在处理派生类异常的 catch 子句
的前面。象上面那个例子,应该这样去写:
try {
...
}
catch (invalid_argument& ex) { // 处理 invalid_argument
... //异常
}
catch (logic_error& ex) { // 处理所有其它的
... // logic_errors 异常
bbs.theithome.com


}
综上所述,把一个对象传递给函数或一个对象调用虚拟函数与把一个对象做为异常抛
出,这之间有三个主要区别。第一、异常对象在传递时总被进行拷贝;当通过传值方式捕获
时,异常对象被拷贝了两次。对象做为参数传递给函数时不一定需要被拷贝。第二、对象做
为异常被抛出与做为参数传递给函数相比,前者类型转换比后者要少(前者只有两种转换形
式)。最后一点,catch 子句进行异常类型匹配的顺序是它们在源代码中出现的顺序,第一
个类型匹配成功的 catch 将被用来执行。当一个对象调用一个虚拟函数时,被选择的函数位
于与对象类型匹配最佳的类里,即使该类不是在源代码的最前头。
5.5 Item M13:通过引用(reference)捕获异常
当你写一个 catch 子句时,必须确定让异常通过何种方式传递到 catch 子句里。你可以
有三个选择:与你给函数传递参数一样,通过指针(by pointer),通过传值(by value)
或通过引用(by reference)。
我们首先讨论通过指针方式捕获异常(catch by pointer)。从 throw 处传递一个异常
到 catch 子句是一个缓慢的过程,在理论上这种方法的实现对于这个过程来说是效率最高
的。因为在传递异常信息时,只有采用通过指针抛出异常的方法才能够做到不拷贝对象(参
见条款 M12),例如:
class exception { ... }; // 来自标准 C++库(STL)
// 中的异常类层次
// (参见条款 12)
void someFunction()
{
static exception ex; // 异常对象
...
throw &ex; // 抛出一个指针,指向 ex
...
}
void doSomething()
{
try {
someFunction(); // 抛出一个 exception*
}
catch (exception *ex) { // 捕获 exception*;
... // 没有对象被拷贝
bbs.theithome.com


}
}
这看上去很不错,但是实际情况却不是这样。为了能让程序正常运行,程序员定义异常
对象时必须确保当程序控制权离开抛出指针的函数后,对象还能够继续生存。全局与静态对
象都能够做到这一点,但是程序员很容易忘记这个约束。如果真是如此的话,他们会这样写
代码:
void someFunction()
{
exception ex; // 局部异常对象;
// 当退出函数的生存空间时
// 这个对象将被释放。
...
throw &ex; // 抛出一个指针,指向
... // 已被释放的对象
}
这简直糟糕透了,因为处理这个异常的 catch 子句接受到的指针,其指向的对象已经不
再存在。
另一种抛出指针的方法是建立一个堆对象(new heap object):
void someFunction()
{
...
throw new exception; // 抛出一个指针,指向一个在堆中
... // 建立的对象(希望
} // 操作符 new — 参见条款 M8
// 自己不要再抛出一个
// 异常!)
这避免了捕获一个指向已被释放对象的指针的问题,但是 catch 子句的作者又面临一个
令人头疼的问题:他们是否应该删除他们接受的指针?如果是在堆中建立的异常对象,那他
们必须删除它,否则会造成资源泄漏。如果不是在堆中建立的异常对象,他们绝对不能删除
它,否则程序的行为将不可预测。该如何做呢?
这是不可能知道的。一些被调用者可能会传递全局或静态对象的地址,另一些可能传递
堆中建立的异常对象的地址。通过指针捕获异常,将遇到一个哈姆雷特式的难题:是删除还
是不删除?这是一个难以回答的问题。所以你最好避开它。
而 且 , 通 过 指 针 捕 获 异 常 也 不 符 合 C++ 语 言 本 身 的 规 范 。 四 个 标 准 的 异 常 ― 
bbs.theithome.com


bad_alloc(当 operator new(参见条款 M8)不能分配足够的内存时,被抛出),bad_cast(当
dynamic_cast 针 对 一 个 引 用 ( reference ) 操 作 失 败 时 , 被 抛 出 ) ,bad_typeid ( 当
dynamic_cast 对空指针进行操作时,被抛出)和 bad_exception(用于 unexpected 异常;
参见条款 M14)――都不是指向对象的指针,所以你必须通过值或引用来捕获它们。
通过值捕获异常(catch-by-value)可以解决上述的问题,例如异常对象删除的问题和
使用标准异常类型的问题。但是当它们被抛出时系统将对异常对象拷贝两次(参见条款
M12)。而且它会产生 slicing problem,即派生类的异常对象被做为基类异常对象捕获时,
那它的派生类行为就被切掉了(sliced off)。这样的 sliced 对象实际上是一个基类对象:
它们没有派生类的数据成员,而且当本准备调用它们的虚拟函数时,系统解析后调用的却是
基类对象的函数。(当一个对象通过传值方式传递给函数,也会发生一样的情况――参见
Effective C++ 条款 22)。例如下面这个程序采用了扩展自标准异常类的异常类层次体系:
class exception { // 如上,这是
public: // 一个标准异常类
virtual const char * what() throw();
// 返回异常的简短描述.
... // (在函数声明的结尾处
// 的"throw()",
}; //有关它的信息
// 参见条款 14)
class runtime_error: //也来自标准 C++异常类
public exception { ... };
class Validation_error: // 客户自己加入个类
public runtime_error {
public:
virtual const char * what() throw();
// 重新定义在异常类中
... //虚拟函数
}; //
void someFunction() // 抛出一个 validation
{ // 异常
...
if (a validation 测试失败) {
throw Validation_error();
bbs.theithome.com


}
...
}
void doSomething()
{
try {
someFunction(); // 抛出 validation
} //异常
catch (exception ex) { //捕获所有标准异常类
// 或它的派生类
cerr << ex.what(); // 调用 exception::what(),
... // 而不是 Validation_error::what()
}
}
调 用 的 是 基 类 的 what 函 数 , 即 使 被 抛 出 的 异 常 对 象 是 runtime_error 或
Validation_error 类型并且它们已经重新定义了这个虚拟函数。这种 slicing 行为绝不是
你所期望的。
最后剩下方法就是通过引用捕获异常(catch-by-reference)。通过引用捕获异常能使
你避开上述所有问题。不象通过指针捕获异常,这种方法不会有对象删除的问题而且也能捕
获标准异常类型。也不象通过值捕获异常,这种方法没有 slicing problem,而且异常对象
只被拷贝一次。
我们采用通过引用捕获异常的方法重写最后那个例子,如下所示:
void someFunction() //这个函数没有改变
{
...
if (a validation 测试失败) {
throw Validation_error();
}
...
}
void doSomething()
{
try {
someFunction(); // 没有改变
bbs.theithome.com


}
catch (exception& ex) { // 这里,我们通过引用捕获异常
// 以替代原来的通过值捕获
cerr << ex.what(); // 现在调用的是
// Validation_error::what(),
... // 而不是 exception::what()
}
}
这里没有对 throw 进行任何改变,仅仅改变了 catch 子句,给它加了一个&符号。然而
这个微小的改变能造成了巨大的变化,因为 catch 块中的虚拟函数能够如我们所愿那样工作
了:调用的 Validation_erro 函数是我们重新定义过的函数。
如果你通过引用捕获异常(catch by reference),你就能避开上述所有问题,不会为
是否删除异常对象而烦恼;能够避开 slicing 异常对象;能够捕获标准异常类型;减少异常
对象需要被拷贝的数目。所以你还在等什么?通过引用捕获异常吧(Catch exceptions by
reference)!
5.6 Item M14:审慎使用异常规格(exception specifications)
毫无疑问,异常规格是一个引人注目的特性。它使得代码更容易理解,因为它明确地描
述了一个函数可以抛出什么样的异常。但是它不只是一个有趣的注释。编译器在编译时有时
能够检测到异常规格的不一致。而且如果一个函数抛出一个不在异常规格范围里的异常,系
统在运行时能够检测出这个错误,然后一个特殊函数 unexpected 将被自动地调用。异常规
格既可以做为一个指导性文档同时也是异常使用的强制约束机制,它好像有着很诱人的外
表。
不过在通常情况下,美貌只是一层皮,外表的美丽并不代表其内在的素质。函数
unexpected 缺省的行为是调用函数 terminate,而 terminate 缺省的行为是调用函数 abort,
所以一个违反异常规格的程序其缺省的行为就是 halt(停止运行)。在激活的栈中的局部变
量没有被释放,因为 abort 在关闭程序时不进行这样的清除操作。对异常规格的触犯变成了
一场并不应该发生的灾难。
不幸的是,我们很容易就能够编写出导致发生这种灾难的函数。编译器仅仅部分地检测
异常的使用是否与异常规格保持一致。一个函数调用了另一个函数,并且后者可能抛出一个
违反前者异常规格的异常,(A 函数调用 B 函数,但因为 B 函数可能抛出一个不在 A 函数异
常规格之内的异常,所以这个函数调用就违反了 A 函数的异常规格 译者注)编译器不对此
种情况进行检测,并且语言标准也禁止编译器拒绝这种调用方式(尽管可以显示警告信息)。
例如函数 f1 没有声明异常规格,这样的函数就可以抛出任意种类的异常:
bbs.theithome.com


extern void f1(); // 可以抛出任意的异常
假设有一个函数 f2 通过它的异常规格来声明其只能抛出 int 类型的异常:
void f2() throw(int);
f2 调用 f1 是非常合法的,即使 f1 可能抛出一个违反 f2 异常规格的异常:
void f2() throw(int)
{
...
f1(); // 即使 f1 可能抛出不是 int 类型的
//异常,这也是合法的。
...
}
当带有异常规格的新代码与没有异常规格的老代码整合在一起工作时,这种灵活性就显
得很重要。
因为你的编译器允许你调用一个函数,其抛出的异常与发出调用的函数的异常规格不一
致,并且这样的调用可能导致你的程序执行被终止,所以在编写软件时应该采取措施把这种
不一致减小到最少。一种好方法是避免在带有类型参数的模板内使用异常规格。例如下面这
种模板,它好像不能抛出任何异常:
// a poorly designed template wrt exception specifications
template<class T>
bool operator==(const T& lhs, const T& rhs) throw()
{
return &lhs == &rhs;
}
这个模板为所有类型定义了一个操作符函数 operator==。对于任意一对类型相同的对
象,如果对象有一样的地址,该函数返回 true,否则返回 false。
这个模板包含的异常规格表示模板生成的函数不能抛出异常。但是事实可能不会这样,
因为 opertor&(地址操作符,参见 Effective C++ 条款 45)能被一些类型对象重载。如果被
重载的话,当调用从 operator==函数内部调用 opertor&时,opertor&可能会抛出一个异常,
这样就违反了我们的异常规格,使得程序控制跳转到 unexpected。
上述的例子是一种更一般问题的特例,这个更一般问题也就是没有办法知道某种模板类
型参数抛出什么样的异常。我们几乎不可能为一个模板提供一个有意义的异常规格。因为模
板总是采用不同的方法使用类型参数。解决方法只能是模板和异常规格不要混合使用。
能够避免调用 unexpected 函数的第二个方法是如果在一个函数内调用其它没有异常规
格的函数时应该去除这个函数的异常规格。这很容易理解,但是实际中容易被忽略。比如允
bbs.theithome.com


许用户注册一个回调函数:
// 一个 window 系统回调函数指针
//当一个 window 系统事件发生时
typedef void (*CallBackPtr)(int eventXLocation,
int eventYLocation,
void *dataToPassBack);
//window 系统类,含有回调函数指针,
//该回调函数能被 window 系统客户注册
class CallBack {
public:
CallBack(CallBackPtr fPtr, void *dataToPassBack)
: func(fPtr), data(dataToPassBack) {}
void makeCallBack(int eventXLocation,
int eventYLocation) const throw();
private:
CallBackPtr func; // function to call when
// callback is made
void *data; // data to pass to callback
}; // function
// 为了实现回调函数,我们调用注册函数,
//事件的作标与注册数据做为函数参数。
void CallBack::makeCallBack(int eventXLocation,
int eventYLocation) const throw()
{
func(eventXLocation, eventYLocation, data);
}
这里在 makeCallBack 内调用 func,要冒违反异常规格的风险,因为无法知道 func 会
抛出什么类型的异常。
通过在程序在 CallBackPtr typedef 中采用更严格的异常规格来解决问题:
typedef void (*CallBackPtr)(int eventXLocation,
int eventYLocation,
void *dataToPassBack) throw();
这样定义 typedef 后,如果注册一个可能会抛出异常的 callback 函数将是非法的:
// 一个没有异常规格的回调函数
bbs.theithome.com


void callBackFcn1(int eventXLocation, int eventYLocation,
void *dataToPassBack);
void *callBackData;
...
CallBack c1(callBackFcn1, callBackData);
//错误!callBackFcn1 可能
// 抛出异常
//带有异常规格的回调函数
void callBackFcn2(int eventXLocation,
int eventYLocation,
void *dataToPassBack) throw();
CallBack c2(callBackFcn2, callBackData);
// 正确,callBackFcn2
// 没有异常规格
传递函数指针时进行这种异常规格的检查,是语言的较新的特性,所以有可能你的编译
器不支持这个特性。如果它们不支持,那就依靠你自己来确保不能犯这种错误。
避免调用 unexpected 的第三个方法是处理系统本身抛出的异常。这些异常中最常见的
是 bad_alloc,当内存分配失败时它被 operator new 和 operator new[]抛出(参见条款 M8)。
如果你在函数里使用 new 操作符(还参见条款 M8),你必须为函数可能遇到 bad_alloc 异常
作好准备。
现在常说预防胜于治疗(即:做任何事都要未雨绸缪 译者注),但是有时却是预防困难
而治疗容易。也就是说有时直接处理 unexpected 异常比防止它们被抛出要简单。例如你正
在编写一个软件,精确地使用了异常规格,但是你必须从没有使用异常规格的程序库中调用
函数,要防止抛出 unexpected 异常是不现实的,因为这需要改变程序库中的代码。
虽然防止抛出 unexpected 异常是不现实的,但是 C++允许你用其它不同的异常类型替
换 unexpected 异常,你能够利用这个特性。例如你希望所有的 unexpected 异常都被替换为
UnexpectedException 对象。你能这样编写代码:
class UnexpectedException {}; // 所有的 unexpected 异常对象被
//替换为这种类型对象
void convertUnexpected() // 如果一个 unexpected 异常被
{ // 抛出,这个函数被调用
throw UnexpectedException();
}
通过用 convertUnexpected 函数替换缺省的 unexpected 函数,来使上述代码开始运行。:
bbs.theithome.com


set_unexpected(convertUnexpected);
当你这么做了以后,一个 unexpected 异常将触发调用 convertUnexpected 函数。
Unexpected 异常被一种 UnexpectedException 新异常类型替换。如果被违反的异常规格包
含 UnexpectedException 异常,那么异常传递将继续下去,好像异常规格总是得到满足。(如
果异常规格没有包含 UnexpectedException,terminate 将被调用,就好像你没有替换
unexpected 一样)
另一种把 unexpected 异常转变成知名类型的方法是替换 unexpected 函数,让其重新抛
出当前异常,这样异常将被替换为 bad_exception。你可以这样编写:
void convertUnexpected() // 如果一个 unexpected 异常被
{ //抛出,这个函数被调用
throw; // 它只是重新抛出当前
} // 异常
set_unexpected(convertUnexpected);
// 安装 convertUnexpected
// 做为 unexpected
// 的替代品
如果这么做,你应该在所有的异常规格里包含 bad_exception(或它的基类,标准类
exception)。你将不必再担心如果遇到 unexpected 异常会导致程序运行终止。任何不听话
的异常都将被替换为 bad_exception,这个异常代替原来的异常继续传递。
到现在你应该理解异常规格能导致大量的麻烦。编译器仅仅能部分地检测它们的使用是
否一致,在模板中使用它们会有问题,一不注意它们就很容易被违反,并且在缺省的情况下
它们被违反时会导致程序终止运行。异常规格还有一个缺点就是它们能导致 unexpected 被
触发,即使一个 high-level 调用者准备处理被抛出的异常,比如下面这个几乎一字不差地
来自从条款 M11 例子:
class Session { // for modeling online
public: // sessions
~Session();
...
private:
static void logDestruction(Session *objAddr) throw();
};
Session::~Session()
{
try {
bbs.theithome.com


logDestruction(this);
}
catch (...) { }
}
session 的析构函数调用 logDestruction 记录有关 session 对象被释放的信息,它明
确地要捕获从 logDestruction 抛出的所有异常。但是 logDestruction 的异常规格表示其不
抛出任何异常。现在假设被 logDestruction 调用的函数抛出了一个异常,而 logDestruction
没有捕获。我们不会期望发生这样的事情,但正如我们所见,很容易就会写出违反异常规格
的代码。当这个异常通过 logDestruction 传递出来,unexpected 将被调用,缺省情况下将
导致程序终止执行。这是一个正确的行为,但这是 session 析构函数的作者所希望的行为
么?作者想处理所有可能的异常,所以好像不应该不给 session 析构函数里的 catch 块执行
的机会就终止程序。如果 logDestruction 没有异常规格,这种事情就不会发生(一种防止
的方法是如上所描述的那样替换 unexpected)。
以全面的角度去看待异常规格是非常重要的。它们提供了优秀的文档来说明一个函数抛
出异常的种类,并且在违反它的情况下,会有可怕的结果,程序被立即终止,在缺省时它们
会这么做。同时编译器只会部分地检测它们的一致性,所以他们很容易被不经意地违反。而
且他们会阻止 high-level 异常处理器来处理 unexpected 异常,即使这些异常处理器知道如
何去做。
综上所述,异常规格是一个应被审慎使用的特性。在把它们加入到你的函数之前,应考
虑它们所带来的行为是否就是你所希望的行为。
5.7 Item M15:了解异常处理的系统开销
为了在运行时处理异常,程序要记录大量的信息。无论执行到什么地方,程序都必须能
够识别出如果在此处抛出异常的话,将要被释放哪一个对象;程序必须知道每一个入口点,
以便从 try 块中退出;对于每一个 try 块,他们都必须跟踪与其相关的 catch 子句以及这些
catch 子句能够捕获的异常类型。这种信息的记录不是没有代价的。虽然确保程序满足异常
规格不需要运行时的比较(runtime comparisons),而且当异常被抛出时也不用额外的开销
来释放相关的对象和匹配正确的 catch 字句。但是异常处理确是有代价的,即使你没有使用
try,throw 或 catch 关键字,你同样得付出一些代价。
让我们先从你不使用任何异常处理特性也要付出的代价谈起。你需要空间建立数据结构
来跟踪对象是否被完全构造(constructed)(参见条款 M10),你也需要 CPU 时间保持这些
数据结构不断更新。这些开销一般不是很大,但是采用不支持异常的方法编译的程序一般比
支持异常的程序运行速度更快所占空间也更小。
在理论上,你不能对这些代价进行选择:异常是 C++的一部分,C++编译器必须支持异
bbs.theithome.com


常。也就是说,当你不用异常处理时你不能让编译器生产商消除这方面的开销,因为程序一
般由多个独立生成的目标文件(object files)组成,只有一个目标文件不进行异常处理并
不能代表其他目标文件不进行异常处理。而且即使组成可执行文件的目标文件都不进行异常
处理,那么还有它们所连接的程序库呢?如果程序的任何一部分使用了异常,其它部分必须
也支持异常。否则在运行时程序就不可能提供正确的异常处理。
不过这只是理论,实际上大部分支持异常的编译器生产商都允许你自由控制是否在生成
的代码里包含进支持异常的内容。如果你知道你程序的任何部分都不使用 try,throw 或
catch,并且你也知道所连接的程序库也没有使用 try,throw 或 catch,你就可以采用不支
持异常处理的方法进行编译,这可以缩小程序的尺寸和提高速度,否则你就得为一个不需要
的特性而付出代价。随着时间的推移,使用异处理的程序库开始变得普遍了,上面这种方法
将逐渐不能使用,但是根据目前的软件开发情况来看,如果你已经决定不使用任何的异常特
性,那么采用不支持异常的方法编译程序是一个性能优化的合理方法。同样这对于想避开异
常的程序库来说也是一个性能优化的好方法,这能保证异常不会从客户端程序传递进程序库
里,不过同时这样做也会妨碍客户端程序重定义程序库中声明的虚拟函数,并且不允许有在
客户端定义的回调函数。
使用异常处理的第二个开销来自于 try 块,无论何时使用它,也就是当你想能够捕获异
常时,那你都得为此付出代价。不同的编译器实现 try 块的方法不同,所以编译器与编译器
间的开销也不一样。粗略地估计,如果你使用 try 块,代码的尺寸将增加 5%-10%并且运
行速度也同比例减慢。这还是假设程序没有抛出异常,我这里讨论的只是在程序里使用 try
块的开销。为了减少开销,你应该避免使用无用的 try 块。
编译器为异常规格生成的代码与它们为 try 块生成的代码一样多,所以一个异常规格一
般花掉与 try 块一样多的系统开销。什么?你说你认为异常规格只是一个规格而已,你认为
它们不会产生代码?那么好,现在你应该对此有新的认识了。
现在我们来到了问题的核心部分,看看抛出异常的开销。事实上我们不用太关心这个问
题,因为异常是很少见的,这种事件的发生往往被描述为 exceptional(异常的,罕见的)。
80-20 规则(参见条款 M16)告诉我们这样的事件不会对整个程序的性能造成太大的影响。
但是我知道你仍旧好奇地想知道如果抛出一个异常到底会有多大的开销,答案是这可能会比
较大。与一个正常的函数返回相比,通过抛出异常从函数里返回可能会慢三个数量级。这个
开销很大。但是仅仅当你抛出异常时才会有这个开销,一般不会发生。但是如果你用异常表
示一个比较普遍的状况,例如完成对数据结构的遍历或结束一个循环,那你必须重新予以考
虑。
不过请等一下,你问我是怎么知道这些事情的呢?如果说支持异常对于大多数编译器来
说是一个较新的特性,如果说不同的编译器的异常方法也不同,那么我如何能说程序的尺寸
将增大 5%-10%,它的速度也同比例减慢,而且如果有大量的异常被抛出,程序运行速度会
bbs.theithome.com


呈数量级的减慢呢?答案是令人惊恐的:一些传闻和一些基准测试(benchmarks)(参见条
款 M23)。事实是大部分人包括编译器生产商在异常处理方面几乎没有什么经验,所以尽管
我们知道异常确实会带来开销,却很难预测出开销的准确数量。
谨慎的做法是对本条款所叙述的开销有了解,但是不深究具体的数量(即定性不定量译
者注)。不论异常处理的开销有多大我们都得坚持只有必须付出时才付出的原则。为了使你
的异常开销最小化,只要可能就尽量采用不支持异常的方法编译程序,把使用 try 块和异常
规格限制在你确实需要它们的地方,并且只有在确为异常的情况下(exceptional)才抛出
异常。如果你在性能上仍旧有问题,总体评估一下你的软件以决定异常支持是否是一个起作
用的因素。如果是,那就考虑选择其它的编译器,能在 C++异常处理方面具有更高实现效率
的编译器。
6. 效率
我怀疑一些人在 C++软件开发人员身上进行秘密的巴甫洛夫试验,否则为什么当提到
“效率”这个词时,许多程序员都会流口水。(Scott Meyers 真幽默 译者注)
事实上,效率可不是一个开玩笑的事情。一个太大或太慢的程序它们的优点无论多么引
人注目都不会为人们所接受。本来就应该这样。软件是用来帮助我们更好地工作,说运行速
度慢才是更好的,说需要 32MB 内存的程序比仅仅需要 16MB 内存的程序好,说占用 100MB
磁盘空间的程序比仅仅占用 50MB 磁盘空间的程序好,这简直是无稽之谈。而且尽管有一些
程序确是为了进行更复杂的运算才占用更多的时间和空间,但是对于许多程序来说只能归咎
于其糟糕的设计和马虎的编程。
在用 C++写出高效地程序之前,必须认识到 C++本身绝对与你所遇到的任何性能上的问
题无关。如果想写出一个高效的 C++程序,你必须首先能写出一个高效的算法。太多的开发
人员都忽视了这个简单的道理。是的,循环能够被手工展开,移位操作(shift operation)
能够替换乘法,但是如果你所使用的高层算法其内在效率很低,这些微调就不会有任何作用。
当线性算法可用时你是否还用二次方程式算法?你是否一遍又一遍地计算重复的数值?如
果是的话,可以毫不夸张地把你的程序比喻成一个二流的观光地,即如果你有额外的时间,
才值得去看一看。
本章的内容从两个角度阐述效率的问题。第一是从语言独立的角度,关注那些你能在任
何语言里都能使用的东西。C++为它们提供了特别吸引人的实现途径,因为它对封装的支持
非常好,从而能够用更好的算法与数据结构来替代低效的类似实现,同时接口可以保持不变。
第二是关注 C++语言本身。高性能的算法与数据结构虽然非常好,但如果实际编程中代
码实现得很粗糙,效率也会降低得相当多。潜在危害性最大的错误是既容易犯而又不容易察
觉的错误,濒繁地构造和释放大量的对象就是一种这样的错误。过多的对象构造和对象释放
bbs.theithome.com


对于你的程序性能来说就象是在大出血,在每次建立和释放不需要的对象的过程中,宝贵的
时间就这么流走了。这个问题在 C++程序中很普遍,我将用四个条款来说明这些对象从哪里
来的,在不影响程序代码正确性的基础上又如何消除它们。
建立大量的对象不会使程序变大而只会使其运行速度变慢。还有其它一些影响性能提高
的因素,包括程序库的选择和语言特性的实现(implementations of language features)。
在下面的条款中我也将涉及。
在学习了本章内容以后,你将熟悉能够提高程序性能的几个原则,这些原则可以适用于
你所写的任何程序。你将知道如何准确地防止在你的软件里出现不需要的对象,并且对编译
器生成可执行代码的行为有着敏锐的感觉。
俗话说有备无患(forewarned is forearmed)。所以把下面的内容想成是战斗前的准备。
6.1 Item M16:牢记 80-20 准则(80-20 rule)
80-20 准则说的是大约 20%的代码使用了 80%的程序资源;大约 20%的代码耗用了大
约 80%的运行时间;大约 20%的代码使用了 80%的内存;大约 20%的代码执行 80%的磁
盘访问;80%的维护投入于大约 20%的代码上;通过无数台机器、操作系统和应用程序上
的实验这条准则已经被再三地验证过。80-20 准则不只是一条好记的惯用语,它更是一条
有关系统性能的指导方针,它有着广泛的适用性和坚实的实验基础。
当想到 80-20 准则时,不要在具体数字上纠缠不清,一些人喜欢更严格的 90-10 准则,
而且也有一些试验证据支持它。不管准确地数字是多少,基本的观点是一样的:软件整体的
性能取决于代码组成中的一小部分。
当程序员力争最大化提升软件的性能时,80-20 准则既简化了你的工作又使你的工作
变得复杂。一方面 80-20 准则表示大多数时间你能够编写性能一般的代码,因为 80%的时
间里这些代码的效率不会影响到整个系统的性能,这会减少一些你的工作压力。而另一方面
这条准则也表示如果你的软件出现了性能问题,你将面临一个困难的工作,因为你不仅必须
找到导致问题的那一小块代码的位置,还必须寻找方法提高它们的性能。这些任务中最困难
的一般是找到系统瓶颈。基本上有两个不同的方法用来寻找:大多数人用的方法和正确的方
法。
大多数人寻找瓶颈的方法就是猜。通过经验、直觉、算命纸牌、显灵板、传闻或者其它
更荒唐的东西,一个又一个程序员一本正经地宣称程序的性能问题已被找到,因为网络的延
迟,不正确的内存分配,编译器没有进行足够的优化或者一些笨蛋主管拒绝在关键的循环里
使用汇编语句。这些评估总是以一种带有嘲笑的盛气凌人的架式发布出来,通常这些嘲笑者
和他们的预言都是错误的。
大多数程序员在他们程序性能特征上的直觉都是错误的,因为程序性能特征往往不能靠
bbs.theithome.com


直觉来确定。结果为提高程序各部分的效率而倾注了大量的精力,但是对程序的整体行为没
有显著的影响。例如在程序里使用能够最小化计算量的奇特算法和数据结构,但是如果程序
的性能限制主要在 I/O 上(I/O-bound)那么就丝毫起不到作用。采用 I/O 性能强劲的程序
库代替编译器本身附加的程序库(参见条款 M23),如果程序的性能瓶颈主要在 CPU 上
(CPU-bound),这种方法也不会起什么作用。
在这种情况下,面对运行速度缓慢或占用过多内存的程序,你该如何做呢?80-20 准
则的含义是:胡乱地提高一部分程序的效率不可能有很大帮助。程序性能特征往往不能靠直
觉确定,这个事实意味着试图猜出性能瓶颈不可能比胡乱地提高一部分程序的效率这种方法
好到哪里去。那么会后什么结果呢?
结果是用经验猜测程序那 20%的部分只会导致你心痛。正确的方法是用 profiler 程序
识别出令人讨厌的程序的 20%部分。不是所有的工作都让 profiler 去做。你想让它去直接
地测量你感兴趣的资源。例如如果程序太缓慢,你想让 profiler 告诉你程序的各个部分都
耗费了多少时间。然后你关注那些局部效率能够被极大提高的地方,这也将会很大地提高整
体的效率。
profiler 告诉你每条语句执行了多少次或各函数被调用了多少次,这是一个作用有限
的工具。从提高性能的观点来看,你不用关心一条语句或一个函数被调用了多少次。毕竟很
少遇到用户或程序库的调用者抱怨执行了太多的语句或调用了太多的函数。如果软件足够
快,没有人关心有多少语句被执行,如果程序运行过慢,不会有人关心语句有多么的少。他
们所关心的是他们厌恶等待,如果你的程序让他们等待,他们也会厌恶你。
不过,知道语句执行或函数调用的频繁程度,有时能帮助你洞察软件内部的行为。例如如果
你建立了 100 个某种类型的对象,会发现你调用该类的构造函数有上千次,这个信息无疑是
有价值的。而且语句和函数的调用次数能间接地帮助你理解不能直接测量的软件行为。例如,
如果你不能直接测量动态内存的使用,那么知道内存分配函数和内存释函数的调用频率也是
有帮助的。(也就是,operators new, new[], delete, and delete[]—参见条款 M8)
当然即使最好的 profiler 也是受其处理的数据所影响。如果用缺乏代表性的数据
profile 你的程序,你就不能抱怨 profiler 导致你优化程序的那 80%的部分,从而不曾对
程序通常的性能有什么影响。记住 profiler 仅能够告诉你在某一次运行(或某几次运行)
时一个程序运行情况,所以如果你用不具有代表性的输入数据 profile 一个程序,那你所进
行的 profile 也没有代表型。相反这样做很可能导致你去优化不常用的软件行为,而在软件
的常用领域,则对软件整体的效率起相反作用(即效率下降)。
防止这种不正确的结果,最好的方法是用尽可能多的数据 profile 你的软件。此外,你
必须确保每组数据在客户(或至少是最重要的客户)如何使用软件的方面能有代表性。通常
获取有代表性的数据是很容易的,因为许多客户都愿意让你用他们的数据进行 profile。毕
竟你是为了他们需求而优化软件。
bbs.theithome.com


6.2 Item M17:考虑使用lazy evaluation(懒惰计算法)
从效率的观点来看,最佳的计算就是根本不计算,那好,不过如果你根本就不用进行计
算的话,为什么还在程序开始处加入代码进行计算呢?并且如果你不需要进行计算,那么如
何必须执行这些代码呢?
关键是要懒惰。
还记得么?当你还是一个孩子时,你的父母叫你整理房间。你如果象我一样,就会说“好
的“,然后继续做你自己的事情。你不会去整理自己的房间。在你心里整理房间被排在了最
后的位置,实际上直到你听见父母下到门厅来查看你的房间是否已被整理时,你才会猛跑进
自己的房间里并用最快的速度开始整理。如果你走运,你父母可能不会来检查你的房间,那
样的话你就能根本不用整理房间了。
同样的延迟策略也适用于具有五年工龄的 C++程序员的工作上。在计算机科学中,我们
尊称这样的延迟为 lazy evaluation(懒惰计算法)。当你使用了 lazy evaluation 后,采
用此种方法的类将推迟计算工作直到系统需要这些计算的结果。如果不需要结果,将不用进
行计算,软件的客户和你的父母一样,不会那么聪明。
也 许 你 想 知 道 我 说 的 这 些 到 底 是 什 么 意 思 。 也 许 举 一 个 例 子 可 以 帮 助 你 理 解 。 lazy
evaluation 广泛适用于各种应用领域,所以我将分四个部分讲述。
z 引用计数
class String { ... }; // 一个 string 类 (the standard
// string type may be implemented
// as described below, but it
// doesn't have to be)
String s1 = "Hello";
String s2 = s1; / 调用 string 拷贝构造函数
通常 string 拷贝构造函数让 s2 被 s1 初始化后,s1 和 s2 都有自己的”Hello”拷贝。
这种拷贝构造函数会引起较大的开销,因为要制作 s1 值的拷贝,并把值赋给 s2,这通常需
要用 new 操作符分配堆内存(参见条款 8),需要调用 strcpy 函数拷贝 s1 内的数据到 s2。这
是一个 eager evaluation(热情计算):只因为到 string 拷贝构造函数,就要制作 s1 值的
拷贝并把它赋给 s2。然而这时的 s2 并不需要这个值的拷贝,因为 s2 没有被使用。
懒惰能就是少工作。不应该赋给 s2 一个 s1 的拷贝,而是让 s2 与 s1 共享一个值。我们
只须做一些记录以便知道谁在共享什么,就能够省掉调用 new 和拷贝字符的开销。事实上
s1 和 s2 共享一个数据结构,这对于 client 来说是透明的,对于下面的例子来说,这没有
什么差别,因为它们只是读数据:
cout << s1; // 读 s1 的值
cout << s1 + s2; // 读 s1 和 s2 的值
bbs.theithome.com


仅仅当这个或那个 string 的值被修改时,共享同一个值的方法才会造成差异。仅仅修
改一个 string 的值,而不是两个都被修改,这一点是极为重要的。例如这条语句:
s2.convertToUpperCase();
这是至关紧要的,仅仅修改 s2 的值,而不是连 s1 的值一块修改。
为了这样执行语句,string 的 convertToUpperCase 函数应该制作 s2 值的一个拷贝,
在修改前把这个私有的值赋给 s2。在 convertToUpperCase 内部,我们不能再懒惰了:必须
为 s2(共享的)值制作拷贝以让 s2 自己使用。另一方面,如果不修改 s2,我们就不用制作
它自己值的拷贝。继续保持共享值直到程序退出。如果我们很幸运,s2 不会被修改,这种
情况下我们永远也不会为赋给它独立的值耗费精力。
这种共享值方法的实现细节(包括所有的代码)在条款 M29 中被提供,但是其蕴含的原
则就是 lazy
evaluation:除非你确实需要,不去为任何东西制作拷贝。我们应该是懒惰的,只要可能就
共享使用其它值。在一些应用领域,你经常可以这么做。
z 区别对待读取和写入
继续讨论上面的 reference-counting string 对象。来看看使用 lazy evaluation 的第
二种方法。考虑这样的代码:
String s = "Homer's Iliad"; // 假设是一个
// reference-counted string
...
cout << s[3]; // 调用 operator[] 读取 s[3]
s[3] = 'x'; // 调用 operator[] 写入 s[3]
首先调用 operator[]用来读取 string 的部分值,但是第二次调用该函数是为了完成写
操作。我们应能够区别对待读调用和写调用,因为读取 reference-counted string 是很容
易的,而写入这个 string 则需要在写入前对该 string 值制作一个新拷贝。
我们陷入了困难之中。为了能够这样做,需要在 operator[]里采取不同的措施(根据
是为了完成读取操作而调用该函数还是为了完成写入操作而调用该函数)。我们如果判断调
用 operator[]的 context 是读取操作还是写入操作呢?残酷的事实是我们不可能判断出来。
通过使用 lazy evaluation 和条款 M30 中讲述的 proxy class,我们可以推迟做出是读操作
还是写操作的决定,直到我们能判断出正确的答案。
z Lazy Fetching(懒惰提取)
第三个 lazy evaluation 的例子,假设你的程序使用了一些包含许多字段的大型对象。
这些对象的生存期超越了程序运行期,所以它们必须被存储在数据库里。每一个对都有一个
唯一的对象标识符,用来从数据库中重新获得对象:
class LargeObject { // 大型持久对象
bbs.theithome.com


public:
LargeObject(ObjectID id); // 从磁盘中恢复对象
const string& field1() const; // field 1 的值
int field2() const; // field 2 的值
double field3() const; // ...
const string& field4() const;
const string& field5() const;
...
};
现在考虑一下从磁盘中恢复 LargeObject 的开销:
void restoreAndProcessObject(ObjectID id)
{
LargeObject object(id); // 恢复对象
...
}
因为 LargeObject 对象实例很大,为这样的对象获取所有的数据,数据库的操作的开销
将非常大,特别是如果从远程数据库中获取数据和通过网络发送数据时。而在这种情况下,
不需要读去所有数据。例如,考虑这样一个程序:
void restoreAndProcessObject(ObjectID id)
{
LargeObject object(id);
if (object.field2() == 0) {
cout << "Object " << id << ": null field2.\n";
}
}
这里仅仅需要 filed2 的值,所以为获取其它字段而付出的努力都是浪费。
当 LargeObject 对象被建立时,不从磁盘上读取所有的数据,这样懒惰法解决了这个问
题。不过这时建立的仅是一个对象“壳”,当需要某个数据时,这个数据才被从数据库中取
回。这种“demand-paged”对象初始化的实现方法是:
class LargeObject {
public:
LargeObject(ObjectID id);
const string& field1() const;
int field2() const;
bbs.theithome.com


double field3() const;
const string& field4() const;
...
private:
ObjectID oid;
mutable string *field1Value; //参见下面有关
mutable int *field2Value; // "mutable"的讨论
mutable double *field3Value;
mutable string *field4Value;
...
};
LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), ...
{}
const string& LargeObject::field1() const
{
if (field1Value == 0) {
从数据库中为 filed 1 读取数据,使
field1Value 指向这个值;
}
return *field1Value;
}
对象中每个字段都用一个指向数据的指针来表示,LargeObject 构造函数把每个指针初
始化为空。这些空指针表示字段还没有从数据库中读取数值。每个 LargeObject 成员函数在
访问字段指针所指向的数据之前必须字段指针检查的状态。如果指针为空,在对数据进行操
作之前必须从数据库中读取对应的数据。
实现 Lazy Fetching 时,你面临着一个问题:在任何成员函数里都有可能需要初始化空
指针使其指向真实的数据,包括在 const 成员函数里,例如 field1。然而当你试图在 const
成员函数里修改数据时,编译器会出现问题。最好的方法是声明字段指针为 mutable,这表
示在任何函数里它们都能被修改,甚至在 const 成员函数里(参见 Effective C++条款 21)。
这就是为什么在 LargeObject 里把字段声明为 mutable。
关键字 mutalbe 是一个比较新的 C++ 特性,所以你用的编译器可能不支持它。如果是
这样,你需要找到另一种方法让编译器允许你在 const 成员函数里修改数据成员。一种方法
叫做“fake this”(伪造 this 指针),你建立一个指向 non-const 指针,指向的对象与 this
bbs.theithome.com


指针一样。当你想修改数据成员时,你通过“fake this”访问它:
class LargeObject {
public:
const string& field1() const; // 没有变化
...
private:
string *field1Value; // 不声明为 mutable
... // 因为老的编译器不
}; // 支持它
const string& LargeObject::field1() const
{
// 声明指针, fakeThis, 其与 this 指向同样的对象
// 但是已经去掉了对象的常量属性
LargeObject * const fakeThis =
const_cast<LargeObject* const>(this);
if (field1Value == 0) {
fakeThis->field1Value = // 这赋值是正确的,
the appropriate data // 因为 fakeThis 指向的
from the database; //对象不是 const
}
return *field1Value;
}
这个函数使用了 const_cast(参见条款 2),去除了*this 的 const 属性。如果你的编译
器不支持 cosnt_cast,你可以使用老式 C 风格的 cast:
// 使用老式的 cast,来模仿 mutable
const string& LargeObject::field1() const
{
LargeObject * const fakeThis = (LargeObject* const)this;
... // as above
}
再来看 LargeObject 里的指针,必须把这些指针都初始化为空,然后每次使用它们时都
必须进行测试,这是令人厌烦的而且容易导致错误发生。幸运的是使用 smart(灵巧)指针可
bbs.theithome.com


以自动地完成这种苦差使,具体内容可以参见条款 M28。如果在 LargeObject 里使用 smart
指针,你也将发现不再需要用 mutalbe 声明指针。这只是暂时的,因为当你实现 smart 指针
类时你最终会碰到 mutalbe。
z Lazy Expression Evaluation(懒惰表达式计算)
有关 lazy evaluation 的最后一个例子来自于数字程序。考虑这样的代码:
template<class T>
class Matrix { ... }; // for homogeneous matrices
Matrix<int> m1(1000, 1000); // 一个 1000 * 1000 的矩阵
Matrix<int> m2(1000, 1000); // 同上
...
Matrix<int> m3 = m1 + m2; // m1+m2
通常 operator 的实现使用 eagar evaluation:在这种情况下,它会计算和返回 m1 与
m2 的和。这个计算量相当大(1000000 次加法运算),当然系统也会分配内存来存储这些值。
lazy evaluation 方法说这样做工作太多,所以还是不要去做。而是应该建立一个数据
结构来表示 m3 的值是 m1 与 m2 的和,在用一个 enum 表示它们间是加法操作。很明显,建立
这个数据结构比 m1 与 m2 相加要快许多,也能够节省大量的内存。
考虑程序后面这部分内容,在使用 m3 之前,代码执行如下:
Matrix<int> m4(1000, 1000);
... // 赋给 m4 一些值
m3 = m4 * m1;
现在我们可以忘掉 m3 是 m1 与 m2 的和(因此节省了计算的开销),在这里我们应该记住
m3 是 m4 与 m1 运算的结果。不必说,我们不用进行乘法运算。因为我们是懒惰的,还记得
么?
这个例子看上去有些做作,因为一个好的程序员不会这样写程序:计算两个矩阵的和而
不去用它们,但是它实际上又不象看上去的那么做作。虽然好程序员不会进行不需要的计算,
但是在维护中程序员修改了程序的路径,使得以前有用的计算变得没有了作用,这种情况是
常见的。通过定义使用前才进行计算的对象可以减少这种情况发生的可能性(参见
Effective C++条款 32),不过这个问题偶尔仍然会出现。
但是如果这就是使用 lazy evaluation 唯一的时机,那就太不值得了。一个更常见的应
用领域是当我们仅仅需要计算结果的一部分时。例如假设我们初始化 m3 的值为 m1 和 m2 的
和,然后象这样使用 m3:
cout << m3[4]; // 打印 m3 的第四行
很明显,我们不能再懒惰了,应该计算 m3 的第四行值。但是我们也不能雄心过大,我
们没有理由计算 m3 第四行以外的结果;m3 其余的部分仍旧保持未计算的状态直到确实需要
bbs.theithome.com


它们的值。很走运,我们一直不需要。
我们怎么可能这么走运呢?矩阵计算领域的经验显示这种可能性很大。实际上 lazy
evaluation 就存在于 APL 语言中。APL 是在 1960 年代发展起来语言,能够进行基于矩阵的
交互式的运算。那时侯运行它的计算机的运算能力还没有现在微波炉里的芯片高,APL 表面
上能够进行进行矩阵的加、乘,甚至能够快速地与大矩阵相除!它的技巧就是 lazy
evaluation。这个技巧通常是有效的,因为一般 APL 的用户加、乘或除以矩阵不是因为他们
需要整个矩阵的值,而是仅仅需要其一小部分的值。APL 使用 lazy evaluation 来拖延它们
的计算直到确切地知道需要矩阵哪一部分的结果,然后仅仅计算这一部分。实际上,这能允
许用户在一台根本不能完成 eager
evaluation 的计算机上交互式地完成大量的计算。现在计算机速度很快,但是数据集也更
大,用户也更缺乏耐心,所以很多现在的矩阵库程序仍旧使用 lazy evaluation。
公正地讲,懒惰有时也会失败。如果这样使用 m3:
cout << m3; // 打印 m3 所有的值
一切都完了,我们必须计算 m3 的全部数值。同样如果修改 m3 所依赖的任一个矩阵,我
们也必须立即计算:
m3 = m1 + m2; // 记住 m3 是 m1 与 m2 的和
//
m1 = m4; // 现在 m3 是 m2 与 m1 的旧值之和!
//
这里我们我们必须采取措施确保赋值给 m1 以后不会改变 m3。在 Matrix<int>赋值操作
符里,我们能够在改变 m1 之前捕获 m3 的值,或者我们可以给 m1 的旧值制作一个拷贝让 m3
依赖于这个拷贝计算,我们必须采取措施确保 m1 被赋值以后 m3 的值保持不变。其它可能会
修改矩阵的函数都必须用同样的方式处理。
因为需要存储两个值之间的依赖关系,维护存储值、依赖关系或上述两者,重载操作符
例如赋值符、拷贝操作和加法操作,所以 lazy evaluation 在数字领域应用得很多。另一方
面运行程序时它经常节省大量的时间和空间。
z 总结
以上这四个例子展示了 lazy evaluation 在各个领域都是有用的:能避免不需要的对象
拷贝,通过使用 operator[]区分出读操作,避免不需要的数据库读取操作,避免不需要的
数字操作。但是它并不总是有用。就好象如果你的父母总是来检查你的房间,那么拖延整理
房间将不会减少你的工作量。实际上,如果你的计算都是重要的,lazy evaluation 可能会
减慢速度并增加内存的使用,因为除了进行所有的计算以外,你还必须维护数据结构让 lazy
evaluation 尽可能地在第一时间运行。在某些情况下要求软件进行原来可以避免的计算,
这时 lazy evaluation 才是有用的。
bbs.theithome.com


lazy evaluation 对于 C++来说没有什么特殊的东西。这个技术能被运用于各种语言里,
几种语言例如著名的 APL、dialects of Lisp(事实上所有的数据流语言)都把这种思想做
为语言的一个基本部分。然而主流程序设计语言采用的是 eager evaluation,C++是主流语
言。不过 C++特别适合用户实现 lazy evaluation,因为它对封装的支持使得能在类里加入
lazy evaluation,而根本不用让类的使用者知道。
再看一下上述例子中的代码片段,你就能知道采用 eager 还是 lazy evaluation,在类
提供的接口中并没有半点差别。这就是说我们可以直接用 eager evaluation 方法来实现一
个类,但是如果你用通过 profiler 调查(参见条款 M16)显示出类实现有一个性能瓶颈,
就可以用使用 lazy evaluation 的类实现来替代它(参见 Effective C++条款 34)。对于使
用者来说所改变的仅是性能的提高(重新编译和链接后)。这是使用者喜欢的软件升级方式,
它使你完全可以为懒惰而骄傲。
6.3 Item M18:分期摊还期望的计算
在条款 M17 中,我极力称赞懒惰的优点,尽可能地拖延时间,并且我解释说懒惰如何提
高程序的运行效率。在这个条款里我将采用一种不同的态度。这里将不存在懒惰。我鼓励你
让程序做的事情比被要求的还要多,通过这种方式来提高软件的性能。这个条款的核心就是
over-eager evaluation(过度热情计算法):在要求你做某些事情以前就完成它们。例如下
面这个模板类,用来表示放有大量数字型数据的一个集合:
template<class NumericalType>
class DataCollection {
public:
NumericalType min() const;
NumericalType max() const;
NumericalType avg() const;
...
};
假设 min,max 和 avg 函数分别返回现在这个集合的最小值,最大值和平均值,有三种方
法实现这三种函数。使用 eager evaluation(热情计算法),当 min,max 和 avg 函数被调用
时,我们检测集合内所有的数值,然后返回一个合适的值。使用 lazy evaluation(懒惰计
算法),只有确实需要函数的返回值时我们才要求函数返回能用来确定准确数值的数据结构。
使用 over-eager evaluation(过度热情计算法),我们随时跟踪目前集合的最小值,最大
值和平均值,这样当 min,max 或 avg 被调用时,我们可以不用计算就立刻返回正确的数值。
如果频繁调用 min,max 和 avg,我们把跟踪集合最小值、最大值和平均值的开销分摊到所有
这些函数的调用上,每次函数调用所分摊的开销比 eager evaluation 或 lazy evaluation
bbs.theithome.com


要小。
隐藏在 over-eager evaluation 后面的思想是如果你认为一个计算需要频繁进行,你就
可以设计一个数据结构高效地处理这些计算需求,这样可以降低每次计算需求时的开销。
采用 over-eager 最简单的方法就是 caching(缓存)那些已经被计算出来而以后还有可
能需要的值。例如你编写了一个程序,用来提供有关雇员的信息,这些信息中的经常被需要
的部分是雇员的办公隔间号码。而假设雇员信息存储在数据库里,但是对于大多数应用程序
来说,雇员隔间号都是不相关的,所以数据库不对查抄它们进行优化。为了避免你的程序给
数据库造成沉重的负担,可以编写一个函数 findCubicleNumber,用来缓存查找到的数据。
以后需要已经被获取的隔间号时,可以在 cache 里找到,而不用向数据库查询。
以下是实现 findCubicleNumber 的一种方法:它使用了标准模板库(STL)里的 map 对
象(有关 STL 参见条款 M35)。
int findCubicleNumber(const string& employeeName)
{
// 定义静态 map,存储 (employee name, cubicle number)
// pairs. 这个 map 是 local cache。
typedef map<string, int> CubicleMap;
static CubicleMap cubes;
// try to find an entry for employeeName in the cache;
// the STL iterator "it" will then point to the found
// entry, if there is one (see Item 35 for details)
CubicleMap::iterator it = cubes.find(employeeName);
// "it"'s value will be cubes.end() if no entry was
// found (this is standard STL behavior). If this is
// the case, consult the database for the cubicle
// number, then add it to the cache
if (it == cubes.end()) {
int cubicle =
the result of looking up employeeName's cubicle
number in the database;
cubes[employeeName] = cubicle; // add the pair
// (employeeName, cubicle)
// to the cache
return cubicle;
}
bbs.theithome.com


else {
// "it" points to the correct cache entry, which is a
// (employee name, cubicle number) pair. We want only
// the second component of this pair, and the member
// "second" will give it to us
return (*it).second;
}
}
不要陷入 STL 代码的实现细节里(你读完条款 M35 以后,你会比较清楚)。应该把注意
力放在这个函数蕴含的方法上。这个方法是使用 local cache,用开销相对不大的内存中查
询来替代开销较大的数据库查询。假如隔间号被不止一次地频繁需要,在
findCubicleNumber 内使用缓存会减少返回隔间号的平均开销。
(上述代码里有一个细节需要解释一下,最后一个语句返回的是(*it).second,而不是
常用的 it->second。为什么?答案是这是为了遵守 STL 的规则。简单地说,iterator 是一
个对象,不是指针,所以不能保证”->”被正确应用到它上面。不过 STL 要求”.”和”*”
在 iterator 上是合法的,所以(*it).second 在语法上虽然比较繁琐,但是保证能运行。)
catching 是一种分摊期望的计算开销的方法。Prefetching(预提取)是另一种方法。你
可以把 prefech 想象成购买大批商品而获得的折扣。例如磁盘控制器从磁盘读取数据时,它
们会读取一整块或整个扇区的数据,即使程序仅需要一小块数据。这是因为一次读取一大块
数据比在不同时间读取两个或三个小块数据要快。而且经验显示如果需要一个地方的数据,
则很可能也需要它旁边的数据。这是位置相关现象。正因为这种现象,系统设计者才有理由
为指令和数据使用磁盘 cache 和内存 cache,还有使用指令 prefetch。
你说你不关心象磁盘控制器或 CPU cache 这样低级的东西。没有问题,prefetch 在高
端应用里也有优点。例如你为 dynamic 数组实现一个模板,dynamic 就是开始时具有一定的
尺寸,以后可以自动扩展的数组,所以所有非负的索引都是合法的:
template<class T> // dynamic 数组
class DynArray { ... }; // 模板
DynArray<double> a; // 在这时, 只有 a[0]
// 是合法的数组元素
a[22] = 3.5; // a 自动扩展
//: 现在索引 0-22
// 是合法的
a[32] = 0; // 有自行扩展;
bbs.theithome.com


// 现在 a[0]-a[32]是合法的
一个 DynArray 对象如何在需要时自行扩展呢?一种直接的方法是分配所需的额外的内
存。就象这样:
template<class T>
T& DynArray<T>::operator[](int index)
{
if (index < 0) {
throw an exception; // 负数索引仍不合法
}
if (index >当前最大的索引值) {
调用 new 分配足够的额外内存,以使得
索引合法;
}
返回 index 位置上的数组元素;
}
每次需要增加数组长度时,这种方法都要调用 new,但是调用 new 会触发 operator
new(参见条款 M8),operator new (和 operator delete)的调用通常开销很大。因为它们将
导致底层操作系统的调用,系统调用的速度一般比进程内函数调用的速度慢。因此我们应该
尽量少使用系统调用。
使用 Over-eager evaluation 方法,其原因我们现在必须增加数组的尺寸以容纳索引 i,
那么根据位置相关性原则我们可能还会增加数组尺寸以在未来容纳比 i 大的其它索引。为了
避免为扩展而进行第二次(预料中的)内存分配,我们现在增加 DynArray 的尺寸比能使 i 合
法的尺寸要大,我们希望未来的扩展将被包含在我们提供的范围内。例如我们可以这样编写
DynArray::operator[]:
template<class T>
T& DynArray<T>::operator[](int index)
{
if (index < 0) throw an exception;
if (index > 当前最大的索引值) {
int diff = index – 当前最大的索引值;
调用 new 分配足够的额外内存,使得 index+diff 合法;
}
返回 index 位置上的数组元素;
}
bbs.theithome.com


这个函数每次分配的内存是数组扩展所需内存的两倍。如果我们再来看一下前面遇到的
那种情况,就会注意到 DynArray 分配了一次额外内存,即使它的逻辑尺寸被扩展了两次:
DynArray<double> a; // 仅仅 a[0]是合法的
a[22] = 3.5; // 调用 new 扩展
// a 的存储空间到索引 44
// a 的逻辑尺寸
// 变为 23
a[32] = 0; // a 的逻辑尺寸
// 被改变,允许使用 a[32],
// 但是没有调用 new
如果再次需要扩展 a,只要提供的新索引不大于 44,扩展的开销就不大。
贯穿本条款的是一个常见的主题,更快的速度经常会消耗更多的内存。跟踪运行时的最
小值、最大值和平均值,这需要额外的空间,但是能节省时间。Cache 运算结果需要更多的
内存,但是一旦需要被缓存的结果时就能减少需要重新生成的时间。Prefetch 需要空间放
置被 prefetch 的东西,但是它减少了访问它们所需的时间。自从有了计算机就有这样的描
述:你能以空间换时间。(然而不总是这样,使用大型对象意味着不适合虚拟内存或 cache
页。在一些罕见的情况下,建立大对象会降低软件的性能,因为分页操作的增加(详见操作
系统中内存管理 译者注),cache 命中率降低,或者两者都同时发生。如何发现你正遭遇这
样的问题呢?你必须 profile, profile, profile(参见条款 M16)。
在本条款中我提出的建议,即通过 over-eager 方法分摊预期计算的开销,例如 caching
和 prefething,这并不与我在条款 M17 中提出的有关 lazy evaluation 的建议相矛盾。当
你必须支持某些操作而不总需要其结果时,lazy evaluation 是在这种时候使用的用以提高
程序效率的技术。当你必须支持某些操作而其结果几乎总是被需要或被不止一次地需要时,
over-eager 是在这种时候使用的用以提高程序效率的一种技术。它们所产生的巨大的性能
提高证明在这方面花些精力是值得的。
6.4 Item M19:理解临时对象的来源
当程序员之间进行交谈时,他们经常把仅仅需要一小段时间的变量称为临时变量。例如
在下面这段 swap(交换)例程里:
template<class T>
void swap(T& object1, T& object2)
{
T temp = object1;
object1 = object2;
bbs.theithome.com


object2 = temp;
}
通常把 temp 叫做临时变量。不过就 C++而言,temp 根本不是临时变量,它只是一个函
数的局部对象。
在 C++中真正的临时对象是看不见的,它们不出现在你的源代码中。建立一个没有命名
的非堆(non-heap)对象会产生临时对象。这种未命名的对象通常在两种条件下产生:为了
使函数成功调用而进行隐式类型转换和函数返回对象时。理解如何和为什么建立这些临时对
象是很重要的,因为构造和释放它们的开销对于程序的性能来说有着不可忽视的影响。
首先考虑为使函数成功调用而建立临时对象这种情况。当传送给函数的对象类型与参数
类型不匹配时会产生这种情况。例如一个函数,它用来计算一个字符在字符串中出现的次数:
// 返回 ch 在 str 中出现的次数
size_t countChar(const string& str, char ch);
char buffer[MAX_STRING_LEN];
char c;
// 读入到一个字符和字符串中,用 setw
// 避免缓存溢出,当读取一个字符串时
cin >> c >> setw(MAX_STRING_LEN) >> buffer;
cout << "There are " << countChar(buffer, c)
<< " occurrences of the character " << c
<< " in " << buffer << endl;
看一下 countChar 的调用。第一个被传送的参数是字符数组,但是对应函数的正被绑定
的参数的类型是 const string&。仅当消除类型不匹配后,才能成功进行这个调用,你的编
译器很乐意替你消除它,方法是建立一个 string 类型的临时对象。通过以 buffer 做为参数
调用 string 的构造函数来初始化这个临时对象。countChar 的参数 str 被绑定在这个临时
的 string 对象上。当 countChar 返回时,临时对象自动释放。
这样的类型转换很方便(尽管很危险-参见条款 M5),但是从效率的观点来看,临时
string 对象的构造和释放是不必要的开销。通常有两个方法可以消除它。一种是重新设计
你的代码,不让发生这种类型转换。这种方法在条款 M5 中被研究和分析。另一种方法是通
过修改软件而不再需要类型转换,条款 M21 讲述了如何去做。
仅当通过传值(by value)方式传递对象或传递常量引用(reference-to-const)参数
时,才会发生这些类型转换。当传递一个非常量引用(reference-to-non-const)参数对象,
就不会发生。考虑一下这个函数:
void uppercasify(string& str); // 把 str 中所有的字符
// 改变成大写
bbs.theithome.com


在字符计数的例子里,能够成功传递 char 数组到 countChar 中,但是在这里试图用 char
数组调用 upeercasify 函数,则不会成功:
char subtleBookPlug[] = "Effective C++";
uppercasify(subtleBookPlug); // 错误!
没有为使调用成功而建立临时对象,为什么呢?
假设建立一个临时对象,那么临时对象将被传递到 upeercasify 中,其会修改这个临时
对象,把它的字符改成大写。但是对 subtleBookPlug 函数调用的真正参数没有任何影响;
仅仅改变了临时从 subtleBookPlug 生成的 string 对象。无疑这不是程序员所希望的。程序
员传递 subtleBookPlug 参数到 uppercasify 函数中,期望修改 subtleBookPlug 的值。当程
序员期望修改非临时对象时,对非常量引用(references-to-non-const)进行的隐式类型
转换却修改临时对象。这就是为什么 C++语言禁止为非常量引用(reference-to-non-const)
产生临时对象。这样非常量引用(reference-to-non-const)参数就不会遇到这种问题。
建立临时对象的第二种环境是函数返回对象时。例如 operator+必须返回一个对象,以
表示它的两个操作数的和(参见 Effective C++ 条款 23)。例如给定一个类型 Number,这
种类型的 operator+被这样声明:
const Number operator+(const Number& lhs,
const Number& rhs);
这个函数的返回值是临时的,因为它没有被命名;它只是函数的返回值。你必须为每次
调用 operator+构造和释放这个对象而付出代价。(有关为什么返回值是 const 的详细解释,
参见 Effective C++条款 21)
通常你不想付出这样的开销。对于这种函数,你可以切换到 operator=,而避免开销。
条款 M22 告诉我们进行这种转换的方法。不过对于大多数返回对象的函数来说,无法切换到
不同的函数,从而没有办法避免构造和释放返回值。至少在概念上没有办法避免它。然而概
念和现实之间又一个黑暗地带,叫做优化,有时你能以某种方法编写返回对象的函数,以允
许你的编译器优化临时对象。这些优化中,最常见和最有效的是返回值优化,这是条款 M20
的内容。
综上所述,临时对象是有开销的,所以你应该尽可能地去除它们,然而更重要的是训练
自己寻找可能建立临时对象的地方。在任何时候只要见到常量引用(reference-to-const)
参数,就存在建立临时对象而绑定在参数上的可能性。在任何时候只要见到函数返回对象,
就会有一个临时对象被建立(以后被释放)。学会寻找这些对象构造,你就能显著地增强透
过编译器表面动作而看到其背后开销的能力。
6.5 Item M20:协助完成返回值优化
一个返回对象的函数很难有较高的效率,因为传值返回会导致调用对象内的构造和析构
bbs.theithome.com


函数(参见条款 M19),这种调用是不能避免的。问题很简单:一个函数要么为了保证正确的
行为而返回对象要么就不这么做。如果它返回了对象,就没有办法摆脱被返回的对象。就说
到这。
考虑 rational(有理数)类的成员函数 operator*:
class Rational {
public:
Rational(int numerator = 0, int denominator = 1);
...
int numerator() const;
int denominator() const;
};
// 有关为什么返回值是 const 的解释,参见条款 M6,
const Rational operator*(const Rational& lhs,
const Rational& rhs);
甚至不用看 operator*的代码,我们就知道它肯定要返回一个对象,因为它返回的是两
个任意数字的计算结果。这些结果是任意的数字。operator*如何能避免建立新对象来容纳
它们的计算结果呢?这是不可能的,所以它必须得建立新对象并返回它。不过 C++程序员仍
然花费大量的精力寻找传说中的方法,能够去除传值返回的对象(参见 Effective C++ 条
款 23 和条款 31)。
有时人们会返回指针,从而导致这种滑稽的句法:
// 一种不合理的避免返回对象的方法
const Rational * operator*(const Rational& lhs,
const Rational& rhs);
Rational a = 10;
Rational b(1, 2);
Rational c = *(a * b); //你觉得这样很“正常”么?
它也引发出一个问题。调用者应该删除函数返回对象的指针么?答案通常是肯定的,并
且通常会导致资源泄漏。
其它一些开发人员会返回引用。这种方法能产生可接受的句法,
//一种危险的(和不正确的)方法,用来避免返回对象
const Rational& operator*(const Rational& lhs,
const Rational& rhs);
Rational a = 10;
bbs.theithome.com


Rational b(1, 2);
Rational c = a * b; // 看上去很合理
但是函数不能被正确地实现。一种尝试的方法是这样的:
// 另一种危险的方法 (和不正确的)方法,用来
// 避免返回对象
const Rational& operator*(const Rational& lhs,
const Rational& rhs)
{
Rational result(lhs.numerator() * rhs.numerator(),
lhs.denominator() * rhs.denominator());
return result;//WQ 加注 返回时,其指向的对象已经不存在了
}
这个函数返回的引用,其指向的对象已经不存在了。它返回的是一个指向局部对象
result 的引用,当 operator* 退出时 result 被自动释放。返回指向已被释放的对象的引用,
这样的引用绝对不能使用。
相信我:一些函数(operator*也在其中)必须要返回对象。这就是它们的运行方法。
不要与其对抗,你不会赢的。
你消除传值返回的对象的努力不会获得胜利。这是一场错误的战争。从效率的观点来看,
你不应该关心函数返回的对象,你仅仅应该关心对象的开销。你所应该关心的是把你的努力
引导到寻找减少返回对象的开销上来,而不是去消除对象本身(我们现在认识到这种寻求是
无用的)。如果没有与这些对象相关的开销,谁还会关心有多少对象被建立呢?
以某种方法返回对象,能让编译器消除临时对象的开销,这样编写函数通常是很普遍的。
这种技巧是返回 constructor argument 而不是直接返回对象,你可以这样做:
// 一种高效和正确的方法,用来实现
// 返回对象的函数
const Rational operator*(const Rational& lhs,
const Rational& rhs)
{
return Rational(lhs.numerator() * rhs.numerator(),
lhs.denominator() * rhs.denominator());
}
仔细观察被返回的表达式。它看上去好象正在调用 Rational 的构造函数,实际上确是
这样。你通过这个表达式建立一个临时的 Rational 对象,
Rational(lhs.numerator() * rhs.numerator(),
bbs.theithome.com


lhs.denominator() * rhs.denominator());
并且这是一个临时对象,函数把它拷贝给函数的返回值。
返回 constructor argument 而不出现局部对象,这种方法还会给你带来很多开销,因
为你仍旧必须为在函数内临时对象的构造和释放而付出代价,你仍旧必须为函数返回对象的
构造和释放而付出代价。但是你已经获得了好处。C++规则允许编译器优化不出现的临时对
象(temporary objects out of existence)。因此如果你在如下的环境里调用 operator*:
Rational a = 10;
Rational b(1, 2);
Rational c = a * b; // 在这里调用 operator*
编译器就会被允许消除在 operator*内的临时变量和 operator*返回的临时变量。它们
能在为目标 c 分配的内存里构造 return 表达式定义的对象。如果你的编译器这样去做,调
用 operator*的临时对象的开销就是零:没有建立临时对象。你的代价就是调用一个构造函
数――建立 c 时调用的构造函数。而且你不能比这做得更好了,因为 c 是命名对象,命名对
象不能被消除(参见条款 M22)。不过你还可以通过把函数声明为 inline 来消除 operator*
的调用开销(不过首先参见 Effective C++ 条款 33):
// the most efficient way to write a function returning
// an object
inline const Rational operator*(const Rational& lhs,
const Rational& rhs)
{
return Rational(lhs.numerator() * rhs.numerator(),
lhs.denominator() * rhs.denominator());
}
“好,不错”,你嘀咕地说,“优化,谁关心编译器能做什么?我想知道它们确实做了什
么,Does any of this nonsense work with real compilers?” It does。这种特殊的优
化――通过使用函数的 return 位置(或者在函数被调用位置用一个对象来替代)来消除局
部临时对象――是众所周知的和被普遍实现的。它甚至还有一个名字:返回值优化(return
value optimization)(WQ 加注:在《深度探索 C++物件模型》中有更多更详细的讲述,
它叫之为 named return value optimization。但注意,这种优化对普通的赋值运算无效,
编译器不能够用拷贝构造函数取代赋值运算动作,最终结论是:在确保语意正确的前题下没
有更好的优化可能了)。实际上这种优化有自己的名字本身就可以解释为什么它被广泛地使
用。寻找 C++编译器的程序员会问销售商编译器是否有返回值优化功能。如果一个销售商说
有而另一个问“那是什么东西?”,第一个销售商就会有明显的竞争优势。啊,资本主义,
有时你实在应该去爱它。(谨代表作者观点,译者坚决拥护四项基本原则 译者注 :-))
bbs.theithome.com


附:
文中最后一段黑体部分如何翻译,我有些拿不准,请高手告知,为了容易理解,我在此
附上此文最后一段的英文原文:
"Yeah, yeah," you mutter, "optimization, schmoptimization. Who cares what compilers
can do? I want to know what they do do. Does any of this nonsense work with real
compilers?" It does. This particular optimization — eliminating a local temporary
by using a function's return location (and possibly replacing that with an object
at the function's call site) — is both well-known and commonly implemented. It even
has a name: the return value optimization. In fact, the existence of a name for this
optimization may explain why it's so
widely available. Programmers looking for a C++ compiler can ask vendors whether
the return value optimization is implemented. If one vendor says yes and another
says "The what?," the first vendor has a notable competitive advantage. Ah,
capitalism. Sometimes you just gotta love it.
6.6 Item M21:通过重载避免隐式类型转换
以下是一段代码,如果没有什么不寻常的原因,实在看不出什么东西:
class UPInt { // unlimited precision
public: // integers 类
UPInt();
UPInt(int value);
...
};
//有关为什么返回值是 const 的解释,参见 Effective C++ 条款 21
const UPInt operator+(const UPInt& lhs, const UPInt& rhs);
UPInt upi1, upi2;
...
UPInt upi3 = upi1 + upi2;
这里还看不出什么令人惊讶的东西。upi1 和 upi2 都是 UPInt 对象,所以它们之间相加
就会调用 UPInts 的 operator 函数。
现在考虑下面这些语句:
upi3 = upi1 + 10;
upi3 = 10 + upi2;
这些语句也能够成功运行。方法是通过建立临时对象把整形数 10 转换为 UPInts(参见
bbs.theithome.com


条款 M19)。
让编译器完成这种类型转换是确实是很方便,但是建立临时对象进行类型转换工作是有
开销的,而我们不想承担这种开销。就象大多数人只想从政府那里受益而不想为此付出一样,
大多数 C++程序员希望进行没有临时对象开销的隐式类型转换。但是在计算领域里发生不了
赤字现象,我们如何能这么做呢?
让我们回退一步,认识到我们的目的不是真的要进行类型转换,而是用 UPint 和 int
做为参数调用 operator+。隐式类型转换只是用来达到目的的手段,但是我们不要混淆手段
与目的。还有一种方法可以成功进行 operator+的混合类型调用,它将消除隐式类型转换的
需要。如果我们想要把 UPInt 和 int 对象相加,通过声明如下几个函数达到这个目的,每一
个函数有不同的参数类型集。
const UPInt operator+(const UPInt& lhs, // add UPInt
const UPInt& rhs); // and UPInt
const UPInt operator+(const UPInt& lhs, // add UPInt
int rhs); // and int
const UPInt operator+(int lhs, // add int and
const UPInt& rhs); // UPInt
UPInt upi1, upi2;
...
UPInt upi3 = upi1 + upi2; // 正确,没有由 upi1 或 upi2
// 生成的临时对象
upi3 = upi1 + 10; // 正确, 没有由 upi1 or 10
// 生成的临时对象
upi3 = 10 + upi2; //正确, 没有由 10 or upi2
//生成的临时对象。
一旦你开始用函数重载来消除类型转换,你就有可能这样声明函数,把自己陷入危险之
中:
const UPInt operator+(int lhs, int rhs); // 错误!
这个想法是合情合理的。对于 UPInt 和 int 类型,我们想要用所有可能的组合来重载
operator 函数。上面只给出了三种重载函数,唯一漏掉的是带有两个 int 参数的 operator,
所以我们想把它加上。
有道理么?在 C++中有一条规则是每一个重载的 operator 必须带有一个用户定义类型
(user-defined type)的参数。int 不是用户定义类型,所以我们不能重载 operator 成为
仅带有此[int]类型参数的函数。(如果没有这条规则,程序员将能改变预定义的操作,这样
做肯定把程序引入混乱的境地。比如企图重载上述的 operator,将会改变 int 类型相加的
bbs.theithome.com


含义。)
利用重载避免临时对象的方法不只是用在 operator 函数上。比如在大多数程序中,你
想允许在所有能使用 string 对象的地方,也一样可以使用 char*,反之亦然。同样如果你
正在使用 numerical(数字)类,例如 complex(参见条款 M35),你想让 int 和 double 这
样的类型可以使用在 numerical 对象的任何地方。因此任何带有 string、char*、complex
参数的函数可以采用重载方式来消除类型转换。
不过,必须谨记 80-20 规则(参见条款 M16)。没有必要实现大量的重载函数,除非你
有理由确信程序使用重载函数以后其整体效率会有显著的提高。
6.7 Item M22:考虑用运算符的赋值形式(op=)取代其单独形式(op)
大多数程序员认为如果他们能这样写代码:
x = x + y; x = x - y;
那他们也能这样写:
x += y; x -= y;
如果 x 和 y 是用户定义的类型(user-defined type),就不能确保这样。就 C++来说,
operator+、operator=和 operator+=之间没有任何关系,因此如果你想让这三个 operator
同时存在并具有你所期望的关系,就必须自己实现它们。同理,operator -, *, /, 等等也
一样。
确保 operator 的赋值形式(assignment version)(例如 operator+=)与一个 operator
的单独形式(stand-alone)(例如 operator+ )之间存在正常的关系,一种好方法是后者(指
operator+ 译者注)根据前者(指 operator+= 译者注)来实现(参见条款 M6)。这很容
易:
class Rational {
public:
...
Rational& operator+=(const Rational& rhs);
Rational& operator-=(const Rational& rhs);
};
// operator+ 根据 operator+=实现;
//有关为什么返回值是 const 的解释,
//参见 Effective C++条款 21 和 109 页 的有关实现的警告
const Rational operator+(const Rational& lhs,
const Rational& rhs)
bbs.theithome.com


{
return Rational(lhs) += rhs;
}
// operator- 根据 operator -= 来实现
const Rational operator-(const Rational& lhs,
const Rational& rhs)
{
return Rational(lhs) -= rhs;
}
在这个例子里,从零开始实现 operator+=和-=,而 operator+ 和 operator- 则是通过
调用前述的函数来提供自己的功能。使用这种设计方法,只用维护 operator 的赋值形式就
行了。而且如果假设 operator 赋值形式在类的 public 接口里,这就不用让 operator 的单
独形式成为类的友元(参见 Effective C++ 条款 19)。
如果你不介意把所有的 operator 的单独形式放在全局域里,那就可以使用模板来替代
单独形式的函数的编写:
template<class T>
const T operator+(const T& lhs, const T& rhs)
{
return T(lhs) += rhs; // 参见下面的讨论
}
template<class T>
const T operator-(const T& lhs, const T& rhs)
{
return T(lhs) -= rhs; // 参见下面的讨论
}
...
使用这些模板,只要为 operator 赋值形式定义某种类型,一旦需要,其对应的 operator
单独形式就会被自动生成。
这样编写确实不错,但是到目前为止,我们还没有考虑效率问题,效率毕竟是本章的主
题。在这里值得指出的是三个效率方面的问题。第一、总的来说 operator 的赋值形式比其
单独形式效率更高,因为单独形式要返回一个新对象,从而在临时对象的构造和释放上有一
些开销(参见条款 M19 和条款 M20,还有 Effective C++条款 23)。operator 的赋值形式把
结果写到左边的参数里,因此不需要生成临时对象来容纳 operator 的返回值。
第二、提供 operator 的赋值形式的同时也要提供其标准形式,允许类的客户端在便利
bbs.theithome.com


与效率上做出折衷选择。也就是说,客户端可以决定是这样编写:
Rational a, b, c, d, result;
...
result = a + b + c + d; // 可能用了 3 个临时对象
// 每个 operator+ 调用使用 1 个
还是这样编写:
result = a; //不用临时对象
result += b; //不用临时对象
result += c; //不用临时对象
result += d; //不用临时对象
前者比较容易编写、debug 和维护,并且在 80%的时间里它的性能是可以被接受的(参
见条款 M16)。后者具有更高的效率,估计这对于汇编语言程序员来说会更直观一些。通过
提供两种方案,你可以让客户端开发人员用更容易阅读的单独形式的 operator 来开发和
debug 代码,同时保留用效率更高的 operator 赋值形式替代单独形式的权力。而且根据
operator 的赋值形式实现其单独形式,这样你能确保当客户端从一种形式切换到另一种形
式时,操作的语义可以保持不变。
最后一点,涉及到 operator 单独形式的实现。再看看 operator+ 的实现:
template<class T>
const T operator+(const T& lhs, const T& rhs)
{ return T(lhs) += rhs; }
表达式 T(lhs)调用了 T 的拷贝构造函数。它建立一个临时对象,其值与 lhs 一样。这
个临时对象用来与 rhs 一起调用 operator+= ,操作的结果被从 operator+返回。这个代码
好像不用写得这么隐密。这样写不是更好么?
template<class T>
const T operator+(const T& lhs, const T& rhs)
{
T result(lhs); // 拷贝 lhs 到 result 中
return result += rhs; // rhs 与它相加并返回结果
}
这个模板几乎与前面的程序相同,但是它们之间还是存在重要的差别。第二个模板包含
一个命名对象,result。这个命名对象意味着不能在 operator+ 里使用返回值优化(参见
条款 M20)。第一种实现方法总可以使用返回值优化,所以编译器为其生成优化代码的可能
就会更大。
广告中的事实迫使我指出表达式:
bbs.theithome.com


return T(lhs) += rhs;
比大多数编译器希望进行的返回值优化更复杂。上面第一个函数实现也有这样的临时对
象开销,就象你为使用命名对象 result 而耗费的开销一样。然而未命名的对象在历史上比
命名对象更容易清除,因此当我们面对在命名对象和临时对象间进行选择时,用临时对象更
好一些。它使你耗费的开销不会比命名的对象还多,特别是使用老编译器时,它的耗费会更
少。
这里谈论的命名对象、未命名对象和编译优化是很有趣的,但是主要的一点是 operator
的赋值形式(operator+=)比单独形式(operator+)效率更高。做为一个库程序设计者,应
该两者都提供,做为一个应用程序的开发者,在优先考虑性能时你应该考虑考虑用 operator
赋值形式代替单独形式。
6.8 Item M23:考虑变更程序库
程序库的设计就是一个折衷的过程。理想的程序库应该是短小的、快速的、强大的、灵
活的、可扩展的、直观的、普遍适用的、具有良好的支持、没有使用约束、没有错误的。这
也是不存在的。为尺寸和速度而进行优化的程序库一般不能被移植。具有大量功能的的程序
库不会具有直观性。没有错误的程序库在使用范围上会有限制。真实的世界里,你不能拥有
每一件东西,总得有付出。
不同的设计者给这些条件赋予了不同的优先级。他们从而在设计中牺牲了不同的东西。
因此一般两个提供相同功能的程序库却有着完全不同的性能特征。
例如,考虑 iostream 和 stdio 程序库,对于 C++程序员来说两者都是可以使用的。
iostream 程序库与 C 中的 stdio 相比有几个优点(参见 Effective C++)。例如它是类型安
全的(type-safe),它是可扩展的。然而在效率方面,iostream 程序库总是不如 stdio,因
为 stdio 产生的执行文件与 iostream 产生的执行文件相比尺寸小而且执行速度快。
首先考虑执行速度的问题。要想掌握 iostream 和 stdio 之间的性能差别,一种方法就
是用这两个程序库来运行 benchmark 程序。不过你必须记住 benchmark 也会撒谎。不仅很难
拿出一组数据能够代表程序或程序库的典型用法,而且就算拿出来也是没用,除非有可靠的
方法判断出你或你的客户就是典型的代表。不过 benchmark 还是能在同一个问题的不同解决
方法间的比较上提供一些信息,所以尽管完全依靠 benchmark 是愚蠢的,但是忽略它们也是
愚蠢的。
让我们测试一个简单的 benchmark 程序,只测试最基本的 I/O 功能。这个程序从标准输
入读取 30000 个浮点数,然后把它们以固定的格式写到标准输出里。编译时预处理符号 STDIO
决定是使用 stdio 还是 iostream。如果定义了这个符号,就是用 stdio,否则就使用 iostream
程序库。
#ifdef STDIO
bbs.theithome.com


#include <stdio.h>
#else
#include <iostream>
#include <iomanip>
using namespace std;
#endif
const int VALUES = 30000; // # of values to read/write
int main()
{
double d;
for (int n = 1; n <= VALUES; ++n) {
#ifdef STDIO
scanf("%lf", &d);
printf("%10.5f", d);
#else
cin >> d;
cout << setw(10) // 设定 field 宽度
<< setprecision(5) // 设置小数位置
<< setiosflags(ios::showpoint) // keep trailing 0s
<< setiosflags(ios::fixed) // 使用这些设置
<< d;
#endif
if (n % 5 == 0) {
#ifdef STDIO
printf("\n");
#else
cout << '\n';
#endif
}
}
return 0;
}
当把正整数的自然对数传给这个程序,它会这样输出:
0.00000 0.69315 1.09861 1.38629 1.60944
bbs.theithome.com