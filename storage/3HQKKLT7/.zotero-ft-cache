The VTK User’s Guide
11th Edition
Contributors:
Lisa S. Avila, Kitware Utkarsh Ayachit, Kitware Sébastien Barré, Kitware Jeff Baumes, Kitware Francois Bertel, Kitware Rusty Blue, Kitware David Cole, Kitware David DeMarle, Kitware Berk Geveci, Kitware William A. Hoffman, Kitware Brad King, Kitware Karthik Krishnan, Kitware C. Charles Law, Kitware Kenneth M. Martin, Kitware William McLendon, Sandia National Laboratories Philippe Pebay, Sandia National Laboratories Niki Russell, Kitware William J. Schroeder, Kitware Timothy Shead, Sandia National Laboratories Jason Shepherd, Sandia National Laboratories Andrew Wilson, Sandia National Laboratories Brian Wylie, Sandia National Laboratories




The VTK User’s Guide
11th Edition
Published by Kitware, Inc.
Join the VTK Community at http://www.vtk.org.
Commercial support and consulting is available for this software from Kitware, Inc. Please visit http://www.kitware.com for more information or send email to kitware@kitware.com.


© 2010 Kitware, Inc.
http://www.kitware.com
All rights reserved. No part of this book may be reproduced, in any form or by any means, without the express written permission of the publisher.
The publisher Kitware, Inc. offers discounts on this book when ordered in bulk quantities. Kitware also publishes a companion text, The Visualization Toolkit An Object-Oriented Approach to 3D Graphics by Schroeder, Martin and Lorensen, and provides commercial training, support and consulting for VTK. For more information contact Kitware, Inc. at sales@kitware.com.
All product names mentioned herein are the trademarks of their respective owners.
Printed in Columbia. ISBN 978-1-930934-23-8


Contents
Part I An Introduction to VTK
Chapter 1 Welcome 3 1.1 User Guide Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4 1.2 How to Learn VTK. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4 1.3 Software Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4 Obtaining The Software. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5 Directory Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5 Documentation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6 Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6 1.4 Additional Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6
Chapter 2 Installation 9 2.1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9 2.2 CMake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10 2.3 Installing VTK on Windows XP, Vista or later . . . . . . . . . . . . . . . . . . . .10 Binary Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .11 Source Code Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12 2.4 Installing VTK on Unix Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14 Source Code Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .15 CMake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .15 Compiling the Source Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .17 Building VTK On Multiple Platforms. . . . . . . . . . . . . . . . . . . . . . . .17 Installing VTK. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .17
Chapter 3 System Overview 19 3.1 System Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .19 Low-Level Object Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .20 The Rendering Engine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21 The Visualization Pipeline. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25 3.2 Create An Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .29 User Methods, Observers, and Commands . . . . . . . . . . . . . . . . . . . .29 Tcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .30 C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .30 Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .36 Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .36 3.3 Conversion Between Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .37
Part II Learn VTK By Example
Chapter 4 The Basics 41 4.1 Creating Simple Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .42 Procedural Source Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .42 Reader Source Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44 4.2 Using VTK Interactors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .45


vi
vtkRenderWindowInteractor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 Interactor Styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 4.3 Filtering Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 4.4 Controlling The Camera . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 Instantiating The Camera . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 Simple Manipulation Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 Controlling The View Direction. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 Perspective Versus Orthogonal Views . . . . . . . . . . . . . . . . . . . . . . . 50 Saving/Restoring Camera State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 4.5 Controlling Lights . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 Positional Lights. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 4.6 Controlling 3D Props . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 Specifying the Position of a vtkProp3D . . . . . . . . . . . . . . . . . . . . . . 52 Actors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 Level-Of-Detail Actors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55 Assemblies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 Volumes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 vtkLODProp3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 4.7 Using Texture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 4.8 Picking. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 vtkAssemblyPath . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 4.9 vtkCoordinate and Coordinate Systems . . . . . . . . . . . . . . . . . . . . . . . . . 62 4.10 Controlling vtkActor2D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 4.11 Text Annotation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 2DText Annotation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 3D Text Annotation and vtkFollower . . . . . . . . . . . . . . . . . . . . . . . 65 4.12 Special Plotting Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 Scalar Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 X-Y Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 Bounding Box Axes (vtkCubeAxesActor2D) . . . . . . . . . . . . . . . . . 68 Labeling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 4.13 Transforming Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 Advanced Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 3D Widgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 4.14 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 Per-primitive type antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 Multisampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 4.15 Translucent polygonal geometry. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 4.16 Animation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 Animation Scene (vtkAnimationScene). . . . . . . . . . . . . . . . . . . . . . 83
Chapter 5 Visualization Techniques 89 5.1 Visualizing vtkDataSet (and Subclasses) . . . . . . . . . . . . . . . . . . . . . . . . 89 Working With Data Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 Color Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 Contouring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 Glyphing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 Streamlines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 Stream Surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 Cutting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98


vii
Merging Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .99 Appending Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .100 Probing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 Color An Isosurface With Another Scalar . . . . . . . . . . . . . . . . . . .102 Extract Subset of Cells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .103 Extract Cells as Polygonal Data . . . . . . . . . . . . . . . . . . . . . . . . . . .104 5.2 Visualizing Polygonal Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .105 Manually Create vtkPolyData . . . . . . . . . . . . . . . . . . . . . . . . . . . . .106 Generate Surface Normals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .107 Decimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .107 Smooth Mesh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .109 Clip Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .110 Generate Texture Coordinates . . . . . . . . . . . . . . . . . . . . . . . . . . . . .111 5.3 Visualizing Structured Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .112 Manually Create vtkStructuredGrid . . . . . . . . . . . . . . . . . . . . . . . .112 Extract Computational Plane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .112 Subsampling Structured Grids. . . . . . . . . . . . . . . . . . . . . . . . . . . . .113 5.4 Visualizing Rectilinear Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .114 Manually Create vtkRectilinearGrid . . . . . . . . . . . . . . . . . . . . . . . .114 Extract Computational Plane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .114 5.5 Visualizing Unstructured Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .115 Manually Create vtkUnstructuredGrid . . . . . . . . . . . . . . . . . . . . . .115 Extract Portions of the Mesh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .115 Contour Unstructured Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .117
Chapter 6 Image Processing & Visualization 119 6.1 Manually Creating vtkImageData . . . . . . . . . . . . . . . . . . . . . . . . . . . . .120 6.2 Subsampling Image Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .121 6.3 Warp Based On Scalar Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .122 6.4 Image Display. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .123 Image Viewer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .123 Image Actor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .124 vtkImagePlaneWidget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .125 6.5 Image Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .125 ImageCanvasSource2D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .126 ImageEllipsoidSource . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .126 ImageGaussianSource . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .127 ImageGridSource . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .127 ImageNoiseSource. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .127 ImageSinusoidSource . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .128 6.6 Image Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .128 Convert Scalar Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .128 Change Spacing, Origin, or Extent . . . . . . . . . . . . . . . . . . . . . . . . .129 Append Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .129 Map Image to Color. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .131 Image Luminance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .132 Histogram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .132 Image Logic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .132 Gradient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .133 Gaussian Smoothing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .133 Image Flip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .134


viii
Image Permute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 Image Mathematics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 Image Reslice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 Iterating through an image . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
Chapter 7 Volume Rendering 139 7.1 Historical Note on Supported Data Types. . . . . . . . . . . . . . . . . . . . . . . 140 7.2 A Simple Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 7.3 Why Multiple Volume Rendering Techniques? . . . . . . . . . . . . . . . . . . 142 7.4 Creating a vtkVolume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 7.5 Using vtkPiecewiseFunction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 7.6 Using vtkColorTransferFunction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 7.7 Controlling Color / Opacity with a vtkVolumeProperty. . . . . . . . . . . . 145 7.8 Controlling Shading with a vtkVolumeProperty. . . . . . . . . . . . . . . . . . 147 7.9 Creating a Volume Mapper . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 7.10 Cropping a Volume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 7.11 Clipping a Volume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 7.12 Controlling the Normal Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 7.13 Volumetric Ray Casting for vtkImageData. . . . . . . . . . . . . . . . . . . . . . 153 7.14 Fixed Point Ray Casting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156 7.15 2D Texture Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156 7.16 3D Texture Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156 7.17 Volumetric Ray Casting for vtkUnstructuredGrid . . . . . . . . . . . . . . . . 157 7.18 ZSweep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 7.19 Projected Tetrahedra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 7.20 Speed vs. Accuracy Trade-offs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 7.21 Using a vtkLODProp3D to Improve Performance . . . . . . . . . . . . . . . . 161
Chapter 8 Information Visualization 163 8.1 Exploring Relationships in Tabular Data . . . . . . . . . . . . . . . . . . . . . . . 164 Converting a Table to a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 Converting a Table to a Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 8.2 Graph Visualization Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170 Vertex Layout. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 Edge Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 Converting Layouts to Geometry . . . . . . . . . . . . . . . . . . . . . . . . . . 173 Area Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 8.3 Views and Representations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 Selections in Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179 8.4 Graph Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 Boost Graph Library Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . 182 Creating Graph Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 The Parallel Boost Graph Library . . . . . . . . . . . . . . . . . . . . . . . . . 186 Multithreaded Graph Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186 8.5 Databases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Connecting to a Database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Executing Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188 Queries and Threads. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 Reading Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 Writing Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190 Table Schemata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190


ix
8.6 Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .192 Specifying columns of interest . . . . . . . . . . . . . . . . . . . . . . . . . . . .193 Phases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .193 Univariate Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .194 Bivariate statistics:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .195 Multivariate statistics: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .195 Using statistics algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .196 Parallel Statistics Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . .197 8.7 Processing Multi-Dimensional Data. . . . . . . . . . . . . . . . . . . . . . . . . . . .198 Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .199 Using multi-dimensional arrays . . . . . . . . . . . . . . . . . . . . . . . . . . .201 Performance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .203 Populating Dense Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .203 Populating Sparse Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .203 Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .204 Array Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .205 Array Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .205 Array Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .206
Chapter 9 Geospatial Visualization 207 9.1 Geographic Views and Representations. . . . . . . . . . . . . . . . . . . . . . . . .207 9.2 Generating Hierarchies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .210 9.3 Hierarchical Data Sources—On-demand resolution . . . . . . . . . . . . . . .210 9.4 Terrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .211 9.5 Cartographic Projections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .211
Chapter 10 Building Models 213 10.1 Implicit Modeling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .213 Creating An Implicit Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .213 Sampling Implicit Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215 10.2 Extrusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .217 10.3 Constructing Surfaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .218 Delaunay Triangulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .218 Gaussian Splatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .222 Surfaces from Unorganized Points . . . . . . . . . . . . . . . . . . . . . . . . .224
Chapter 11 Time Varying Data 227 11.1 Introduction to temporal support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .227 11.2 VTK's implementation of time support . . . . . . . . . . . . . . . . . . . . . . . . .228 TIME_RANGE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .228 TIME_STEPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .228 UPDATE_TIME_STEPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .229 DATA_TIME_STEPS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .229 CONTINUE_EXECUTING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .229 Using time support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .230
Chapter 12 Reading and Writing Data 239 12.1 Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .239 Data Object Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .240


x
Data Set Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240 Image and Volume Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240 Rectilinear Grid Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 Structured Grid Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 Polygonal Data Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 Unstructured Grid Readers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 Graph Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 Table Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 Composite Data Readers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243 12.2 Writers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243 Data Object Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244 Data Set Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244 Image and Volume Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244 Rectilinear Grid Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244 Structured Grid Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244 Polygonal Data Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244 Unstructured Grid Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 Graph Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 Table Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 Composite Data Writers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 12.3 Importers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 12.4 Exporters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246 12.5 Creating Hardcopy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246 Saving Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247 Saving Large (High-Resolution) Images . . . . . . . . . . . . . . . . . . . . 247 12.6 Creating Movie Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248 12.7 Working With Field Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
Chapter 13 Interaction, Widgets and Selections 255 13.1 Interactors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255 vtkRenderWindowInteractor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255 Interactor Styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256 vtkInteractorStyle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256 Adding vtkRenderWindowInteractor Observers . . . . . . . . . . . . . . 257 13.2 Widgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258 Reconfigurable Bindings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260 Cursor Management and Highlighting . . . . . . . . . . . . . . . . . . . . . . 261 Widget Hierarchies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261 Timers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261 Priorities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261 Point Placers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262 13.3 A tour of the widgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262 Measurement Widgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262 Widgets for probing or manipulating underlying data . . . . . . . . . . 265 Annotation widgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272 Segmentation / Registration widgets . . . . . . . . . . . . . . . . . . . . . . . 276 Miscellaneous. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284 An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289 13.4 Selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291 13.5 Types of selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292 Index selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292


xi
Pedigree ID selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .292 Global ID selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .292 Frustum selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .292 Value selections. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .293 Threshold selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .293 Location selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .293 Block selections. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .293
Part III VTK Developer’s Guide
Chapter 14 Contributing Code 297 14.1 Coding Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .297 Conditions on Contributing Code To VTK . . . . . . . . . . . . . . . . . . .297 Coding Style . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .299 How To Contribute Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .299 14.2 Standard Methods: Creating and Deleting Objects . . . . . . . . . . . . . . . .300 14.3 Copying Objects and Protected Methods . . . . . . . . . . . . . . . . . . . . . . . .302 14.4 Using STL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .303 14.5 Managing Include Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .304 14.6 Writing A VTK Class: An Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .305 Find A Similar Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .305 Identify A Superclass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .305 Single Class Per .h File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .306 Required Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .306 Document Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .306 Use SetGet Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .307 Add Class To VTK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .307 14.7 Object Factories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .307 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .308 How To Write A Factory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .308 How To Install A Factory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .309 Example Factory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .310 14.8 Kitware’s Quality Software Process. . . . . . . . . . . . . . . . . . . . . . . . . . . .312 CVS Source Code Repository . . . . . . . . . . . . . . . . . . . . . . . . . . . . .313 CDash Regression Testing System . . . . . . . . . . . . . . . . . . . . . . . . .313 Working The Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .314 The Effectiveness of the Process . . . . . . . . . . . . . . . . . . . . . . . . . . .315
Chapter 15 Managing Pipeline Execution 317 15.1 Information Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .318 15.2 Pipeline Execution Models. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .319 15.3 Pipeline Information Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .320 15.4 Interface of Information Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .321 15.5 Standard Executives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .323 vtkDemandDrivenPipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .323 vtkStreamingDemandDrivenPipeline . . . . . . . . . . . . . . . . . . . . . . .325 vtkCompositeDataPipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .326 15.6 Choosing the Default Executive. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .326


xii
Chapter 16 Interfacing To VTK Data Objects 327 16.1 Data Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327 vtkDataArray Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328 16.2 Datasets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333 vtkDataSet Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335 vtkDataSet Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338 16.3 Image Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339 vtkImageData Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339 vtkImageData Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340 16.4 Rectilinear Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341 vtkRectilinearGrid Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342 16.5 Point Sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343 vtkPointSet Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343 vtkPointSet Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343 16.6 Structured Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344 vtkStructuredGrid Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344 16.7 Polygonal Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345 vtkPolyData Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346 16.8 Unstructured Grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350 vtkUnstructuredGrid Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350 16.9 Cells. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352 vtkCell Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352 16.10 Supporting Objects for Data Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 vtkPoints Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 vtkCellArray Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357 vtkCellTypes Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359 vtkCellLinks Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360 16.11 Field and Attribute Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362 vtkFieldData Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362 vtkDataSetAttributes Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 16.12 Selections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369 vtkSelection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369 vtkSelectionNode Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370 vtkSelectionNode Property Methods . . . . . . . . . . . . . . . . . . . . . . . 370 16.13 Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 vtkGraph Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372 vtkDirectedGraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375 vtkUndirectedGraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375 vtkMutableDirectedGraph and vtkMutableUndirectedGraph Methods 375 vtkDirectedAcyclicGraph. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377 vtkTree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377 16.14 Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377 vtkTable Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377 16.15 Multi-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379 vtkArray Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379 vtkTypedArray Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380 vtkDenseArray Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381 vtkSparseArray Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382 vtkArrayData Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383


xiii
Chapter 17 How To Write an Algorithm for VTK 385 17.1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .385 The Pipeline Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .385 The User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .388 Fulfilling Pipeline Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .389 17.2 Laws of VTK Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .390 Never Modify Input Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .390 Reference Count Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .390 Use Debug Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .391 Reclaim/Delete Allocated Memory . . . . . . . . . . . . . . . . . . . . . . . . .391 Compute Modified Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .391 Use ProgressEvent and AbortExecute . . . . . . . . . . . . . . . . . . . . . .392 Implement PrintSelf() Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . .394 Get Input/Output Data From Pipeline Information . . . . . . . . . . . . .394 17.3 Example Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .394 A Graphics Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .394 A Simple Imaging Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .399 A Threaded Imaging Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .401 A Simple Reader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .406 A Streaming Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .409 An Abstract Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .412 Composite Dataset Aware Filters . . . . . . . . . . . . . . . . . . . . . . . . . .416 Programmable Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .419
Chapter 18 Integrating With The Windowing System 421 18.1 vtkRenderWindow Interaction Style . . . . . . . . . . . . . . . . . . . . . . . . . . .421 18.2 General Guidelines for GUI Interaction . . . . . . . . . . . . . . . . . . . . . . . . .423 18.3 X Windows, Xt, and Motif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .427 18.4 Microsoft Windows / Microsoft Foundation Classes (MFC). . . . . . . . .432 18.5 Tcl/Tk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .433 18.6 Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .434 18.7 Using VTK with Qt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .434
Chapter 19 Coding Resources 437 19.1 Object Diagrams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .437 Foundation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .437 Cells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .437 Datasets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .438 Topology and Attribute Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .439 Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .439 Sources and Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .439 Mappers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .439 Graphics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .441 Volume Rendering. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .441 Imaging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .442 OpenGL Renderer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .442 Picking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .442 Transformation Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .443 Widgets and Interaction Style . . . . . . . . . . . . . . . . . . . . . . . . . . . . .443 19.2 Summary Of Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .444


xiv
Source Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 444 Imaging Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450 Visualization Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455 Mapper Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463 Actor (Prop) Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464 Views and Informatics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465 19.3 VTK File Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469 Simple Legacy Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470 XML File Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482


Part I
An Introduction to VTK




Chapter 1
Welcome 1
W
elcome to the Visualization Toolkit (VTK) User’s Guide. VTK is an open-source, object-oriented software system for computer graphics, visualization, and image processing. Although it is large and complex, VTK is designed to be easy to use once you learn about its basic object-oriented design and implementation methodology. The purpose of this User’s Guide is to help you learn this methodology, plus familiarize you with a variety of important VTK classes.
If you are a past reader of this guide, you’ll note that we are now distinguishing updates of this book based on an edition number rather than a version number for VTK. This is the 11th edition of the VTK User’s Guide. The User’s Guide has been in publication for more than eleven years and this edition was published over sixteen years after the start of VTK. Although a version of VTK shortly before the 5.6 release was used when writing this edition, we are fairly confident in saying that nearly all the material covered here will be valid through many future releases. Backwards compatability is taken seriously in VTK, and although new features may be added that are not documented here, it is very rare for an existing feature to change.
VTK is a large system. As a result, it is not possible to completely document all VTK objects and their methods in this guide. Instead, this guide will introduce you to important system concepts and lead you up the learning curve as fast and efficiently as possible. Once you master the basics, we suggest that you take advantage of the many resources available including the Doxygen documentation pages (“Documentation” on page 6) and the community of VTK users (see “Additional Resources” on page 6).
The Visualization Toolkit is an open-source software system. What this means is that dozens and perhaps hundreds of generous developers and users like you have contributed to the code base. If you find VTK a useful tool, we encourage you to contribute bug fixes, algorithms, ideas, and/or applications back to the community. (See “How To Contribute Code” on page 299 for more information.) You can also contract with commercial firms such as Kitware to develop and add new features and tools.


4 Welcome
1.1 User Guide Organization
This software guide is divided into three parts, each of which is further divided into several standalone chapters. Part I is a general introduction to VTK, including—in the next chapter—a description of how to install the Visualization Toolkit on your computer. This includes installing pre-compiled libraries and executables or compiling the software from the source code. Part I also introduces basic system concepts including an overview of the system architecture as well as a description of building applications in the C++, Tcl, Java, and Python programming languages. In some ways Part II is the heart of User’s Guide, since dozens of examples are used to illustrate important system features. Part III is for the advanced VTK user. If you are a developer, Part III explains how to create your own classes, extend the system, and interface to various windowing and GUI systems. Chapter 19 contains simplified object diagrams that provide an overview of the relationship of VTK objects, a summary list of filters, and a description of VTK file formats for reading and writing your own data. Finally, the index is a handy tool for random access into the User’s Guide.
1.2 How to Learn VTK
There are two broad categories of VTK users. First are class developers, who create classes in C++. Second, application developers use the C++ class library to build turn-key applications. Class developers must be proficient in C++, and if you are extending or modifying VTK, you must also be familiar with VTK’s internal structures and design (material covered in Part III). Application developers may or may not use C++, since the compiled C++ class library has been “wrapped” with the interpreted languages Tcl, Python, Visual Basic, and Java. However, as an application developer you must know something about the external interface to the VTK objects, and the relationships between them.
The key to learning how to use VTK is to become familiar with its palette of objects and the ways of combining them. If you are a new Visualization Toolkit user, begin by installing the software. If you are a class developer, you’ll want to download the source code and then compile it. Application developers may only need the precompiled binaries and executables. We recommend that you learn the system by studying the examples (if you are an application developer) and then studying the source code (if you are a class developer). Start by reading Chapter 3, which provides an overview of some of the key concepts in the system, and then review the examples in Part II. You may also wish to run the dozens of examples distributed with the source code found in the directory VTK/Examples. (Please see the file VTK/Examples/README.txt for a description of the examples contained in the various subdirectories.) There are also several hundred tests found in the source distribution such as
those found in VTK/Graphics/Testing/Tcl and VTK/Graphics/Testing/Cxx, most of which are undocumented testing scripts. However, they may be useful to see how classes are used together in VTK.
1.3 Software Organization
The following sections describe the directory contents, summarize the software functionality in each directory, and locate the documentation and data.


1.3 Software Organization 5
Obtaining The Software
There are two different ways to access the VTK source code .
1. from releases available on the VTK Web site http://www.vtk.org; and
2. from direct access to the CVS source code repository (instructions found at www.vtk.org).
This user’s guide assumes that you are working with an official VTK release. This book was written against VTK as of September 2009. When we wrote this book we were considering both VTK 5.4 and features we were expecting in the 5.6 release. Please note that topics covered in this text will be valid for future releases of VTK as well. Also note that in the past, major releases of VTK were denoted by a major number change (i.e. VTK 4.4 to VTK 5.0) which also indicated that there was some break in backwards compatibility somewhere in the toolkit. However, with more frequent releases we will be faced with releasing a VTK 5.10 (confusing since alpha-numerically that comes before 5.2, but chronologically it comes after 5.8) or releasing VTK 6.0 with no change in backward compatibility. Since it is likely that we will choose to release a VTK 6.0 rather than a VTK 5.10, you may be reading this book while working with VTK 6.0 or later. Although the latest features may not be covered here, the material in this guide will be applicable to future releases. For information on new features specific to future releases, see the VTK mailing lists (http://www.vtk.org/VTK/help/mailing.html) or the Kitware Source (http://www.kitware.com/products/thesource.html), Kitware’s free, quarterly developer’s newsletter. We highly recommend that you use VTK 5.4 or a later official release. Official releases are stable, consistent, and better tested than the current CVS repository. However, if you must use a more recent version, please be aware of the VTK quality testing dashboard. The Visualization Toolkit is heavily tested using the Kitware Software Process (http://www.kitware.com/solutions/softwareprocess.html). Before updating the CVS repository, make sure that the dashboard is “green” indicating stable code. If not green it is possible that your software update is unstable. (Learn more about the VTK quality dashboard in the section “Kitware’s Quality Software Process” on page 312.)
Directory Structure
To begin your VTK odyssey, you will first need to know something about VTK’s directory structure. Even if you are installing pre-compiled binaries, it is helpful to know enough to navigate through the code base to find examples, code, and documentation. The VTK directory structure is organized as follows. • InfoVis — classes for information visualization.
• Views — specialized classes for viewing data including: filters, visualization, interaction and selection.
• VTK/CMake — configuration files for cross-platform building.
• VTK/Common — core classes.
• VTK/Examples — well-documented examples, grouped by topic.
• VTK/Filtering — classes related to data processing in the visualization pipeline.
• VTK/GenericFiltering — an adaptor framework to interface VTK to external simulation packages.
• VTK/GeoVis — views, sources, and other objects useful in terrain visualization.


6 Welcome
• VTK/Graphics — filters that process 3D data.
• VTK/GUISupport — classes for using VTK with the MFC and Qt user interface packages.
• VTK/Hybrid — complex classes that depend on classes in multiple other directories.
• VTK/Imaging — image processing filters.
• VTK/IO — classes for reading and writing data.
• VTK/Parallel — parallel processing support such as MPI.
• VTK/Rendering — classes used to render.
• VTK/Utilities — supporting software like expat, png, jpeg, tiff, and zlib. The Doxygen directory contains scripts and configuration programs for generating the Doxygen documentation.
• VTK/VolumeRendering — classes used for volume rendering.
• VTK/Widgets — 3D widget classes.
• VTK/Wrapping — support for Tcl, Python, and Java wrapping.
Documentation
Besides this text and The Visualization Toolkit text (see the next section for more information), there are other documentation resources that you should be aware of.
• Doxygen Documentation. The Doxygen documentation is an essential resource when working with VTK. These extensive Web pages describe in detail every class and method in the system. The documentation also contains inheritance and collaboration diagrams, a listing of event invocations, and data members. The documentation is heavily hyper-linked to other classes and to the source code. The Doxygen documentation is available online at http://www.vtk.org. Make sure that you have the right documentation for your version of the source code.
• Header Files. Each VTK class is implemented with a .h and .cxx file. All methods found in the .h header files are documented and provide a quick way to find documentation for a particular method. (Indeed, Doxygen uses the header documentation to produces its output.)
Data
The data used in VTK examples and tests can be obtained from the download area at vtk.org, and via CVS access. Instructions for CVS access to the data repository are also available at vtk.org.
1.4 Additional Resources
This User's Guide is just one resource available to you to learn the Visualization Toolkit. Here is a sampling of some on-line resources, services, software applications and publications that can help you make effective use of this powerful toolkit.
• The companion textbook The Visualization Toolkit An Object-Oriented Approach to 3D Graphics covers in detail many of the algorithms and data structures utilized in VTK. The textbook is


1.4 Additional Resources 7
published by Kitware, Inc. and is available to purchase either through the Kitware web site or through amazon.com.
• The Source is a quarterly newsletter published by Kitware that covers all of Kitware's open source projects. New functionality added to VTK will typically be covered by an article in the Source, and past issues are a valuable resource for articles and tutorials on a variety of VTK related topics. You can view the source online at kitware.com, and you can subscribe to receive a copy via postal mail.
• The VTK web site at vtk.org contains pointers to many other resources such as online manual pages, the Wiki and FAQ, the dashboard and bug tracker, and a searchable archive of the vtkusers mailing list (see below). In particular, the Doxygen manual pages are an invaluable resource for both novice users and experienced developers.
• The vtkusers mailing list allows users and developers to ask questions and receive answers; post updates, bug fixes, and improvements; and offer suggestions for improving the system. Please visit the VTK web site for more information on how to join the mailing list.
• Professional training is available from Kitware. Developer's Training Courses covering several of Kitware's open source projects including VTK, ITK, CMake and ParaView are offered typically twice per year in the upstate New York area. In addition, Kitware can bring the course to your site for customized training for your development team. Please see the Kitware web site or send email to courses@kitware.com for further information.
• Commercial support and consulting contracts are available from Kitware. These contracts range from small support efforts where VTK experts assist you in developing your application, to large-scale consulting efforts where Kitware develops an application to your specifications. Please see the Kitware web site or send email to sales@kitware.com for further information.
• ParaView is an open source end-user application focused on scientific visualization that is built on top of VTK. You can find the ParaView web site at paraview.org. Using ParaView is an excellent way to learn VTK since you will have access to the most popular functionality from a graphical user interface. It is also a good reference point for what is possible with VTK since you can load your own data and see what sort of visualization techniques are available and what sort of performance you should expect.
• CMake is an open source build environment for cross platform development. Although basic VTK users will need very little CMake knowledge in order to successfully build VTK on their standard Windows, Linux, or Mac OSX platform, advanced users may find CMake useful in their own development efforts or may require some in-depth CMake knowledge in order to port VTK to a non-standard platform. Visit the CMake web site at cmake.org for more information.
• CDash is an open source testing platform utilized by VTK. You can find a link to the VTK testing dashboard (powered by CDash) on the VTK web site. The dashboard shows the results of nightly and continuous testing on a variety of platforms. Developers who are building on nonstandard platforms may with the contribute their own tests results to the dashboard. More information on the Kitware software process can be found in Section 10.8.




Chapter 2
Installation 2
T
his chapter describes the steps required to install VTK on your computer system. The overall difficulty of this process depends on several factors. On Microsoft Windows, you can install the pre-built vtk.exe and run Tcl scripts using it. For Python or Java usage, to link VTK libraries into your own applications, or to use VTK on any platform other than Microsoft Windows, you must build VTK from source code. (There are too many platform variations – keeping binary distributions up-to-date is too much work, so we focus on making VTK easy to build everywhere.) If you are compiling the VTK source code and building your own libraries, expect to spend one-half hour on faster, multi-processor systems, and several hours on slower, memory limited systems. Also, the time to build depends on how many interpreted languages you wrap around the VTK C++ core, and your system configuration. You may wish to refer to “System Architecture” on page 19 for an overview of the VTK architecture—this may make the compile process easier to follow. Also, if you run into trouble, you can contact the vtkusers mailing list (see “Additional Resources” on page 6).
2.1 Overview
VTK compiles and runs on many different computer platforms. By platform, we are referring to various combinations of operating systems, hardware configurations, and compilers. Because of the large number of combinations possible, binary distributions of VTK are generally not feasible. Therefore, to install VTK, you will have to compile and link the source code to produce libraries and executables. The exception to this process is if you are creating VTK applications using the Tcl interpreted language. In this case, pre-compiled binaries may be available for the Windows platform. Otherwise, you will have to compile the Tcl and Python VTK executables from the source code. The chapter begins with an overview of CMake, the Cross-platform Make tool. CMake is used on all operating systems to configure the build environment. Next, the chapter is divided into two sections based on the type of operating system that you are installing on: either Windows or UNIX (for


10 Installation
Macintosh OSX or Linux, follow the UNIX instructions). You only need to read the appropriate section for your installation. The Visualization Toolkit does not run on older versions of Windows such as Windows 3.1. It also does not run on any Macintosh OS prior to OSX 10.2 (Jaguar).
2.2 CMake
CMake is an open-source, cross-platform tool for configuring and managing the build process. Simple, platform independent files (CMakeLists.txt) are used to describe the build process and capture dependencies. When CMake is run, it produces native build files for the particular compiler/operating system that you are working on. For example, on Windows with Microsoft Visual Studio, solution files and project files are created. On Unix, makefiles are created. This way you can easily compile VTK on any computer using a single source tree and work with the development tools (editors, debuggers, profilers, compilers, etc.) that are natural to the platform that you are working on. (Learn more about CMake from cmake.org. Kitware also publishes a book Mastering CMake for detailed information.) Download the latest CMake from http://www.cmake.org. Running CMake requires three basic pieces of information: which compiler to use, where the source code directory (i.e. source tree) is, and which directory (i.e., build tree) to place the object code, libraries, and binaries that the compilation process produces. CMake will read the top-level CMakeLists.txt file found in the source tree and produce a cache (CMakeCache.txt) in the build tree. Note that CMake handles complex source code directory structures just fine—there will be one CMakeLists.txt file in each subdirectory of the source code tree. Once these basic pieces of information are provided, the user invokes the configure step. This causes CMake to read the top-level CMakeLists.txt file, determine the system configuration, locate system resources, and descend into subdirectories in the source tree. As CMake runs, it discovers CMake variables and flags (CMake cache entries) that control the build process. These are presented to the user after the configure process ends. If the user desires to change the cache values, CMake provides a simple GUI to do so. After they are changed, another configure invocation is performed. This iterative configuration process continues until no additional changes are required. Once this point is reached, the user invokes the generate step. The generate step produces the solutions files, project files or makefiles used to control the build process for the specified compiler. In the two sections that follow (Windows and Unix), specific instructions for running CMake for each platform are provided. Note that the general instructions described above are applicable to all systems. The CMake user interface may vary based on your platform. Although cmake-gui, the nwe Qt-based interface available in CMake 2.6 and later, is very similar from platform to platform. Also, if at all possible, install precompiled binaries for CMake rather than building CMake from source code.
2.3 Installing VTK on Windows XP, Vista or later
Under Windows there are two types of VTK installations. The first is a binary/executable installation that lets you do development in Tcl by running the pre-compiled executable. The second type is a full source code installation requiring you to compile the VTK source code (to generate C++ libraries) and VTK wrapper code (to generate Java, Tcl, and Python executables). Of the two types of installations, the binary installation is much easier. The source code installation has the advantage that you can monitor, debug, and modify VTK code—which is probably what you want if you are a class developer. Note, however, that even if you choose the binary installation, you can still extend VTK in


2.3 Installing VTK on Windows XP, Vista or later 11
a variety of ways—creating your own class (see “Writing A VTK Class: An Overview” on page 305), using run-time programmable filters (see “Programmable Filters” on page 419), and replacing VTK classes at run-time with your own versions of the class (see “Object Factories” on page 307).
Binary Installation
To install vtk.exe, the VTK Tcl/Tk executable, run the installer program vtk-X.X.X-win32.exe, available from the download page of vtk.org which will bring up an installation GUI (see Figure 2–1). The “X.X.X” in the installer program’s filename represents the version number of VTK used to build it. You may also download corresponding *.zip files of the VTK source tree and the VTKData directory. As we release new versions of VTK, we make them available via links on the vtk.org download page. Watch for release announcements on the vtkusers mailing list.
The VTK source tree contains many *.tcl scripts you may use to learn about how various VTK classes work. Download the vtk-X.X.X.zip and vtkdata-X.X.X.zip files and extract them to your hard drive. In the VTK folder, you will find an “Examples” folder. Under the Examples folder, there are folders such as GUI, MangledMesa, and Parallel; each of those folders will have a sub folder called Tcl that contains various Tcl examples. In addition to the Examples folder, there are library folders like Graphics, Imaging, and Filtering. Each of these folders contains a Testing/Tcl sub folder containing the regression tests for VTK. Try running any example by double clicking on the Tcl file. When you double-click on a Tcl file (.tcl extension) for the first time, a dialog box may appear asking you what to use to open the file. This means that you need to create an association between Tcl files and the vtk executable to run them. If this happens, click the "Select the program from a list" button on the dialog, and click "OK". A new dialog labeled "Open With" will appear. Click the "Browse" button on this dialog to display a file browser. In the browser, go to the directory where you installed VTK. Normally this is either C:\Program Files\VTK 5.4 or C:\Program Files\Documents and Settings\<username>\My Documents\VTK 5.4. In there you should see a bin folder which in turn contains a program called vtk. Double-click on vtk (or vtk.exe). Check that the "Always use the selected program to open this kind of file" checkbutton is marked on the "Open With" dialog, and then select the OK button. Your example should then run. In the future, double-clicking on any Tcl scripts will automatically begin execution of vtk.
Figure 2–1 The VTK installer program for Windows.


12 Installation
Alternatively, if Tcl files are already associated with the wish executable (from installing Tcl/ Tk binaries), you will see an error message similar to the following when you double-click on a Tcl file: can’t find package vtk while executing "package require vtk". If you receive this error message, right-click on the Tcl file, and select "Open With..." from the pop-up menu displayed. The "Open With" dialog will appear. Follow the rest of the instructions from the previous paragraph to associate Tcl files with the vtk executable. That completes the binary installation process for Windows. In Chapter 3 we’ll go into more detail on how to write your own C++, Tcl, Java and Python applications.
Source Code Installation
To develop C++ applications and extend VTK, you will need to do a source code installation. This is more challenging and may tie up your machine for a few hours as it compiles VTK. First you need to make sure your machine is capable of building a VTK source code release. You must be running Windows XP, Vista or later. You will need a C++ compiler installed on your machine. The instructions in this guide are oriented towards Microsoft Visual Studio 2005 or later, which works well with VTK. We also support the Borland C++ compiler, gcc under Cygwin or MinGW, NMake, Microsoft Visual C++ free editions, and Microsoft Visual C++ 2005. If you have not installed a C++ compiler, then you must do this first. The next issue to consider is what additional tools you plan to use. If you plan to do development in Java then you must download and install the Java JDK which is available from Sun Microsystems at http://www.java.sun.com. If you plan on using Tcl/Tk and you are not using Microsoft Visual C++, then you will need to download and build the source code version of Tcl/Tk from http://www.tcl.tk or download and install a Tcl/Tk binary from http://www.activestate.com/Products/ActiveTcl. (Note: Tcl/Tk version 8.4 works with VTK version 5.4.0.)
Installing CMake. To compile VTK, you will first need to install CMake. An installer for CMake is available from http://www.cmake.org.
Running CMake. After you have setup your C++ compiler, installed CMake, and installed any additional packages such as Tcl, Java, and Python, you are ready to run CMake. To run CMake, there should be a CMake entry in the Start menu under Programs->CMake->CMakeSetup. The CMakeSetup.exe interface (Figure 2–2) is a simple program that allows you to customize the build to your particular machine and desired options for VTK. First you must tell CMakeSetup where the source tree for VTK is located and where you want to put the VTK binaries (these are generated as a result of compiling the source code). You can specify those directories with the Browse buttons or by
Figure 2–2 CMake is used to generate projects, makefiles, or workspaces for different compilers and operating systems. CMake is cross-platform.


2.3 Installing VTK on Windows XP, Vista or later 13
typing in the paths manually. Once the source and binary directories have been selected, you should click on the Configure button. The first time you click the Configure button, CMake will display a dialog from which you can select the build system you will use for compiling VTK. Then the CMakeSetup GUI will be filled with a list of variables and values found in the CMake cache. When first run, all the variables will be colored red. The red indicates that the cache entry was generated or changed during the previous configure step. At this point, you can customize your VTK build. For example, if you want to enable the Tcl wrapping feature of VTK, scroll down in the cache values editor to the entry VTK_WRAP_TCL, and click on the value to toggle it from OFF to ON. After that, click the Configure button again. This will cause most of the values to change to gray, and any new values to appear in red. If you installed Tcl/ Tk from a binary install, none of the new values should have NOTFOUND as values; if they do, you will have to specify those paths manually with the CMake interface. To set any value in the CMake interface, you click to the right of the variable where the value is displayed. Depending on the type of variable, there may be a file chooser, edit box or pull down that will allow you to edit the value. Some important cache values for VTK are:
• BUILD_SHARED_LIBS — If this Boolean value is set to yes, then DLLs or shared libraries will be built. If it is no, then static libraries will be built. The default is static libraries. The static libraries are somewhat easier to work with, since they do not need to be in your path when executables are run. The executables will be self-contained. This is preferred for distribution of VTK based applications.
• VTK_WRAP_TCL — This determines if Tcl wrapping will be built.
• VTK_WRAP_PYTHON — This determines if Python wrapping will be built.
• VTK_WRAP_JAVA — This determines if Java wrapping will be built.
To get on-line help for any variable in CMake, simply click right over the value and select “Help for Cache Entry”. Most of the defaults should be correct. Continue to click on Configure until there are no longer any red values and you are happy with all of the values. At this point, you can click the OK button. This will cause CMake to write out the build files for the build type selected. For Microsoft, a project file will be located in the binary path you selected. Simply load this project file (VTK.dsw into Visual Studio 6.0, VTK.sln for .NET), and select the configuration you want to build in the Build->Set Active Configuration menu of Visual Studio. You will have the choice of Debug, Release, MinSizeRel (minimum size release), and RelWithDebInfo (release with debug information). You can select the ALL_BUILD project, and compile it as you would any other Visual Studio project. For Borland, makefiles are generated, and you have to use the command line make supplied with that compiler. The makefiles are located in the binary directory you specified. Once VTK has been built all libraries and executables produced will be located in the binary directory you specified to CMake in a sub-folder called bin (unless you changed the EXECUTABLE_OUTPUT_PATH, or LIBRARY_OUTPUT_PATH variables in CMake).
(Note: Do not use the MSVC++ “Rebuild All” menu selection to rebuild the source code. This deletes all CMakeLists.txt files which are then automatically regenerated as part of the build process. MSVC will then try reloading them and an error will result. Instead, to rebuild everything, remove your VTK binary directory, rerun CMake, and then do a normal build.) If you built VTK with BUILD_SHARED_LIBS on, then your client application will need to locate and load the VTK DLLs at runtime. There are many different ways that your application might


14 Installation
find the VTK DLLs at runtime. There are pros and cons associated with each way. The easiest approach is to make sure your application and the VTK DLLs exist in the same directory. You can copy all the VTK DLLs into your application's directory, or build your application into the same directory the VTK DLLs were built in using EXECUTABLE_OUTPUT_PATH in your own application's CMakeLists files. If your application’s executable files and the VTK DLLs exist in the same directory, everything should just work. The "pro" of these approaches is their simplicity. The cons are: if you make copies of the VTK DLLs, you'll need to make sure you copy them again if you update and rebuild VTK; if your application's build output is mixed in with VTK's build output, it may be difficult to determine which build product comes from which project if necessary.
Another alternative is to modify the PATH environment variable so that your application can find the VTK DLLs even though they are not in the same directory. However, within this alternative, there are a couple ways to accomplish the task. You can set up a command prompt where the PATH is modified only in that command prompt and then launch your application from there, or you can change the user's PATH environment variable or the system-wide PATH environment variable. Changing the user’s or system-wide PATH environment variable is recommended unless you need to have two or more distinct builds of VTK on the same computer.
The KWWidgets project (http://www.kwwidgets.org) provides a good example of setting the PATH from a batch script (to avoid changing the PATH environment variable), see the KWWidgetsSetupPaths.bat script in the build tree for the KWWidgets project. To obtain source code for KWWidgets, follow the instructions found at http://www.kwwidgets.org.
To set up a command prompt that can be used to launch an executable that can find the VTK DLLs, make a shortcut to a command prompt and then set it to call a batch file when it starts up. This is the technique that Visual Studio uses to create a command prompt where you can run the command line compiler or nmake. You can right click on a shortcut in the Windows Start menu and choose Properties to see how other command prompt shortcuts work. You can also drag-and-drop one of them to your desktop while holding down the control key to make a copy of it on your desktop. Then you can modify the properties of the shortcut on your desktop to call your own batch file that sets up your PATH and any other environment settings you may need for your application. Use the "/K batchfilename.bat" argument to the command prompt to run the batch file and then leave the command prompt running. Type "cmd /?" from any Windows command prompt for more information on the /K option.
For further discussion of locating DLLs on Windows, see the Windows SDK documentation for the LoadLibrary and LoadLibraryEx functions.
If you’ve made it this far, you’ve successfully built VTK on a PC. It can be a challenging process because of the size and complexity of the software. Please pay careful attention to the instructions given earlier. If you do run into problems, you may wish to join the vtkusers mailing list (see “Additional Resources” on page 6) and ask for help there. Commercial support is also available from Kitware.
2.4 Installing VTK on Unix Systems
There are a wide variety of flavors of Unix systems. As a result you will have to compile the VTK source code to build binaries and executables.


2.4 Installing VTK on Unix Systems 15
Source Code Installation
This section will walk you through the steps required to build VTK on a UNIX system. Unlike Windows, pre-compiled libraries and executables are not available for Unix systems, so you’ll have to compile VTK yourself. (Note: check the vtkusers mailing list and other resources as described in “Additional Resources” on page 6—some users maintain binaries on the Web.) Typically, it is a fairly simple process, and it should take about one to four hours depending on the speed of your machine. (High-end, large-memory multi-processor machines using parallel builds can build the C++ and Tcl libraries and executables in under 10 minutes!) Most of this time is spent waiting for the computer to compile the source code. Only about 10-30 minutes of your time will be required. The first step is to make sure you have the necessary resources to build VTK. To be safe, you will need about 300 megabytes of disk space. On some systems, such as SGI, you may need more space, especially if compiling a debug version of VTK. You will also need a C++ compiler since VTK is written in C++. Typically the C++ compiler will be called CC, g++, or acc. If you are not sure that you have a C++ compiler, check with your support staff. If you are planning to use VTK with Tcl/Tk, Python, or Java, then you will first need to download and install those packages. The Java JDK is available from Sun Microsystems at http:// www.java.sun.com. If you plan on using Tcl/Tk and it is not already installed on your system, then you will need to download Tcl/Tk from http://www.tcl.tk. Python can be downloaded from http://www.python.org. Follow the instructions in these packages to build them.
CMake
Similar to the Windows environment, VTK on Unix uses CMake for the build process. (See the previous section on CMake.) There are precompiled binaries of CMake available for many Unix systems; however, you may have to build CMake if binaries are not available. (Go to http:// www.cmake.org to download precompiled binaries.)
Installing CMake. If pre-compiled binaries are available, download and then extract the tar files into your destination directory (typically /usr/local). Either make sure that cmake and associated executables are in your path, or run cmake and its associated executables by giving their full path.
Building CMake. If a precompiled CMake binary is not available, you will have to build and install CMake. To build and install CMake, simply untar the sources (found at http://www.cmake.org) into a directory, and then run (in that directory):
./configure make make install
If you do not have root privileges, you can skip the third step above (i.e., make install). The CMake executables will be located at CMake/bin/. There are two different CMake executables which can be used to configure VTK: ccmake that provides a terminal based interface very similar to CMakeSetup described in the Windows installation section, and cmake which implements a wizard that requires you to answer a list of questions in order to configure the build. It is a good idea to tell CMake which C++ and C compilers you want to use. On most Unix systems, you can set the information this way:


16 Installation
setenv CXX /your/c++/compiler setenv CC /your/c/compiler
or
export CXX=/your/c++/compiler export CC=/your/c/compiler
Otherwise CMake will automatically detect your compiler—however, this may not be the one that you want if you have multiple compilers on your system. Once you have done this, create an empty binary directory (e.g., VTK-bin) at the same level as the VTK source directory, and run CMake in it, passing it the path to the VTK source directory as shown below.
cd VTK-bin ccmake ../VTK
or
cd VTK-bin cmake -i ../VTK
(The instructions in the following two subsections describe the differences between ccmake and cmake -i.) UNIX developers familiar with configure scripts will notice that CMake and configure are similar in their functionality. However, configure takes command line arguments to control the generation of makefiles whereas in CMake, the build options can be set from a user interface.
Customizing the Build Using the Terminal Based User Interface (ccmake). ccmake has a simple terminal based interface that allows you to customize the VTK build to your particular machine and with the desired options. Once you run CMake using ccmake, you will be presented with a list of options that can be modified to customize the VTK build. CMake will be able to set most of these options to reasonable default values. To change a value, simply scroll with arrow keys and press enter when the desired option is highlighted. You will then be able to edit the option (unless the variable is a boolean, in which case, pressing enter will toggle the value). After completing the edit operation, hit enter again to resume scrolling through the options. Once you set all the options you want, press ‘c’. CMake will then process the configuration files and if necessary display new options on top (for example, if you turn VTK_WRAP_TCL on, you will be presented with options for the location of Tcl/Tk libraries and include paths). If there are new options, you should set them, (or leave them as they are if you are satisfied with the default values) and re-configure by pressing ‘c’ and continue this process until there are no new options. Once this iterative process is completed, there will be new commands available: Generate and Exit. You can now press ‘g’ to have CMake generate new makefiles and exit. If you need to change build options in the future, simply re-run ccmake and follow the instructions above.
Customizing the Build Using the Interactive Wizard Mode (cmake -i). On some platforms the terminal based interface provided by ccmake may not work. In this case try cmake with the -i (interactive wizard) option. Once you do so, it will ask you whether you want to see the advanced options. Most users will not have to change the advanced options. Next, CMake will ask you a list of questions. For each option, there will be a line describing what it does and a default (current) value. In


2.4 Installing VTK on Unix Systems 17
most cases, CMake will be able to generate acceptable default options. However, in certain cases, for example when a library such as OpenGL library is not located in the expected place, you will have to tell CMake the correct setting. Furthermore, by default, the bindings for Tcl, Python and Java are not created. If you want support for one or more of these languages, you will have to turn on the appropriate VTK_WRAP_XXX option on and, if necessary, tell CMake the location of necessary libraries and header files. Once you answer all questions, all your makefiles will be generated and VTK will be ready to build. If you need to change build options in the future, you can re-run CMake in wizard mode and answer all questions again.
Compiling the Source Code
Once CMake has completed running and produced the necessary makefiles, you can type make and VTK should compile. Some make utilities such as GNU make (gmake) support parallel builds (e.g., gmake with the -j option). Use parallel make if possible, even if on a single processor system, because usually the process is IO bound and the processor can handle multiple compiles. If you do run into problems, you may wish to join the vtkusers mailing list (see “Additional Resources” on page 6) and ask for help there. Commercial support is also available from Kitware.
Building VTK On Multiple Platforms
If you are planning to build VTK for multiple architectures then you can either make a copy of the entire VTK tree for each architecture and follow the instructions above, or you can have one copy of the VTK source tree and produce object code, libraries, and executables for each architecture in a separate directory. This approach requires creating a new build directory for each architecture such as vtk-solaris (make sure that you have enough disk space). Assuming that the new directory is created along side of the VTK source code directory, change directory (cd) into this directory and then run CMake similar to the following example:
cd /yourdisk
ls (output is: VTK vtk-solaris vtk-sgi) cd vtk-solaris cmake -i ../VTK
or
ccmake ../VTK
This will create makefiles in the vtk-solaris directory. You can now follow the instructions in the previous section for compiling VTK.
Installing VTK
Now that VTK has been built, the executables and libraries will be located in the build directory, in the sub-directory bin/. If you plan to share the build with more than one developer on the UNIX system, and you have root privileges, it is often a good idea to run the make install command. This will install VTK into /usr/local, unless you changed the build option CMAKE_INSTALL_PREFIX to another location. Running make install will copy all the files you need to compile and run VTK into a directory that other users can share.


18 Installation
This concludes the build and installation section for VTK under UNIX. If you need more information about CMake, see http://www.cmake.org or purchase the Mastering CMake book from Kitware (http://www.kitware.com/products/cmakebook.html). Chapter 3 of this software guide provides more details on how to run examples and create your own applications.


Chapter 3
System Overview 3
T
he purpose of this chapter is to provide you with an overview of the Visualization Toolkit system, and to show you the basic information you’ll need to create applications in C++, Java, Tcl, and Python. We begin by introducing basic system concepts and object model abstractions. We close the chapter by demonstrating these concepts and describing what you’ll need to know to build applications.
3.1 System Architecture
The Visualization Toolkit consists of two basic subsystems: a compiled C++ class library and an “interpreted” wrapper layer that lets you manipulate the compiled classes using the languages Java, Tcl, and Python. See Figure 3–1. The advantage of this architecture is that you can build efficient (in both CPU and memory usage) algorithms in the compiled C++ language, and retain the rapid code development features of interpreted languages (avoidance of compile/link cycle, simple but powerful tools, and access to GUI tools). Of course, for those proficient in C++ and who have the tools to do so, applications can be built entirely in C++. The Visualization Toolkit is an object-oriented system. The key to using VTK effectively is to develop a good understanding of the underlying object models. Doing so will remove much of the mystery surrounding the use of the hundreds of objects in the system. With this understanding in place it’s much easier to combine objects to build applications. You’ll also need to know something about the capabilities of the many objects in the system; this only comes with reviewing code exam
Figure 3–1 The Visualization Toolkit consists of a compiled (C++) core wrapped with various interpreted languages (Java, Tcl, Python).
Interpreted Wrapper (Tcl, Java, Python)
Compiled Core (C++)


20 System Overview
ples and online documentation. In this User’s Guide, we’ve tried to provide you with useful combinations of VTK objects that you can adapt to your own applications. In the remainder of this section, we will introduce two major components of the Visualization Toolkit: the visualization pipeline and the rendering engine. The visualization pipeline is used to acquire or create data, process that data, and either write the results to a file or pass the results to the rendering engine for display. The rendering engine is responsible for creating a visual representation of the data. Note that these are not truly rigid architectural components of VTK but are instead conceptual components. The discussion in this chapter will be fairly high-level, but when you combine that with the specific examples in both this chapter and the next, as well as the hundreds of available examples in the VTK source distribution you will gain a good understanding of these components.
Low-Level Object Model
The VTK object model can be thought of as being rooted in the superclass vtkObject. Nearly all VTK classes are derived from this class, or in some special cases from its superclass vtkObjectBase. All VTK must be created using the object's New() method, and must be destroyed using the object's Delete() method. VTK objects cannot be allocated on the stack because the constructor is a protected method. Using a common superclass and a unified method of creating and destroying object, VTK is able to provide several basic object-oriented operations.
Reference Counting. Objects explicitly store a count of the number of pointers referencing them. When an object is created through the static New() method of a class its initial reference count is 1 because a raw pointer must be used to refer to the new object:
vtkObjectBase* obj = vtkExampleClass::New();
When other references to the object are created or destroyed the reference count is incremented and decremented using the Register() and UnRegister() methods. Usually this is handled automatically by the various “set” methods provided in the object’s API:
otherObject->SetExample(obj);
The reference count is now 2 because both the original pointer and a pointer stored inside the other object both refer to it. When the raw pointer originally storing the object is no longer needed the reference is removed using the Delete() method:
obj->Delete();
From this point forward it is no longer safe to use the original pointer to access the object because the pointer does not own a reference to it. In order to ensure proper management of object references every call to New() must be paired with a later call to Delete() to be sure no references are leaked. A "smart pointer" implementation is provided by the class template vtkSmartPointer<> which simplifies object management. The above example may be re-written:
vtkSmartPointer<vtkObjectBase> obj = vtkSmartPointer<vtkExampleClass>::New(); otherObject->SetExample(obj);


3.1 System Architecture 21
In this case the smart pointer automatically manages the reference it owns. When the smart pointer variable goes out-of-scope and is no longer used, such as when a function in which it is a local variable returns, it automatically informs the object by decrementing the reference count. By using the static New() method provided by the smart pointer no raw pointer ever needs to hold a reference to the object, so no call to Delete() is needed.
Run-Time Type Information. In C++ the real type of an object may be different from the type of pointer used to reference it. All classes in the public interface of VTK have simple identifiers for class names (no templates), so a string is sufficient to identify them. The type of a VTK object may be obtained at run-time with the GetClassName() method:
const char* type = obj->GetClassName();
An object may be tested for whether it is an instance of a particular class or one of its subclasses using the IsA() method:
if(obj->IsA("vtkExampleClass")) { ... }
A pointer of a superclass type may be safely converted to a more derived type using the static SafeDownCast() method provided by the class of the derived type:
vtkExampleClass* example = vtkExampleClass::SafeDownCast(obj)
This will succeed at run-time only if the object is truly an instance of the more-derived type and otherwise will return a null pointer.
Object State Display. When debugging it is often useful to display a human-readable description of the current state of an object. This can be obtained for VTK objects using the Print() method:
obj->Print(cout);
The Rendering Engine
The VTK rendering engine consists of the classes in VTK that are responsible for taking the results of the visualization pipeline and displaying them into a window. This involves the following components. Note that this is not an exhaustive list, but rather a sense of the most commonly used objects in the rendering engine. The subheadings used here are the highest level superclass in VTK that represents this type of object, and in many cases where there are multiple choices these are abstract classes defining the basic API across the various concrete subclasses that implement the functionality..
vtkProp. Visible depictions of data that exist in the scene are represented by a subclass of vtkProp. The most commonly used subclasses of vtkProp for displaying objects in 3D are vtkActor (used to represent geometric data in the scene) and vtkVolume (used to represent volumetric data in the scene). There are also props that represent data in 2D such as vtkActor2D. The vtkProp subclass is generally responsible for knowing its position, size, and orientation in the scene. The parameters used to control the placement of the prop generally depend on whether the prop is for example a 3D object in the scene, or a 2D annotation. For 3D props such as vtkActor and vtkVolume (both subclasses of vtkProp3D which is itself a subclass of vtkProp), you can either directly control parameters such as


22 System Overview
the object's 3D position, orientation and scale, or you can use a 4x4 transformation matrix. For 2D props that provide annotation such as the vtkScalarBarActor, the size and position of the annotation can be defined in a variety of ways including specifying a position, width, and height relative to the size of the entire viewport. In addition to providing placement control, props generally have a mapper object that holds the data and knows how to render it, and a property object that controls parameters such as color and opacity.
There are a large number (over 50) of specialized props such as vtkImageActor (used to display an image) and vtkPieChartActor (used to create a pie chart visual representation of an array of data
(a) Image Data (vtkImageData)
(e) Polygonal Data (vtkPolyData)
(c) Structured Grid (vtkStructuredGrid)
(f) Unstructured Grid (vtkUnstructuredGrid)
(b) Rectilinear Grid (vtkRectilinearGrid)
(d) Unstructured Points (use vtkPolyData)
Figure 3–2 Dataset types found in VTK. Note that unstructured points can be represented by either polygonal data or unstructured grids, so are not explicitly represented in the system.


3.1 System Architecture 23
values). Some of these specialized props directly contain the parameters that control appearance, and directly have a reference to the input data to be rendered, and therefore do not require the use of a property or a mapper. The vtkFollower prop is a specialized subclass of vtkActor that will automatically update its orientation in order to continually face a specified camera. This is useful for displaying billboards or text in the 3D scene and having them remain visible as the user rotates. The vtkLODActor is also a subclass of vtkActor that automatically changes its geometric representation in order to maintain interactive frame rates, and vtkLODProp3D is a subclass of vtkProp3D that selects between a number of different mappers (perhaps even a mixture of volumetric and geometric mappers) in order to provide interactivity. vtkAssembly allows hierarchies of actors, properly managing the transformations when the hierarchy is translated, rotated or scaled.
vtkAbstractMapper. Some props such as vtkActor and vtkVolume use a subclass of vtkAbstractMapper to hold a reference to the input data and to provide the actual rendering functionality. The vtkPolyDataMapper is the primary mapper for rendering polygonal geometry. For volumetric objects, VTK provides several rendering techniques including the vtkFixedPointVolumeRayCastMapper that can be used to rendering vtkImageData, and the vtkProjectedTetrahedra mapper that can be used to render vtkUnstructuredGrid data.
vtkProperty and vtkVolumeProperty. Some props use a separate property object to hold the various parameters that control the appearance of the data. This allows you to more easily share appearance settings between different objects in your scene. The vtkActor object uses a vtkProperty to store parameters such as color, opacity, and the ambient, diffuse, and specular coefficient of the material. The vtkVolume object instead uses a vtkVolumeProperty to capture the parameters that are applicable to a volumetric object, such as the transfer functions that map the scalar value to color and opacity. Many mappers also provide functionality to set clipping planes that can be used to reveal interior structure.
vtkCamera. The vtkCamera contains the parameters that control how you view the scene. The vtkCamera has a position, a focal point, and a vector defining the direction of "up" in the scene. Other parameters control the specific viewing transformation (parallel or perspective), the scale or view angle of the image, and the near and far clipping planes of the view frustum.
vtkLight. When lighting is computed for a scene, one or more vtkLight objects are required. The vtkLight objects store the position and orientation of the light, as well as the color and intensity. Lights also have a type that describes how the light will move with respect to the camera. For example, a Headlight is always located at the camera's position and shines on the camera's focal point, whereas a SceneLight is located at a stationary position in the scene.
vtkRenderer. The objects that make up a scene including the props, the camera and the lights are collected together in a vtkRenderer. The vtkRenderer is responsible for managing the rendering process for the scene. Multiple vtkRenderer objects can be used together in a single vtkRenderWindow. These renderers may render into different rectangular regions (known as viewports) of the render window, or may be overlapping.
vtkRenderWindow. The vtkRenderWindow provides a connection between the operating system and the VTK rendering engine. Platform specific subclasses of vtkRenderWindow are responsible for opening a window in the native windowing system on your computer and managing the display pro


24 System Overview
cess. When you develop with VTK, you simply use the platform-independent vtkRenderWindow which is automatically replaced with the correct platform-specific subclass at runtime. The vtkRenderWindow contains a collection of vtkRenderers, and parameters that control rendering features such as stereo, anti-aliasing, motion blur and focal depth.
vtkRenderWindowInteractor. The vtkRenderWindowInteractor is responsible for processing mouse, key, and timer events and routing these through VTK's implementation of the command / observer design pattern. A vtkInteractorStyle listens for these events and processes them in order to provide motion controls such as rotating, panning and zooming. The vtkRenderWindowInteractor automatically creates a default interactor style that works well for 3D scenes, but you can instead select one for 2D image viewing for example, or create your own custom interactor style.
vtkTransform. Many of the objects in the scene that require placement such as props, lights, and cameras have a vtkTransform parameter that can be used to easily manipulate the position and orientation of the object. The vtkTransform can be used to describe the full range of linear (also known as affine) coordinate transformation in three dimensions, which are internally represented as a 4x4 homogeneous transformation matrix. The vtkTransform object will start with a default identity matrix or you can chain transformation together in a pipeline fashion to create complex behavior. The pipeline mechanism assures that if you modify any transform in the pipeline, all subsequent transforms are updated accordingly.
vtkLookupTable, vtkColorTransferFunction, and vtkPiecewiseFunction. Visualizing scalar data often involves defining a mapping from a scalar value to a color and opacity. This is true both in geometric surface rendering where the opacity will define the translucency of the surface, and in volume rendering where the opacity will represent the opacity accumulated along some length of of ray passing through the volume. For geometric rendering, this mapping is typically created using a vtkLookupTable, and in volume rendering both the vtkColorTransferFunction and the vtkPiecewiseFunction will be utilized.
A minimal example. The following example (adapted from ./VTK/Examples/Rendering/Cxx/Cylinder.cxx) shows how some of these objects can be used to specify and render a scene.
vtkCylinderSource *cylinder = vtkCylinderSource::New();
vtkPolyDataMapper *cylinderMapper = vtkPolyDataMapper::New(); cylinderMapper->SetInputConnection(cylinder->GetOutputPort());
vtkActor *cylinderActor = vtkActor::New(); cylinderActor->SetMapper(cylinderMapper);
vtkRenderer *ren1 = vtkRenderer::New(); ren1->AddActor(cylinderActor);
vtkRenderWindow *renWin = vtkRenderWindow::New(); renWin->AddRenderer(ren1);
vtkRenderWindowInteractor *iren = vtkRenderWindowInteractor::New(); iren->SetRenderWindow(renWin);


3.1 System Architecture 25
renWin->Render(); iren->Start();
In this example we have directly created a vtkActor, vtkPolyDataMapper, vtkRenderer, vtkRenderWindow and vtkRenderWindowInteractor. Note that a vtkProperty was automatically created by the actor, and a vtkLight and a vtkCamera were automatically created by the vtkRenderer.
The Visualization Pipeline
The visualization pipeline in VTK can be used to read or create data, analyze and create derivative version of this data, and write the data to disk or pass it along to the rendering engine for display. For example, you may read a 3D volume of data from disk, process it to create a set of triangles representing an isovalued surface through the volume, then write this geometric object back out to disk. Or, you may create a set of spheres and cylinders to represent atoms and bonds, then pass these off to the rendering engine for display. The Visualization Toolkit uses a data flow approach to transform information into graphical data. There are two basic types of objects involved in this approach.
• vtkDataObject
• vtkAlgorithm
Data objects represent data of various types. The class vtkDataObject can be viewed as a generic “blob” of data. Data that has a formal structure is referred to as a dataset (class vtkDataSet). Figure 32 shows the dataset objects supported in VTK. Datasets consist of a geometric and topological structure (points and cells) as illustrated by the figure; they also have associated attribute data such as scalars or vectors. The attribute data can be associated with the points or cells of the dataset. Cells are topological organizations of points; cells form the atoms of the dataset and are used to interpolate information between points. Figure 19–20 and Figure 19–21 show twenty-three of the most common cell types supported by VTK. Figure 3–3 shows the attribute data supported by VTK. Algorithms, also referred to generally as filters, operate on data objects to produce new data objects. Algorithms and data objects are connected together to form visualization pipelines (i.e., dataflow networks). Figure 3–4 is a depiction of a visualization pipeline. This figure together with Figure 3–5 illustrate some important visualization concepts. Source algorithms produce data by reading (reader objects) or constructing one or more data objects (procedural source objects). Filters ingest one or more data objects and generate one or more data objects on output. Mappers (or in some cases, specialized actors) take the data and convert it into a visual representation that is displayed by the rendering engine. A writer can be thought of as a type of mapper that writes data to a file or stream. There are several important issues regarding the construction of the visualization pipeline that we will briefly introduce here. First, pipeline topology is constructed using variations of the methods
aFilter->SetInputConnection( anotherFilter->GetOutputPort() );
which sets the input to the filter aFilter to the output of the filter anotherFilter. (Filters with multiple inputs and outputs have similar methods.) Second, we must have a mechanism for controlling the execution of the pipeline. We only want to execute those portions of the pipeline necessary to bring the output up to date. The Visualization Toolkit uses a lazy evaluation scheme (executes only


26 System Overview
Figure 3–3 Data attributes associated with the points and cells of a dataset.
Scalar: single data value Vector: 3D direction and magnitude
Normal: 3D direction
Texture coordinate:
n-dimensional index into texture map
Tensor: nxn matrix
s
(u,v,w)
(nx, ny, nz) |n|=1
s
t
2D: (u,v) 3D: (u,v,w)
a11 a12 a13
a21 a22 a23
a31 a32 a33
Field Data:
An array of arrays. Each array can be of different data type (vtkFieldData)
vtkDataArray
Array 0 Array 1 Array n-1
Source Filter Filter Mapper
Data Object
Filter
Rendering engine
Multiple Input
Data Object
Data Object Data Object Data Object
Figure 3–4 Data objects are connected with algorithms (filters) to create the visualization pipeline. The arrows point in the direction of data flow.
Source


3.1 System Architecture 27
when the data is requested) based on an internal modification time of each object. Third, the assembly of the pipeline requires that only those objects compatible with one another can fit together with the SetInputConnection() and GetOutputPort() methods. VTK produces errors at run-time if the data object types are incompatible. Finally, we must decide whether to cache, or retain, the data objects once the pipeline has executed. Since visualization datasets are typically quite large, this is important to the successful application of visualization tools. VTK offers methods to turn data caching on and off, use of reference counting to avoid copying data, and methods to stream data in pieces if an entire dataset cannot be held in memory. (We recommend that you review the chapter on the Visualization Pipeline in The Visualization Toolkit An Object-Oriented Approach to 3D Graphics text for more information.)
Please note that there are many varieties of both algorithm and data objects. Figure 16–2 shows six of the most common data object types supported by the current version of VTK. Algorithm objects vary in their type(s) of input data and output data and of course in the particular algorithm implemented.
Pipeline Execution. In the previous section we discussed the need to control the execution of the visualization pipeline. In this section we will expand our understanding of some key concepts regarding pipeline execution.
As indicated in the previous section, the VTK visualization pipeline only executes when data is required for computation (lazy evaluation). Consider this example where we instantiate a reader object and ask for the number of points as shown below. (The language shown here is Tcl.)
No input
Data
Source Filter Mapper
Filter Filter
Data
Data
Single input
Single output
Multiple input
Multiple fan-out
≥ 1 output ≥ 1 output
≥ 1 input ≥ 1 input
No output
(a) Sources, filters, and mappers
Multiple output
(b) Multiplicity of input and output
Data Data
Filter
Figure 3–5 Different types of algorithms. Filters ingest one or more inputs and produce one or more output data objects.


28 System Overview
vtkPLOT3DReader reader reader SetXYZFileName $VTK_DATA_ROOT/Data/combxyz.bin [reader GetOutput] GetNumberOfPoints
the reader object will return “0” from the GetNumberOfPoints() method call, despite the fact that the data file contains thousands of points. However, if you add the Update() method
reader Update [reader GetOutput] GetNumberOfPoints
the reader object will return the correct number. In the first example, the GetNumberOfPoints() methods does not require computation, and the object simply returns the current number of points, which is “0”. In the second example, the Update() method forces execution of the pipeline, thereby forcing the reader to execute and read the data from the file indicated. Once the reader has executed, the number of points in its output is set correctly. Normally, you do not need to manually invoke Update() because the filters are connected into a visualization pipeline. In this case, when the actor receives a request to render itself, it forwards the method to its mapper, and the Update() method is automatically sent through the visualization pipeline. A high-level view of pipeline execution appears in Figure 3–6. As this figure illustrates, the Render() method often initiates the request for data; this request is then passed up through the pipeline. Depending on which portions of the pipeline are out-of-date, the filters in the pipeline may reexecute, thereby bringing the data at the end of the pipeline up-to-date; the up-to-date data is then rendered by the actor. (For more information about the execution process, see Chapter 15 “Managing Pipeline Execution” on page 317.)
Image Processing. VTK supports an extensive set of image processing and volume rendering functionality. In VTK, both 2D (image) and 3D (volume) data are referred to as vtkImageData. An image dataset in VTK is one in which the data is arranged in a regular, axis-aligned array. Images, pixmaps, and bitmaps are examples of 2D image datasets; volumes (a stack of 2D images) is a 3D image dataset. Algorithms in the imaging pipeline always input and output image data objects. Because of the regular and simple nature of the data, the imaging pipeline has other important features. Volume rendering is used to visualize 3D vtkImageData (see “Volume Rendering” on page 139), and special image viewers are used to view 2D vtkImageData. Almost all algorithms in the imaging pipeline are multithreaded and are capable of streaming data in pieces to satisfy a user-specified memory limit. Filters automatically sense the number of cores and processors available on the system and create that
Figure 3–6 Conceptual overview of pipeline execution.
Source Filter Mapper Actor
Direction of Update() method
Direction of data flow (data generated via algorithm RequestData() method)
Render()


3.2 Create An Application 29
number of threads during execution as well as automatically separating data into pieces that are streamed through the pipeline. (See “vtkStreamingDemandDrivenPipeline” on page 325 for more information.) This concludes our brief overview of the Visualization Toolkit system architecture. We recommend the The Visualization Toolkit An Object-Oriented Approach to 3D Graphics text for more details on many of the algorithms found in VTK. Learning by example is another helpful approach. Chapters 4 through 13 contain many annotated examples demonstrating various capabilities of VTK. Also, since source code is available, you may wish to study the examples found in the VTK/Examples directory of the VTK source tree. With this abbreviated introduction behind us, let’s look at ways to create applications in C++, Tcl, Java, and Python.
3.2 Create An Application
This section covers the basic information you need to develop VTK applications in the four programming languages Tcl, C++, Java, and Python. After reading this introduction, you should jump to the subsection(s) that discuss the language(s) you are interested in using. In addition to providing you with instructions on how to create and run a simple application, each section will show you how to take advantage of callbacks in that language.
User Methods, Observers, and Commands
Callbacks (or user methods) are implemented in VTK using the Subject/Observer and Command design pattern. This means that nearly every class in VTK (every subclass of vtkObject) has an AddObserver() method that can be used to setup callbacks from VTK. The observer looks at every event invoked on an object, and if it matches one of the events that the observer is watching for, then an associated command is invoked (i.e., the callback). For example, all VTK filters invoke a StartEvent right before they start to execute. If you add an observer that watches for a StartEvent then it will get called every time that filter starts to execute. Consider the following Tcl script that creates an instance of vtkElevationFilter, and adds an observer for the StartEvent to call the procedure PrintStatus.
proc PrintStatus {} { puts "Starting to execute the elevation filter" }
vtkElevationFilter foo foo AddObserver StartEvent PrintStatus
This type of functionality (i.e., callback) is available in all the languages VTK supports. Each section that follows will show a brief example of how to use it. Further discussion on user methods is provided in “Integrating With The Windowing System” on page 421. (This section also discusses user interface integration issues.) To create your own application, we suggest starting with one of the examples that come with VTK. They can be found in VTK/Examples in the source distribution. In the source distribution the examples are organized first by topic and then by language. Under VTK/Examples you will find directories for different topics, and under the directories there will be subdirectories for different languages such as Tcl.


30 System Overview
Tcl
Tcl is one of the easiest languages with which to start creating VTK applications. Once you have installed VTK, you should be able to run the Tcl examples that come with the distribution. Under UNIX you have to compile VTK with Tcl support as mentioned in “Installing VTK on Unix Systems” on page 14. Under Windows you can just install the self-extracting archive as described in “Installing VTK on Windows XP, Vista or later” on page 10.
Windows. Under Windows, you can run a Tcl script just by double clicking on the file (Cone.tcl in this example). If nothing happens you might have an error in your script or a problem with associating Tcl files with the vtk.exe executable. To detect this you need to run vtk.exe first. vtk.exe can be found in your start menu under VTK. Once execution begins, a console window should appear with a prompt in it. At this prompt type in a cd command to change to the directory where Cone.tcl is located. Two examples are given below:
% cd "c:/VTK/Examples/Tutorial/Step1/Tcl"
Then you will need to source the example script using the following command.
% source Cone.tcl
Tcl will try to execute Cone.tcl, and you will be able to see errors or warning messages that would otherwise not appear.
Unix. Under UNIX, Tcl development can be done by running the VTK executable (after you have compiled the source code) that can be found in your binary directory (e.g., VTK-bin/bin/vtk, VTKSolaris/bin/vtk, etc.) and then providing the Tcl script as the first argument as shown below.
unix machine> cd VTK/Examples/Tutorial/Step1/Tcl unix machine> /home/VTK-Solaris/bin/vtk Cone.tcl
User methods can be set up as shown in the introduction of this section. An example can be found in Examples/Tutorial/Step2/Tcl/Cone2.tcl. The key changes are shown below.
proc myCallback {} { puts "Starting to render" }
vtkRenderer ren1 ren1 AddObserver StartEvent myCallback
You may instead simply provide the body of the proc directly to AddObserver().
vtkRenderer ren1 ren1 AddObserver StartEvent {puts "Starting to render"}
C++
Using C++ as your development language will typically result in smaller, faster, and more easily deployed applications than most any other language. C++ development also has the advantage that


3.2 Create An Application 31
you do not need to compile any additional support for Tcl, Java, or Python. This section will show you how to create a simple VTK C++ application for the PC with Microsoft Visual C++ and also for UNIX using an appropriate compiler. We will start with a simple example called Cone.cxx which can be found in Examples/Tutorial/Step1/Cxx. For both Windows and UNIX you can use a source code installation of VTK or installed binaries. These examples will work with both. The first step in building your C++ program is to use CMake to generate a makefile or workspace file, depending on your compiler. The CMakeList.txt file that comes with Cone.cxx (shown below) makes use of the FindVTK and UseVTK CMake modules. These modules attempt to locate VTK and then setup your include paths and link lines for building C++ programs. If they do not successfully find VTK, you will have to manually specify the appropriate CMake parameters and rerun CMake as necessary.
PROJECT (Step1)
FIND_PACKAGE(VTK REQUIRED) IF(NOT VTK_USE_RENDERING) MESSAGE(FATAL_ERROR "Example ${PROJECT_NAME} requires VTK_USE_RENDERING.") ENDIF(NOT VTK_USE_RENDERING) INCLUDE(${VTK_USE_FILE})
ADD_EXECUTABLE(Cone Cone.cxx) TARGET_LINK_LIBRARIES(Cone vtkRendering)
Microsoft Visual C++. Once you have run CMake for the Cone example you are ready to start Microsoft Visual C++ and load the generated solution file. For current .NET versions of the compile this will be named Cone.sln.You can now select a build type (such as Release or Debug) and build your application. If you want to integrate VTK into an existing project that does not use CMake, you can copy the settings from this simple example into your existing workspaces. Now consider an example of a true Windows application. The process is very similar to what we did above, except that we create a windows application instead of a console application, as shown in the following. Much of the code is standard Windows code and will be familiar to any Windows developer. This example can be found in VTK/Examples/GUI/Win32/SimpleCxx/ Win32Cone.cxx. Note that the only significant change to the CMakeLists.txt file is the addition of the WIN32 parameter in the ADD_EXECUTABLE command.
#include "windows.h" #include "vtkConeSource.h" #include "vtkPolyDataMapper.h" #include "vtkRenderWindow.h" #include "vtkRenderWindowInteractor.h" #include "vtkRenderer.h"
static HANDLE hinst; long FAR PASCAL WndProc(HWND, UINT, UINT, LONG);
// define the vtk part as a simple c++ class class myVTKApp {


32 System Overview
public: myVTKApp(HWND parent); ~myVTKApp(); private: vtkRenderWindow *renWin; vtkRenderer *renderer; vtkRenderWindowInteractor *iren; vtkConeSource *cone; vtkPolyDataMapper *coneMapper; vtkActor *coneActor; };
We start by including the required VTK include files. Next we have two standard windows prototypes followed by a small class definition called myVTKApp. When developing in C++, you should try to use object-oriented approaches instead of the scripting programming style found in many of the Tcl examples. Here we are encapsulating the VTK components of the application into a small class. This is the constructor for myVTKApp. As you can see it allocates the required VTK objects, sets their instance variables, and then connects them to form a visualization pipeline. Most of this is straightforward VTK code except for the vtkRenderWindow. This constructor takes a HWND handle to the parent window that should contain the VTK rendering window. We then use this in the SetParentId() method of vtkRenderWindow so that it will create its window as a child of the window passed to the constructor.
myVTKApp::myVTKApp(HWND hwnd) {
// Similar to Examples/Tutorial/Step1/Cxx/Cone.cxx // We create the basic parts of a pipeline and connect them this->renderer = vtkRenderer::New(); this->renWin = vtkRenderWindow::New(); this->renWin->AddRenderer(this->renderer);
// setup the parent window this->renWin->SetParentId(hwnd); this->iren = vtkRenderWindowInteractor::New(); this->iren->SetRenderWindow(this->renWin);
this->cone = vtkConeSource::New(); this->cone->SetHeight( 3.0 ); this->cone->SetRadius( 1.0 ); this->cone->SetResolution( 10 ); this->coneMapper = vtkPolyDataMapper::New(); this->coneMapper->SetInputConnection(this->cone->GetOutputPort()); this->coneActor = vtkActor::New(); this->coneActor->SetMapper(this->coneMapper);
this->renderer->AddActor(this->coneActor); this->renderer->SetBackground(0.2,0.4,0.3); this->renWin->SetSize(400,400);
// Finally we start the interactor so that event will be handled


3.2 Create An Application 33
this->renWin->Render(); }
The destructor simply frees all of the VTK objects that were allocated in the constructor.
myVTKApp::~myVTKApp() {
renWin->Delete(); renderer->Delete(); iren->Delete(); cone->Delete(); coneMapper->Delete(); coneActor->Delete(); }
The WinMain code here is all standard windows code and has no VTK references in it. As you can see the application has control of the event loop. Events are handled by the WndProc described later in this section.
int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow) {
static char szAppName[] = "Win32Cone"; HWND hwnd ; MSG msg ; WNDCLASS wndclass ;
if (!hPrevInstance) {
wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; wndclass.lpfnWndProc = WndProc ; wndclass.cbClsExtra = 0 ; wndclass.cbWndExtra = 0 ; wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION); wndclass.hCursor = LoadCursor (NULL, IDC_ARROW); wndclass.lpszMenuName = NULL; wndclass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); wndclass.lpszClassName = szAppName; RegisterClass (&wndclass); }
hinst = hInstance;
hwnd = CreateWindow ( szAppName, "Draw Window", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 400, 480, NULL,


34 System Overview
NULL, hInstance, NULL); ShowWindow (hwnd, nCmdShow); UpdateWindow (hwnd); while (GetMessage (&msg, NULL, 0, 0)) {
TranslateMessage (&msg); DispatchMessage (&msg); }
return msg.wParam; }
This WndProc is a very simple event handler. For a full application it would be significantly more complicated, but the key integration issues are the same. At the top of this function we declare a static reference to a myVTKApp instance. When handling the WM_CREATE method we create an Exit button and then construct an instance of myVTKApp passing in the handle to the current window. The vtkRenderWindowInteractor will handle all of the events for the vtkRenderWindow, so you do not need to handle them here. You probably will want to add code to handle resizing events so that the render window resizes appropriately with respect to your overall user interface. If you do not set the ParentId of the vtkRenderWindow, it will show up as a top-level independent window. Everything else should behave the same as before.
long FAR PASCAL WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam) {
static HWND ewin; static myVTKApp *theVTKApp; switch (message) {
case WM_CREATE: {
ewin = CreateWindow("button","Exit", WS_CHILD | WS_VISIBLE | SS_CENTER, 0,400,400,60, hwnd,(HMENU)2, (HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE), NULL); theVTKApp = new myVTKApp(hwnd); return 0; }
case WM_COMMAND: switch (wParam) {
case 2: PostQuitMessage (0); if (theVTKApp) {
delete theVTKApp; theVTKApp = NULL;


3.2 Create An Application 35
}
break; }
return 0;
case WM_DESTROY: PostQuitMessage (0); if (theVTKApp) {
delete theVTKApp; theVTKApp = NULL; }
return 0; }
return DefWindowProc (hwnd, message, wParam, lParam); }
UNIX. Creating a C++ application on UNIX is done by running CMake and then make. CMake creates a makefile that specifies the include paths, link lines, and dependencies. The make program then uses this makefile to compile the application. This should result in a Cone executable that you can run. If Cone.cxx does not compile then check the make errors and correct them. Make sure that the values in the top of CMakeCache.txt are valid. If it does compile, but you receive errors when you try running it, you might need to set your LD_LIBRARY_PATH as described in Chapter 2.
User Methods in C++. You can add user methods (using the observer/command design pattern) in C++ by creating a subclass of vtkCommand that overrides the Execute() method. Consider the following example taken from VTK/Examples/Tutorial/Step2/Cxx/Cone2.cxx.
class vtkMyCallback : public vtkCommand { static myCallback *New() {return new vtkMyCallback;} virtual void Execute(vtkObject *caller, unsigned long, void *) {
vtkRenderer *renderer = reinterpret_cast<vtkRenderer*>(caller); cout << renderer->GetActiveCamera()->GetPosition()[0] << " " << renderer->GetActiveCamera()->GetPosition()[1] << " " << renderer->GetActiveCamera()->GetPosition()[2] << "\n"; } };
While the Execute() method is always passed the calling object (caller) you are not required to use it. If you do use the caller you will typically want to perform a SafeDownCast() to the actual type. For example:
virtual void Execute(vtkObject *caller, unsigned long, void *callData) {
vtkRenderer *ren = vtkRenderer::SafeDownCast(caller); if (ren) { ren->SetBackground(0.2,0.3,0.4); } }
Once you have created your subclass of vtkCommand you are ready to add an observer that will call your command on certain events. This can be done as follows.


36 System Overview
// Here is where we setup the observer, //we do a new and ren1 will eventually free the observer vtkMyCallback *mo1 = vtkMyCallback::New(); ren1->AddObserver(vtkCommand::StartEvent,mo1); mo1->Delete();
The above code creates an instance of myCallback and then adds an observer on ren1 for the StartEvent. Whenever ren1 starts to render, the Execute() method of vtkMyCallback will be called. When ren1 is deleted, the callback will be deleted as well.
Java
To create Java applications you must first have a working Java development environment. This section provides instructions for using Sun's JDK 1.3 or later on either Windows or UNIX. Once your JDK has been installed and you have installed VTK, you need to set your CLASSPATH environment variable to include the VTK classes. Under Microsoft Windows this can be set by right clicking on the My Computer icon, selecting the properties option, then selecting the Advanced tab, and then clicking the Environment Variables button. Then add a CLASSPATH environment variable and set it to include your the path to your vtk.jar file, your Wrapping/Java directory, and the current directory. For a Windows build it will be something like "C:\vtk-bin\bin\vtk.jar;C:\vtkbin\Wrapping\Java;.". Under UNIX you should set your CLASSPATH environment variable to something similar to "/yourdisk/vtk-bin/bin/vtk.jar;/yourdisk/vtk-bin/Wrapping/ Java;.".
The next step is to byte compile your Java program. For starters try byte compiling (with javac) the Cone.java example that comes with VTK under VTK/Examples/Tutorial/Step1/Java. Then you should be able to run the resulting application using the java command. It should display a cone which rotates 360 degrees and then exits. The next step is to create your own applications using the examples provided as a starting point.
public void myCallback() {
System.out.println("Starting a render"); }
You set up a callback by passing three arguments. The first is the name of the event you are interested in, the second is an instance of a class, the third is the name of the method you want to invoke. In this example we set up the StartEvent to invoke the myCallback method on me (which is an instance of Cone2). The myCallback method must of course be a valid method of Cone2 to avoid an error. (This code fragment is from VTK/Examples/Tutorial/Step2/Java/cone2.java.)
Cone2 me = new Cone2(); ren1.AddObserver("StartEvent",me,"myCallback");
Python
If you have built VTK with Python support, a vtkpython executable will be created. Using this executable, you should be able to run Examples/Tutorial/Step1/Python/Cone.py as follows.


3.3 Conversion Between Languages 37
vtkpython Cone.py
Creating your own Python scripts is a simple matter of using some of our example scripts as a starting point. User methods can be set up by defining a function and then passing it as the argument to the AddObserver as shown below.
def myCallback(obj,event): print "Starting to render" ren1.AddObserver("StartEvent",myCallback)
The complete source code for the example shown above is in VTK/Examples/Tutorial/Step2/ Python/Cone2.py.
3.3 Conversion Between Languages
As we have seen, VTK’s core is implemented in C++ and then wrapped with the Tcl, Java, and Python programming languages. This means that you have a language choice when developing applications. Your choice will depend on which language you are most comfortable with, the nature of the application, and whether you need access to internal data structures and/or have special performance requirements. C++ offers several advantages over the other languages when you need to access internal data structure or require the highest-performing application possible. However, using C++ means the extra burden of the compile/link cycle, which often slows the software development process. You may find yourself developing prototypes in an interpreted language such as Tcl and then converting them to C++. Or, you may discover example code (in the VTK distribution or from other users) that you wish to convert to your implementation language. Converting VTK code from one language to another is fairly straightforward. Class names and method names remain the same across languages; what changes are the implementation details and GUI interface, if any. For example, the C++ statement
anActor->GetProperty()->SetColor(red,green,blue);
in Tcl becomes
[anActor GetProperty] SetColor $red $green $blue
in Java becomes
anActor.GetProperty().SetColor(red,green,blue);
and in Python becomes
anActor.GetProperty().SetColor(red,green,blue)
One major limitation you’ll find is that some C++ applications cannot be converted to the other three languages because of pointer manipulation.While it is always possible to get and set individual values from the wrapped languages, it is not always possible to obtain a raw pointer to quickly traverse and inspect or modify a large structure. If your application requires this level of data inspection or manipulation, you can either develop directly in C++ or extend VTK at the C++ level with your required high-performance classes, then use these new classes from your preferred interpreted language.




Part II
Learn VTK By Example




Chapter 4
The Basics 4
T
he purpose of this chapter is to introduce you to some of
VTK’s capabilities by way of a selected set of examples. Our focus will be on commonly used meth
ods and objects, and combinations of objects. We will also introduce important concepts and useful
applications. By no means are all of VTK’s features covered; this chapter is meant to give you a
broad overview of what’s possible. You’ll want to refer to online documentation or class .h files to
learn about other options each class might have.
Most of the examples included here are implemented in the Tcl programming language. They
could just as easily be implemented in C++, Java, and Python—the conversion process between the
languages is straightforward. (See “Conversion Between Languages” on page 37.) C++ does offer
some advantages, mainly access and manipulation of data structures and pointers, and some examples
reflect this by being implemented in the C++ language.
Each example presented here includes sample code and often a supplemental image. We indi
cate the name of the source code file (when one exists in the VTK source tree), so you will not have
to enter it manually. We recommend that you run and understand the example and then experiment
with object methods and parameters. You may also wish to try suggested alternative methods and/or
classes. Often, the Visualization Toolkit offers several approaches to achieve similar results. Note also
that the scripts are often modified from what’s found in the source code distribution. This is done to
simplify concepts or remove extraneous code.
Learning an object-oriented system like VTK first requires understanding the programming
abstraction, and then becoming familiar with the library of objects and their methods. We recommend
that you review “System Architecture” on page 19 for information about the programming abstrac
tion. The examples in this chapter will then provide you with a good overview of the many VTK
objects.


42 The Basics
4.1 Creating Simple Models
The use of the Visualization Toolkit typically goes as follows: read/generate some data, filter it, render it, and interact with it. In this section, we’ll start by looking at ways to read and generate data. There are two basic ways to obtain data. The data may exist in a file (or files, streams, etc.) that is read into the system, or the data may be procedurally generated (via an algorithm or mathematical expression). Recall that objects that initiate the processing of data in the visualization pipeline are called source objects (see Figure 3–5). Objects that generate data are called procedural (source) objects, and objects that read data are called reader (source) objects.
Procedural Source Object
We’ll start off by rendering a simple cylinder. The example code shown below (VTK/Examples/ Rendering/Tcl/Cylinder.tcl) demonstrates many basic concepts in the visualization pipeline and rendering engine. Refer to Figure 4–1 to see the results of running the script. We begin the script by invoking a Tcl command to load the VTK package (package require vtk) and create a GUI interpreter (package require vtkinteraction) that lets you type commands at run-time. Also, we load vtktesting which defines a set of colors, one of which (tomato) is used later in the script.
package require vtk package require vtkinteraction package require vtktesting
We then create a procedural source object: vtkCylinderSource. This source creates a polygonal representation of a cylinder. The output of the cylinder is set as the input to the vtkPolyDataMapper via the method SetInputConnection(). We create an actor (the object that is rendered) that refers to the mapper as its defining geometry. Notice the way objects are constructed in Tcl: we use the class name followed by the desired instance name.
vtkCylinderSource cylinder cylinder SetResolution 8 vtkPolyDataMapper cylinderMapper cylinderMapper SetInputConnection [cylinder GetOutputPort] vtkActor cylinderActor cylinderActor SetMapper cylinderMapper eval [cylinderActor GetProperty] SetColor $tomato cylinderActor RotateX 30.0
Figure 4–1 Using Tcl/Tk to program an interpreted application.


4.1 Creating Simple Models 43
cylinderActor RotateY -45.0
As a reminder of how similar a C++ implementation is to a Tcl (or other interpreted languages) implementation, the same code implemented in C++ is shown below, and can be found in VTK/Examples/ Rendering/Cxx/Cylinder.cxx.
vtkCylinderSource *cylinder = vtkCylinderSource::New(); cylinder->SetResolution(8);
vtkPolyDataMapper *cylinderMapper = vtkPolyDataMapper::New(); cylinderMapper->SetInputConnection(cylinder->GetOutputPort());
vtkActor *cylinderActor = vtkActor::New(); cylinderActor->SetMapper(cylinderMapper); cylinderActor->GetProperty()->SetColor(1.0000, 0.3882, 0.2784); cylinderActor->RotateX(30.0); cylinderActor->RotateY(-45.0);
Recall that source objects initiate the visualization pipeline, and mapper objects (or prop objects that include mapping functionality) terminate the pipeline, so in this example we have a pipeline consisting of two algorithms (i.e., a source and mapper). The VTK pipeline uses a lazy evaluation scheme, so even though the pipeline is connected, no generation or processing of data has yet occurred (since we have not yet requested the data). Next we create graphics objects which will allow us to render the actor. The vtkRenderer instance ren1 coordinates the rendering process for a viewport of the render window renWin. The render window interactor iren is a 3D widget that allows us to manipulate the camera.
#Create the graphics structure vtkRenderer ren1 vtkRenderWindow renWin renWin AddRenderer ren1 vtkRenderWindowInteractor iren iren SetRenderWindow renWin
Notice that we’ve associated the renderer with the render window via the AddRenderer() method. We must also associate the actor with the renderer using the AddActor() method.
# Add the actors to the renderer, set the background and size ren1 AddActor cylinderActor ren1 SetBackground 0.1 0.2 0.4 renWin SetSize 200 200
The SetBackground() method specifies the background color of the rendering window using RGB (red, green, blue) values between (0,1), and SetSize() specifies the window size in pixels. Finally, we conclude this example by associating the GUI interactor with the render window interactor’s userdefined method. (The user-defined method is invoked by pressing the u key when the mouse focus is in the rendering window. See “Using VTK Interactors” on page 45. Also see “User Methods, Observers, and Commands” on page 29) The Initialize() method begins the event loop, and the Tcl/Tk com


44 The Basics
mand wm withdraw . makes sure that the interpreter widget .vtkInteract is not visible when the application starts.
# Associate the “u” keypress with a UserEvent and start the event loop iren AddObserver UserEvent {wm deiconify .vtkInteract} iren Initialize
# suppress the tk window wm withdraw .
When the script is run, the visualization pipeline will execute because the rendering engine will request data. (The window expose event will force the render window to render itself.) Only after the pipeline executes are the filters up-to-date with respect to the input data. If you desire, you can manually cause execution of the pipeline by invoking renWin Render. After you get this example running, you might try a couple of things. First, use the interactor by mousing in the rendering window. Next, change the resolution of the cylinder object by invoking the cylinder SetResolution 12. You can do this by editing the example file and re-executing it, or by pressing u in the rendering window to bring up the interpreter GUI and typing the command there. Remember, if you are using the Tcl interactor popup, the changes you make are visible only after data is requested, so follow changes with a renWin Render command, or by mousing in the rendering window.
Reader Source Object
This example is similar to the previous example except that we read a data file rather than procedurally generating the data. A stereo-lithography file is read (suffix .stl) that represents polygonal data using the binary STL data format. (Refer to Figure 4–2 and the Tcl script VTK/Examples/Rendering/ Tcl/CADPart.tcl.)
vtkSTLReader part part SetFileName \ $VTK_DATA_ROOT/Data/42400-IDGH.stl vtkPolyDataMapper partMapper partMapper SetInputConnection \ [part GetOutputPort] vtkLODActor partActor partActor SetMapper partMapper
Notice the use of the vtkLODActor. This actor changes its representation to maintain interactive performance. Its default behavior is to create a point cloud and wireframe, bounding-box outline to represent the intermediate and low-level representations. (See “Level-Of-Detail Actors” on page 55 for more information.) The model used in this example is small enough that on most computers today you will only see the high-level representation (the full geometry of the model). Many of the readers do not sense when the input file(s) change and re-execute. For example, if the file 42400-IDGH.stl changes, the pipeline will not re-execute. You can manually modify objects by invoking the Modified() method on them. This will cause the filter to re-execute, as well as all filters downstream of it.
Figure 4–2 Reader source object.


4.2 Using VTK Interactors 45
The Visualization Toolkit has limited, built-in modeling capabilities. If you want to use VTK to edit and manipulate complex models (e.g., those created by a solid modeler or modeling tool), you’ll typically use a reader (see “Readers” on page 239) to interface to the data. (Another option is importers, which are used to ingest entire scenes. See “Importers” on page 245 for more information.)
4.2 Using VTK Interactors
Once you’ve visualized your data, you typically want to interact with it. The Visualization Toolkit offers several approaches to do this. The first approach is to use the built in class vtkRenderWindowInteractor. The second approach is to create your own interactor by specifying event bindings. And don’t forget that if you are using an interpreted language you can type commands at run-time. You may also wish to refer to “Picking” on page 59 to see how to select data from the screen. (Note: Developers can also interface to a windowing system of their choice. See “Integrating With The Windowing System” on page 421.)
vtkRenderWindowInteractor
The simplest way to interact with your data is to instantiate vtkRenderWindowInteractor. This class responds to a pre-defined set of events and actions and provides a way to override the default actions. vtkRenderWindowInteractor allows you to control the camera and actors and offers two interaction styles: position sensitive (i.e., joystick mode) and motion sensitive (i.e., trackball mode). (More about interactor styles in the next section.) vtkRenderWindowInteractor responds to the following events in the render window. (Remember that multiple renderers can draw into a rendering window and that the renderer draws into a viewport within the render window. Interactors support multiple renderers in a render window.)
• Keypress j / Keypress t — Toggle between joystick (position sensitive) and trackball (motion sensitive) styles. In joystick style, motion occurs continuously as long as a mouse button is pressed. In trackball style, motion occurs when the mouse button is pressed and the mouse pointer moves.
• Keypress c / Keypress a — Toggle between camera and actor (object) modes. In camera mode, mouse events affect the camera position and focal point. In object mode, mouse events affect the actor that is under the mouse pointer.
• Button 1 — Rotate the camera around its focal point (if camera mode) or rotate the actor around its origin (if actor mode). The rotation is in the direction defined from the center of the renderer’s viewport towards the mouse position. In joystick mode, the magnitude of the rotation is determined by the distance between the mouse and the center of the render window.
• Button 2 — Pan the camera (if camera mode) or translate the actor (if object mode). In joystick mode, the direction of pan or translation is from the center of the viewport towards the mouse position. In trackball mode, the direction of motion is the direction the mouse moves. (Note: With a 2-button mouse, pan is defined as <Shift>-Button 1.)
• Button 3 — Zoom the camera (if camera mode), or scale the actor (if object mode). Zoom in/ increase scale if the mouse position is in the top half of the viewport; zoom out/decrease scale if the mouse position is in the bottom half. In joystick mode, the amount of zoom is controlled by the distance of the mouse pointer from the horizontal centerline of the window.


46 The Basics
• Keypress 3 — Toggle the render window into and out of stereo mode. By default, red-blue stereo pairs are created. Some systems support Crystal Eyes LCD stereo glasses; you have to invoke SetStereoTypeToCrystalEyes() on the rendering window.
• Keypress e/q — Exit or quit the application.
• Keypress f — Fly-to the point under the cursor. This sets the focal point and allows rotations around that point.
• Keypress p — Perform a pick operation. The render window interactor has an internal instance of vtkPropPicker that it uses to pick. See “Picking” on page 59 for more information about picking.
• Keypress r — Reset the camera view along the current view direction. Centers the actors and moves the camera so that all actors are visible.
• Keypress s — Modify the representation of all actors so that they are surfaces.
• Keypress u — Invoke the user-defined method. Typically, this keypress will bring up an interactor that you can type commands into.
• Keypress w — Modify the representation of all actors so that they are wireframe.
The default interaction style is position sensitive (i.e., joystick style)—that is, it manipulates the camera or actor and renders continuously as long as a mouse button is pressed. If you don’t like the default behavior, you can change it or write your own. (See “vtkRenderWindow Interaction Style” on page 421 for information about writing your own style.) vtkRenderWindowInteractor has other useful features. Invoking LightFollowCameraOn() (the default behavior) causes the light position and focal point to be synchronized with the camera position and focal point (i.e., a “headlight” is created). Of course, this can be turned off with LightFollowCameraOff(). A callback that responds to the “u” keypress can be added with “AddObserver(UserEvent) method. It is also possible to set several pick-related methods. AddObserver(StartPickEvent) defines a method to be called prior to picking, and AddObserver(EndPickEvent) defines a method after the pick has been performed. (Please see “User Methods, Observers, and Commands” on page 29 for more information on defining user methods.) You can also specify an instance of a subclass of vtkAbstractPicker to use via the SetPicker() method. (See “Picking” on page 59.) If you are using a prop that adjusts rendering quality based on desired interactivity, you may wish to set the desired frame rate via SetDesiredUpdateRate() in the interactor. Normally, this is handled automatically. (When the mouse buttons are activated, the desired update rate is increased; when the mouse button is released, the desired update rate is set back down.) Refer to “Level-Of-Detail Actors” on page 55, the “vtkLODProp3D” on page 57, and the chapter on “Volume Rendering” on page 139 for further information on how props and their associated mappers may adjust render style to achieve a desired frame rate.. We’ve seen how to use vtkRenderWindowInteractor previously, here’s a recapitulation.
vtkRenderWindowInteractor iren iren SetRenderWindow renWin iren AddObserver UserEvent {wm deiconify .vtkInteract}
Interactor Styles
There are two distinctly different ways to control interaction style in VTK. The first is to use a subclass of vtkInteractorStyle, either one supplied with the system or one that you write. The second


4.2 Using VTK Interactors 47
method is to add observers that watch for events on the vtkRenderWindowInteractor and define your own set of callbacks (or commands) to implement the style. (Note: 3D widgets are another, more complex way to interact with data in the scene. See “3D Widgets” on page 72 for more information.)
vtkInteractorStyle. The class vtkRenderWindowInteractor can support different interaction styles. When you type “t” or “j” in the interactor (see the previous section) you are changing between trackball and joystick interaction styles. The way this works is that vtkRenderWindowInteractor translates window-system-specific events it receives (e.g., mouse button press, mouse motion, keyboard events) to VTK events such as MouseMoveEvent, StartEvent, and so on. (See “User Methods, Observers, and Commands” on page 29 for related information.) Different styles then observe particular events and perform the action(s) appropriate to the event. To set the style, use the vtkRenderWindowInteractor::SetInteractorStyle() method. For example:
vtkInteractorStyleFlight flightStyle vtkRenderWindowInteractor iren iren SetInteractorStyle flightStyle
(Note: When vtkRenderWindowInteractor is instantiated, a window-system specific render window interactor is actually instantiated. For example, on Unix systems the class vtkXRenderWindowInteractor is actually created and returned as an instance of vtkRenderWindowInteractor. On Windows, the class vtkWin32RenderWindowInteractor is instantiated.)
Adding vtkRenderWindowInteractor Observers. While a variety of interactor styles are available in VTK, you may prefer to create your own custom style to meet the needs of a particular application. In C++ the natural approach is to subclass vtkInteractorStyle. (See “vtkRenderWindow Interaction Style” on page 421.) However, in an interpreted language (e.g., Tcl, Python, or Java), this is difficult to do. For interpreted languages the simplest approach is to use observers to define particular interaction bindings. (See “User Methods, Observers, and Commands” on page 29.) The bindings can be managed in any language that VTK supports, including C++, Tcl, Python, and Java. An example of this is found in the Tcl code VTK/Examples/GUI/Tcl/CustomInteraction.tcl, which defines bindings for a simple Tcl application. Here’s an excerpt to give you an idea of what’s going on.
vtkRenderWindowInteractor iren iren SetInteractorStyle "" iren SetRenderWindow renWin
# Add the observers to watch for particular events. These invoke # Tcl procedures.
set Rotating 0 set Panning 0 set Zooming 0
iren AddObserver LeftButtonPressEvent {global Rotating; set Rotating 1} iren AddObserver LeftButtonReleaseEvent \ {global Rotating; set Rotating 0} iren AddObserver MiddleButtonPressEvent {global Panning; set Panning 1} iren AddObserver MiddleButtonReleaseEvent \ {global Panning; set Panning 0}


48 The Basics
iren AddObserver RightButtonPressEvent {global Zooming; set Zooming 1} iren AddObserver RightButtonReleaseEvent {global Zooming; set Zooming 0} iren AddObserver MouseMoveEvent MouseMove iren AddObserver KeyPressEvent Keypress
proc MouseMove {} { ... set xypos [iren GetEventPosition] set x [lindex $xypos 0] set y [lindex $xypos 1] ... }
proc Keypress {} { set key [iren GetKeySym] if { $key == "e" } { vtkCommand DeleteAllObjects exit }
... }
Note that a key step in this example is disabling the default interaction style by invoking SetInteractionStyle(““). Observers are then added to watch for particular events which are tied to the appropriate Tcl procedures. This example is a simple way to add bindings from a Tcl script. If you would like to create a full GUI using Tcl/Tk, then use the vtkTkRenderWidget, and refer to “Tcl/Tk” on page 433 for more details.
4.3 Filtering Data
The previous example pipelines consisted of a source and mapper object; the pipeline had no filters. In this section we show how to add a filter into the pipeline. Filters are connected by using the SetInputConnection() and GetOutputPort() methods. For example, we can modify the script in “Reader Source Object” on page 44 to shrink the polygons that make up the model. The script is shown below. (Only the pipeline and other pertinent objects are shown.) The complete script can be found at
VTK/Examples/Rendering/Tcl/FilterCADPart.tcl.
vtkSTLReader part part SetFileName \ “$VTK_DATA_ROOT/Data/42400-IDGH.stl” vtkShrinkPolyData shrink shrink SetInputConnection [part GetOutputPort] shrink SetShrinkFactor 0.85


4.4 Controlling The Camera 49
vtkPolyDataMapper partMapper partMapper SetInputConnection \ [shrink GetOutputPort] vtkLODActor partActor partActor SetMapper partMapper
As you can see, creating a visualization pipeline is simple. You need to select the right classes for the task at hand, make sure that the input and output type of connected filters are compatible, and set the necessary instance variables. (Input and output types are compatible when the output dataset type of a source or filter is acceptable as input to the next filter or mapper in the pipeline. The output dataset type must either match the input dataset type exactly or be a subclass of it.) Visualization pipelines can contain loops, but the output of a filter cannot be directly connected to its input.
4.4 Controlling The Camera
You may have noticed that in the proceeding scripts no cameras or lights were instantiated. If you’re familiar with 3D graphics, you know that lights and cameras are necessary to render objects. In VTK, if lights and cameras are not directly created, the renderer automatically instantiates them.
Instantiating The Camera
The following Tcl script shows how to instantiate and associate a camera with a renderer.
vtkCamera cam1 cam1 SetClippingRange 0.0475572 2.37786 cam1 SetFocalPoint 0.052665 -0.129454 -0.0573973 cam1 SetPosition 0.327637 -0.116299 -0.256418 cam1 ComputeViewPlaneNormal cam1 SetViewUp -0.0225386 0.999137 0.034901 ren1 SetActiveCamera cam1
Alternatively, if you wish to access a camera that already exists (for example, a camera that the renderer has automatically instantiated), in Tcl you would use
set cam1 [ren1 GetActiveCamera] $cam1 Zoom 1.4
Let’s review some of the camera methods that we’ve just introduced. SetClippingPlane() takes two arguments, the distance to the near and far clipping planes along the view plane normal. Recall that all graphics primitives not between these planes are eliminated during rendering, so you need to make sure the objects you want to see lie between the clipping planes. The FocalPoint and Position (in world coordinates) instance variables control the direction and position of the camera. ComputeViewPlaneNormal() resets the normal to the view plane based on the current position and focal point. (If the view plane normal is not perpendicular to the view plane you can get some inter
Figure 4–3 Filtering data. Here we use a filter to shrink the polygons forming the model towards their centroid.


50 The Basics
esting shearing effects.) Setting the ViewUp controls the “up” direction for the camera. Finally, the Zoom() method magnifies objects by changing the view angle (i.e., SetViewAngle()). You can also use the Dolly() method to move the camera in and out along the view plane normal to either enlarge or shrink the visible actors.
Simple Manipulation Methods
The methods described above are not always the most convenient ones for controlling the camera. If the camera is “looking at” the point you want (i.e., the focal point is set), you can use the Azimuth() and Elevation() methods to move the camera about the focal point.
cam1 Azimuth 150 cam1 Elevation 60
These methods move the camera in a spherical coordinate system centered at the focal point by moving in the longitude direction (azimuth) and the latitude direction (elevation) by the angle (in degrees) given. These methods do not modify the view-up vector and depend on the view-up vector remaining constant. Note that there are singularities at the north and south poles — the view-up vector becomes parallel with the view plane normal. To avoid this, you can force the view-up vector to be orthogonal to the view vector by using OrthogonalizeViewUp(). However, this changes the camera coordinate system, so if you’re flying around an object with a natural horizon or view-up vector (such as terrain), camera manipulation is no longer natural with respect to the data.
Controlling The View Direction
A common function of the camera is to generate a view from a particular direction. You can do this by invoking SetFocalPoint(), SetPosition(), and ComputeViewPlaneNormal() followed by invoking ResetCamera() on the renderer associated with the camera.
vtkCamera cam1 cam1 SetFocalPoint 0 0 0 cam1 SetPosition 1 1 1 cam1 ComputeViewPlaneNormal cam1 SetViewUp 1 0 0 cam1 OrthogonalizeViewUp ren1 SetActiveCamera cam1 ren1 ResetCamera
The initial direction (view vector or view plane normal) is computed from the focal point and position of the camera, which, together with ComputeViewPlaneNormal(), defines the initial view vector. Optionally, you can specify an initial view-up vector and orthogonalize it with respect to the view vector. The ResetCamera() method then moves the camera along the view vector so that the renderer’s actors are all visible to the camera.
Perspective Versus Orthogonal Views
In the previous examples, we have assumed that the camera is a perspective camera where a view angle controls the projection of the actors onto the view plane during the rendering process. Perspective projection, while generating more natural looking images, introduces distortion that can be unde


4.5 Controlling Lights 51
sirable in some applications. Orthogonal (or parallel) projection is an alternative projection method. In orthogonal projection, view rays are parallel, and objects are rendered without distance effects. To set the camera to use orthogonal projection, use the vtkCamera::ParallelProjectionOn() method. In parallel projection mode, the camera view angle no longer controls zoom. Instead, use the SetParallelScale() method to control the magnification of the actors.
Saving/Restoring Camera State
Another common requirement of applications is the capability to save and restore camera state (i.e., recover a view). To save camera state, you’ll need to save (at a minimum) the clipping range, the focal point and position, and the view-up vector. You’ll also want to compute the view plane normal (as shown in the example in “Instantiating The Camera” on page 49). Then, to recover camera state, simply instantiate a camera with the saved information, and assign it to the appropriate renderer (i.e., SetActiveCamera()). In some cases you may need to store additional information. For example, if the camera view angle (or parallel scale) is set, you’ll need to save this. Or, if you are using the camera for stereo viewing, the EyeAngle and Stereo flags are required.
4.5 Controlling Lights
Lights are easier to control than cameras. The most frequently used methods are SetPosition(), SetFocalPoint(), and SetColor(). The position and focal point of the light control the direction in which the light points. The color of the light is expressed as an RGB vector. Also, lights can be turned on and off via the SwitchOn() and SwitchOff() methods, and the brightness of the light can be set with the SetIntensity() method. By default, instances of vtkLight are directional lights. That is, the position and focal point define a vector parallel to which light rays travel, and the light source is assumed to be located at the infinity point. This means that the lighting on an object does not change if the focal point and position are translated identically. Lights are associated with renderers as follows.
vtkLight light light SetColor 1 0 0 light SetFocalPoint [cam1 GetFocalPoint] light SetPosition [cam1 GetPosition]
ren1 AddLight light
Here we’ve created a red headlight: a light located at the camera’s (cam1’s) position and pointing towards the camera’s focal point. This is a useful trick, and is used by the interactive renderer to position the light as the camera moves. (See “Using VTK Interactors” on page 45.)
Positional Lights
It is possible to create positional (i.e., spot lights) by using the PositionalOn() method. This method is used in conjunction with the SetConeAngle() method to control the spread of the spot. A cone angle


52 The Basics
of 180 degrees indicates that no spot light effects will be applied (i.e., no truncated light cone), only the effects of position.
4.6 Controlling 3D Props
Objects in VTK that are to be drawn in the render window are generically known as “props.” (The word prop comes from the vocabulary of theater—a prop is something that appears on stage.) There are several different types of props including vtkProp3D and vtkActor. vtkProp3D is an abstract superclass for those types of props existing in 3D space. The class vtkActor is a type of vtkProp3D whose geometry is defined by analytic primitives such as polygons and lines.
Specifying the Position of a vtkProp3D
We have already seen how to use cameras to move around an object; alternatively, we can also hold the camera steady and transform the props. The following methods can be used to define the position of a vtkProp3D (and its subclasses).
• SetPosition(x,y,z) — Specify the position of the vtkProp3D in world coordinates.
• AddPosition(deltaX,deltaY,deltaZ) — Translate the prop by the specified amount along each of the x, y, and z axes.
• RotateX(theta), RotateY(theta), RotateZ(theta) — Rotate the prop by theta degrees around the x, y, z coordinate axes, respectively.
• SetOrientation(x,y,z) — Set the orientation of the prop by rotating about the z axis, then about the x axis, and then about the y axis.
• AddOrientation(a1,a2,a3) — Add to the current orientation of the prop.
• RotateWXYZ(theta,x,y,z) — Rotate the prop by theta degress around the x-y-z vector defined.
• SetScale(sx,sy,sz) — Scale the prop in the x, y, z axes coordinate directions.
• SetOrigin(x,y,z) — Specify the origin of the prop. The origin is the point around which rotations and scaling occur.
These methods work together in complex ways to control the resulting transformation matrix. The most important thing to remember is that the operations listed above are applied in a particular order, and the order of application dramatically affects the resulting actor position. The order used in VTK to apply these transformations is as follows:
1. Shift to Origin
2. Scale
3. Rotate Y
4. Rotate X
5. Rotate Z
6. Shift from Origin
7. Translate


4.6 Controlling 3D Props 53
The shift to and from the origin is a negative and positive translation of the Origin value, respectively. The net translation is given by the Position value of the vtkProp3D. The most confusing part of these transformations are the rotations. For example, performing an x rotation followed by a y rotation gives very different results than the operations applied in reverse order (see Figure 4–4). For more information about actor transformation, please refer to the Visualization Toolkit text. In the next section we describe a variety of vtkProp3D’s—of which the most widely used class in VTK is called vtkActor. Later on (see “Controlling vtkActor2D” on page 62) we will examine 2D props (i.e., vtkActor2D) which tend to be used for annotation and other 2D operations.
Actors
An actor is the most common type of vtkProp3D. Like other concrete subclasses of vtkProp3D, vtkActor serves to group rendering attributes such as surface properties (e.g., ambient, diffuse, and specular color), representation (e.g., surface or wireframe), texture maps, and/or a geometric definition (a mapper).
Defining Geometry. As we have seen in previous examples, the geometry of an actor is specified with the SetMapper() method:
vtkPolyDataMapper mapper mapper SetInputConnection [aFilter GetOutputPort] vtkActor anActor anActor SetMapper mapper
In this case mapper is of type vtkPolyDataMapper, which renders geometry using analytic primitives such as points, lines, polygons, and triangle strips. The mapper terminates the visualization pipeline and serves as the bridge between the visualization subsystem and the graphics subsystem.
Actor Properties. Actors refer to an instance of vtkProperty, which in turn controls the appearance of the actor. Probably the most used property is actor color, which we will describe in the next section. Other important features of the property are its representation (points, wireframe, or surface), its shading method (either flat or Gouraud shaded), the actor’s opacity (relative transparency), and the ambient, diffuse, and specular color and related coefficients. The following script shows how to set some of these instance variables.
Figure 4–4 The effects of applying rotation in different order. On the left, first an x rotation followed by a y rotation; on the right, first a y rotation followed by an x rotation.


54 The Basics
vtkActor anActor anActor SetMapper mapper [anActor GetProperty] SetOpacity 0.25 [anActor GetProperty] SetAmbient 0.5 [anActor GetProperty] SetDiffuse 0.6 [anActor GetProperty] SetSpecular 1.0 [anActor GetProperty] SetSpecularPower 10.0
Notice how we dereference the actor’s property via the GetProperty() method. Alternatively, we can create a property and assign it to the actor.
vtkProperty prop prop SetOpacity 0.25 prop SetAmbient 0.5 prop SetDiffuse 0.6 prop SetSpecular 1.0 prop SetSpecularPower 10.0 vtkActor anActor anActor SetMapper mapper anActor SetProperty prop
The advantage of the latter method is that we can control the properties of several actors by assigning each the same property.
Actor Color. Color is perhaps the most important property applied to an actor. The simplest procedure for controlling this property is the SetColor() method, used to set the red, green, and blue (RGB) values of the actor. Each value ranges from zero to one.
[anActor GetProperty] SetColor 0.1 0.2 0.4
Alternatively, you can set the ambient, diffuse, and specular colors separately.
vtkActor anActor anActor SetMapper mapper [anActor GetProperty] SetAmbientColor .1 .1 .1 [anActor GetProperty] SetDiffuseColor .1 .2 .4 [anActor GetProperty] SetSpecularColor 1 1 1
In this example we’ve set the ambient color to a dark gray, the diffuse color to a shade of blue, and the specular color to white. (Note: The SetColor() method sets the ambient, diffuse, and specular colors to the color specified.) Important: The color set in the actor’s property only takes effect if there is no scalar data available to the actor’s mapper. By default, the mapper’s input scalar data colors the actor, and the actor’s color is ignored. To ignore the scalar data, use the method ScalarVisibilityOff() as shown in the Tcl script below.
vtkPolyDataMapper planeMapper planeMapper SetInputConnection [CompPlane GetOutputPort] planeMapper ScalarVisibilityOff vtkActor planeActor


4.6 Controlling 3D Props 55
planeActor SetMapper planeMapper [planeActor GetProperty] SetRepresentationToWireframe [planeActor GetProperty] SetColor 0 0 0
Actor Transparency. Many times it is useful to adjust transparency (or opacity) of an actor. For example, if you wish to show internal organs surrounded by the skin of a patient, adjusting the transparency of the skin allows the user to see the organs in relation to the skin. Use the vtkProperty::SetOpacity() method as follows.
vtkActor popActor popActor SetMapper popMapper [popActor GetProperty] SetOpacity 0.3 [popActor GetProperty] SetColor .9 .9 .9
Please note that transparency is implemented in the rendering library using an -blending process. This process requires that polygons are rendered in the correct order. In practice, this is very difficult to achieve, especially if you have multiple transparent actors. To order polygons, you should add transparent actors to the end of renderer’s list of actors (i.e., add them last). Also, you can use the filter vtkDepthSortPolyData to sort polygons along the view vector. Please see VTK/Examples/ VisualizationAlgorithms/Tcl/DepthSort.tcl for an example using this filter. For more information on this topic see “Translucent polygonal geometry” on page 79
Miscellaneous Features. Actors have several other important features. You can control whether an actor is visible with the VisibilityOn() and VisibilityOff() methods. If you don’t want to pick an actor during a picking operation, use the PickableOff() method. (See “Picking” on page 59 for more information about picking.) Actors also have a pick event that can be invoked when they are picked. Additionally you can get the axis-aligned bounding box of actor with the GetBounds() method.
Level-Of-Detail Actors
One major problem with graphics systems is that they often become too slow for interactive use. To handle this problem, VTK uses level-of-detail actors to achieve acceptable rendering performance at the cost of lower-resolution representations. In “Reader Source Object” on page 44 we saw how to use a vtkLODActor. Basically, the simplest way to use vtkLODActor is to replace instances of vtkActor with instances of vtkLODActor. In addition, you can control the representation of the levels of detail. The default behavior of vtkLODActor is to create two additional, lower-resolution models from the original mapper. The first is a point cloud, sampled from the points defining the mapper’s input. You can control the number of points in the cloud as follows. (The default is 150 points.)
vtkLODActor dotActor dotActor SetMapper dotMapper dotActor SetNumberOfCloudPoints 1000
The lowest resolution model is a bounding box of the actor. Additional levels of detail can be added using the AddLODMapper() method. They do not have to be added in order of complexity. To control the level-of-detail selected by the actor during rendering, you can set the desired frame rate in the rendering window:
α


56 The Basics
vtkRenderWindow renWin renWin SetDesiredUpdateRate 5.0
which translates into five frames per second. The vtkLODActor will automatically select the appropriate level-of-detail to yield the requested rate. (Note: The interactor widgets such as vtkRenderWindowInteractor automatically control the desired update rate. They typically set the frame rate very low when a mouse button is released, and increase the rate when a mouse button is pressed. This gives the pleasing effect of low-resolution/high frame rate models with camera motion, and high-resolution/low frame rate when the camera stops. If you would like more control over the levels-of-detail, see “vtkLODProp3D” on page 57. vtkLODProp3D allow you to specifically set each level.)
Assemblies
Actors are often grouped in hierarchal assemblies so that the motion of one actor affects the position of other actors. For example, a robot arm might consist of an upper arm, forearm, wrist, and end effector, all connected via joints. When the upper arm rotates around the shoulder joint, we expect the rest of the arm to move with it. This behavior is implemented using assemblies, which are a type of (subclass of) vtkActor. The following script shows how it’s done (from VTK/Examples/ Rendering/Tcl/assembly.tcl).
# create four parts: a top level assembly and three primitives vtkSphereSource sphere vtkPolyDataMapper sphereMapper sphereMapper SetInputConnection [sphere GetOutputPort] vtkActor sphereActor sphereActor SetMapper sphereMapper sphereActor SetOrigin 2 1 3 sphereActor RotateY 6 sphereActor SetPosition 2.25 0 0 [sphereActor GetProperty] SetColor 1 0 1
vtkCubeSource cube vtkPolyDataMapper cubeMapper cubeMapper SetInputConnection [cube GetOutputPort] vtkActor cubeActor cubeActor SetMapper cubeMapper cubeActor SetPosition 0.0 .25 0 [cubeActor GetProperty] SetColor 0 0 1
vtkConeSource cone vtkPolyDataMapper coneMapper coneMapper SetInputConnection [cone GetOutputPort] vtkActor coneActor coneActor SetMapper coneMapper coneActor SetPosition 0 0 .25 [coneActor GetProperty] SetColor 0 1 0
vtkCylinderSource cylinder


4.6 Controlling 3D Props 57
vtkPolyDataMapper cylinderMapper CylinderMapper SetInputConnection [cylinder GetOutputPort] vtkActor cylinderActor cylinderActor SetMapper cylinderMapper [cylinderActor GetProperty] SetColor 1 0 0
vtkAssembly assembly assembly AddPart cylinderActor assembly AddPart sphereActor assembly AddPart cubeActor assembly AddPart coneActor assembly SetOrigin 5 10 15 assembly AddPosition 5 0 0 assembly RotateX 15
# Add the actors to the renderer, set the background and size ren1 AddActor assembly ren1 AddActor coneActor
Notice how we use vtkAssembly’s AddPart() method to build the hierarchies. Assemblies can be nested arbitrarily deeply as long as there are not any self-referencing cycles. Note that vtkAssembly is a subclass of vtkProp3D, so it has no notion of properties or of an associated mapper. Therefore, the leaf nodes of the vtkAssembly hierarchy must carry information about material properties (color, etc.) and any associated geometry. Actors may also be used by more than one assembly (notice how coneActor is used in the assembly and as an actor). Also, the renderer’s AddActor() method is used to associate the top level of the assembly with the renderer; those actors at lower levels in the assembly hierarchy do not need to be added to the renderer since they are recursively rendered. You may be wondering how to distinguish the use of an actor relative to its context if an actor is used in more than one assembly, or is mixed with an assembly as in the example above. (This is particularly important in activities like picking, where the user may need to know which vtkProp was picked as well as the context in which it was picked.) We address this issue along with the introduction of the class vtkAssemblyPath, which is an ordered list of vtkProps with associated transformation matrices (if any), in detail in “Picking” on page 59.
Volumes
The class vtkVolume is used for volume rendering. It is analogous to the class vtkActor. Like vtkActor, vtkVolume inherits methods from vtkProp3D to position and orient the volume. vtkVolume has an associated property object, in this case a vtkVolumeProperty. Please see “Volume Rendering” on page 116 for a thorough description of the use of vtkVolume and a description of volume rendering.
vtkLODProp3D
The vtkLODProp3D class is similar to vtkLODActor (see “Level-Of-Detail Actors” on page 55) in that it uses different representations of itself in order to achieve interactive frame rates. Unlike vtkLODActor, vtkLODProp3D supports both volume rendering and surface rendering. This means that you can use vtkLODProp3D in volume rendering applications to achieve interactive frame rates. The following example shows how to use the class.


58 The Basics
vtkLODProp3D lod set level1 [lod AddLOD volumeMapper volumeProperty2 0.0] set level2 [lod AddLOD volumeMapper volumeProperty 0.0] set level3 [lod AddLOD probeMapper_hres probeProperty 0.0] set level4 [lod AddLOD probeMapper_lres probeProperty 0.0] set level5 [lod AddLOD outlineMapper outlineProperty 0.0]
Basically, you create different mappers each corresponding to a different rendering complexity, and add the mappers to the vtkLODProp3D. The AddLOD() method accepts either volume or geometric mappers and optionally a texture map and/or property object. (There are different signatures for this method depending on what information you wish to provide.) The last value in the field is an estimated time to render. Typically you set it to zero to indicate that there is no initial estimate. The method returns an integer id that can be used to access the appropriate LOD (i.e., to select a level or delete it). vtkLODProp3D measures the time it takes to render each LOD and sorts them appropriately. Then, depending on the render window’s desired update rate, vtkLODProp3D selects the appropriate level to render. See “Using a vtkLODProp3D to Improve Performance” on page 135 for more information.
4.7 Using Texture
Texture mapping is a powerful graphics tool for creating realistic and compelling visualizations. The basic idea behind 2D texture mapping is that images can be “pasted” onto a surface during the rendering process, thereby creating richer and more detailed images. Texture mapping requires three pieces of information: a surface to apply the texture to; a texture map, which in VTK is a vtkImageData dataset (i.e., a 2D image); and texture coordinates, which control the positioning of the texture on the surface. The following example (Figure 4–5) demonstrates the use of texture mapping (see VTK/Examples/Rendering/Tcl/ TPlane.tcl). Notice that the texture map (of class vtkTexture) is associated with the actor, and the texture coordinates come from the plane (the texture coordinates are generated by vtkPlaneSource when the plane is created).
# load in the texture map vtkBMPReader bmpReader bmpReader SetFileName \ "$VTK_DATA_ROOT/Data/masonry.bmp" vtkTexture atext atext SetInputConnection [bmpReader GetOutputPort] atext InterpolateOn
# create a plane source and actor vtkPlaneSource plane vtkPolyDataMapper planeMapper planeMapper SetInputConnection [plane GetOutputPort] vtkActor planeActor planeActor SetMapper planeMapper
Figure 4–5 Texture map on plane


4.8 Picking 59
planeActor SetTexture atext
Often times texture coordinates are not available, usually because they are not generated in the pipeline. If you need to generate texture coordinates, refer to “Generate Texture Coordinates” on page 111. Although some older graphics card have limitations on the dimensions of textures (e.g. they must be a power of two and less than 1024 on a side), VTK allows arbitrarily sized textures. At run time, VTK will query the graphics system to determine its capabilities, and will automatically resample your texture to meet the card's requirements.
4.8 Picking
Picking is a common visualization task. Picking is used to select data and actors or to query underlying data values. A pick is made when a display position (i.e., pixel coordinate) is selected and used to invoke vtkAbstractPicker’s Pick() method. Depending on the type of picking class, the information returned from the pick may be as simple as an x-y-z global coordinate, or it may include cell ids, point ids, cell parametric coordinates, the instance of vtkProp that was picked, and/or assembly paths. The syntax of the pick method is as follows.
Pick(selectionX, selectionY, selectionZ, Renderer)
Notice that the pick method requires a renderer. The actors associated with the renderer are the candidates for pick selection. Also, selectionZ is typically set to 0.0—it relates to depth in the z-buffer. (In typical usage, this method is not invoked directly. Rather the user interacts with the class vtkRenderWindowInteractor which manages the pick. In this case, the user would control the picking process by assigning an instance of a picking class to the vtkRenderWindowInteractor, as we will see in a later example.) The Visualization Toolkit supports several types of pickers of varying functionality and performance. (Please see Figure 19–16 which is an illustration of the picking class hierarchy.) The class vtkAbstractPicker serves as the base class for all pickers. It defines a minimal API which allows the user to retrieve the pick position (in global coordinates) using the GetPickPosition() method. Two direct subclasses of vtkAbstractPicker exist. The first, vtkWorldPointPicker, is a fast (usually in hardware) picking class that uses the z-buffer to return the x-y-z global pick position. However, no other information (about the vtkProp that was picked, etc.) is returned. The class vtkAbstractPropPicker is another direct subclass of vtkAbstractPicker. It defines an API for pickers that can pick an instance of vtkProp. There are several convenience methods in this class to allow querying for the return type of a pick.
• GetProp() — Return the instance of vtkProp that was picked. If anything at all was picked, then this method will return a pointer to the instance of vtkProp, otherwise NULL is returned.
• GetProp3D() — If an instance of vtkProp3D was picked, return a pointer to the instance of vtkProp3D.
• GetActor2D() — If an instance of vtkActor2D was picked, return a pointer to the instance of vtkActor2D.
• GetActor() — If an instance of vtkActor was picked, return a pointer to the instance of vtkActor.


60 The Basics
• GetVolume() — If an instance of vtkVolume was picked, return a pointer to the instance of vtkVolume.
• GetAssembly() — If an instance of vtkAssembly was picked, return a pointer to the instance of vtkAssembly.
• GetPropAssembly() — If an instance of vtkPropAssembly was picked, return a pointer to the instance of vtkPropAssembly.
A word of caution about these methods. The class (and its subclass) return information about the top level of the assembly path that was picked. So if you have an assembly whose top level is of type vtkAssembly, and whose leaf node is of type vtkActor, the method GetAssembly() will return a pointer to the instance of vtkAssembly, while the GetActor() method will return a NULL pointer (i.e., no vtkActor). If you have a complex scene that includes assemblies, actors, and other types of props, the safest course to take is to use the GetProp() method to determine whether anything at all was picked, and then use GetPath(). There are three direct subclasses of vtkAbstractPropPicker. These are vtkPropPicker, vtkAreaPicker, and vtkPicker. vtkPropPicker uses hardware picking to determine the instance of vtkProp that was picked, as well as the pick position (in global coordinates). vtkPropPicker is generally faster than all other decendents of vtkAbstractPropPicker but it cannot return information detailed information about what was picked. vtkAreaPicker and its hardware picking based descendent vtkRenderedAreaPicker are similarly incapable of determining detailed information, as all three exist for the purpose of identifying entire objects that are shown on screen. The AreaPicker classes differ from all other pickers in that they can determine what lies begin an entire rectangular region of pixels on the screen instead of only what lies behind a single pixel. These classes have an AreaPick(x_min, y_min, x_max, y_max, Renderer) method that can be called in addition to the standard Pick(x,y,z, Renderer) method. If you need detailed information, for example specific cells and points or information about what lies behind an area, review the following picker explanations below. vtkPicker is a software-based picker that selects vtkProp’s based on their bounding box. Its pick method fires a ray from the camera position through the selection point and intersects the bounding box of each prop 3D; of course, more than one prop 3D may be picked. The “closest” prop 3D in terms of its bounding box intersection point along the ray is returned. (The GetProp3Ds() method can be used to get all prop 3D’s whose bounding box was intersected.) vtkPicker is fairly fast but cannot generate a single unique pick. vtkPicker has two subclasses that can be used to retrieve more detailed information about what was picked (e.g., point ids, cell ids, etc.) vtkPointPicker selects a point and returns the point id and coordinates. It operates by firing a ray from the camera position through the selection point, and projecting those points that lie within Tolerance onto the ray. The projected point closest to the camera position is selected, along with its associated actor. (Note: The instance variable Tolerance is expressed as a fraction of the renderer window’s diagonal length.) vtkPointPicker is slower than vtkPicker but faster than vtkCellPicker. It cannot always return a unique pick because of the tolerances involved. vtkCellPicker selects a cell and returns information about the intersection point (cell id, global coordinates, and parametric cell coordinates). It operates by firing a ray and intersecting all cells in each actor’s underlying geometry, determining if each intersects this ray, within a certain specified tolerance. The cell closest to the camera position along the specified ray is selected, along with its associated actor. (Note: The instance variable Tolerance is used during intersection calculation, and you may need to experiment with its value to get satisfactory behavior.) vtkCellPicker is the slowest


4.8 Picking 61
of all the pickers, but provides the most information. It will generate a unique pick within the tolerance specified. Several events are defined to interact with the pick operation. The picker invokes StartPickEvent prior to executing the pick operation. EndPickEvent is invoked after the pick operation is complete. The picker’s PickEvent and the actor’s PickEvent are invoked each time an actor is picked. (Note that no PickEvent is invoked when using vtkWorldPointPicker.)
vtkAssemblyPath
An understanding of the class vtkAssemblyPath is essential if you are to perform picking in a scene with different types of vtkProp’s, especially if the scene contains instances of vtkAssembly. vtkAssemblyPath is simply an ordered list of vtkAssemblyNode’s, where each node contains a pointer to a vtkProp, as well as an optional vtkMatrix4x4. The order of the list is important: the start of the list represents the root, or top level node in an assembly hierarchy, while the end of the list represents a leaf node in an assembly hierarchy. The ordering of the nodes also affects the associated matrix. Each matrix is a concatenation of the node’s vtkProp’s matrix with the previous matrix in the list. Thus, for a given vtkAssemblyNode, the associated vtkMatrix4x4 represents the position and orientation of the vtkProp (assuming that the vtkProp is initially untransformed).
Example
Typically, picking is automatically managed by vtkRenderWindowInteractor (see “Using VTK Interactors” on page 45 for more information about interactors). For example, when pressing the p key, vtkRenderWindowInteractor invokes a pick with its internal instance of vtkPropPicker. You can then ask the vtkRenderWindowInteractor for its picker, and gather the information you need. You can also specify a particular vtkAbstractPicker instance for vtkRenderWindowInteractor to use, as the following script illustrates. The results on a sample data set are shown in Figure 4–6. The script for this example can be found in VTK/Examples/Annotation/Tcl/annotatePick.tcl. vtkCellPicker picker picker AddObserver EndPickEvent annotatePick vtkTextMapper textMapper set tprop [textMapper GetTextProperty] $tprop SetFontFamilyToArial $tprop SetFontSize 10 $tprop BoldOn $tprop ShadowOn $tprop SetColor 1 0 0 vtkActor2D textActor textActor VisibilityOff textActor SetMapper textMapper vtkRenderWindowInteractor iren iren SetRenderWindow renWin iren SetPicker picker
proc annotatePick {} { if { [picker GetCellId] < 0 } { textActor VisibilityOff } else { set selPt [picker GetSelectionPoint]
Figure 4–6 Annotating a pick operation.


62 The Basics
set x [lindex $selPt 0] set y [lindex $selPt 1] set pickPos [picker GetPickPosition] set xp [lindex $pickPos 0] set yp [lindex $pickPos 1] set zp [lindex $pickPos 2] textMapper SetInput "($xp, $yp, $zp)" textActor SetPosition $x $y textActor VisibilityOn }
renWin Render }
picker Pick 85 126 0 ren1
This example uses a vtkTextMapper to draw the world coordinate of the pick on the screen. (See “Text Annotation” on page 63 for more information.) Notice that we register the EndPickEvent to perform setup after the pick occurs. The method is configured to invoke the annotatePick() procedure when picking is complete.
4.9 vtkCoordinate and Coordinate Systems
The Visualization Toolkit supports several different coordinate systems, and the class vtkCoordinate manages transformations between them. The supported coordinate systems are as follows.
• DISPLAY — x-y pixel values in the (rendering) window. (Note that vtkRenderWindow is a subclass of vtkWindow). The origin is the lower-left corner (which is true for all 2D coordinate systems described below).
• NORMALIZED DISPLAY — x-y (0,1) normalized values in the window.
• VIEWPORT — x-y pixel values in the viewport (or renderer — a subclass of vtkViewport)
• NORMALIZED VIEWPORT — x-y (0,1) normalized values in viewport
• VIEW — x-y-z (-1,1) values in camera coordinates (z is depth)
• WORLD — x-y-z global coordinate value
• USERDEFINED - x-y-z in user-defined space. The user must provide a transformation method for user defined coordinate systems. See vtkCoordinate for more information.
The class vtkCoordinate can be used to transform between coordinate systems and can be linked together to form “relative” or “offset” coordinate values. Refer to the next section for an example of using vtkCoordinate in an application.
4.10 Controlling vtkActor2D
vtkActor2D is analogous to vtkActor except that it draws on the overlay plane and does not have a 4x4 transformation matrix associated with it. Like vtkActor, vtkActor2D refers to a mapper (vtkMapper2D) and a property object (vtkProperty2D). The most difficult part when working with vtkActor2D is positioning it. To do that, the class vtkCoordinate is used. (See previous section, “vtk


4.11 Text Annotation 63
Coordinate and Coordinate Systems”.) The following script shows how to use the vtkCoordinate object.
vtkActor2D bannerActor bannerActor SetMapper banner [bannerActor GetProperty] SetColor 0 1 0 [bannerActor GetPositionCoordinate] SetCoordinateSystemToNormalizedDisplay [bannerActor GetPositionCoordinate] SetValue 0.5 0.5
What’s done in this script is to access the coordinate object and define it’s coordinate system. Then the appropriate value is set for that coordinate system. In this script a normalized display coordinate system is used, so display coordinates range from zero to one, and the values (0.5,0.5) are set to position the vtkActor2D in the middle of the rendering window. vtkActor2D also provides a convenience method, SetDisplayPosition(), that sets the coordinate system to DISPLAY and uses the input parameters to set the vtkActor2D’s position using pixel offsets in the render window. The example in the following section shows how the method is used.
4.11 Text Annotation
The Visualization Toolkit offers two ways to annotate images. First, text (and graphics) can be rendered on top of the underlying 3D graphics window (often referred to as rendering in the overlay plane). Second, text can be created as 3D polygonal data and transformed and displayed as any other 3D graphics object. We refer to this as 2D and 3D annotation, respectively. See Figure 4–7 to see the difference.
2DText Annotation
To use 2D text annotation, we employ 2D actors (vtkActor2D and its subclasses such as vtkScaledTextActor) and mappers (vtkMapper2D and subclasses such as vtkTextMapper). 2D actors and mappers are similar to their 3D counterparts except that they render in the overlay plane on top of underlying graphics or images. Here’s an example Tcl script found in VTK/Examples/ Annotation/Tcl/TestText.tcl; the results are shown on the left side of Figure 4–7.
vtkSphereSource sphere vtkPolyDataMapper sphereMapper sphereMapper SetInputConnection [sphere GetOutputPort]
Figure 4–7 2D (left) and 3D (right) annotation.


64 The Basics
sphereMapper GlobalImmediateModeRenderingOn vtkLODActor sphereActor sphereActor SetMapper sphereMapper
vtkTextActor textActor textActor SetTextScaleModeToProp textActor SetDisplayPosition 90 50 textActor SetInput "This is a sphere" # Specify an initial size [textActor GetPosition2Coordinate] \ SetCoordinateSystemToNormalizedViewport [textActor GetPosition2Coordinate] SetValue 0.6 0.1
set tprop [textActor GetTextProperty] $tprop SetFontSize 18 $tprop SetFontFamilyToArial $tprop SetJustificationToCentered $tprop BoldOn $tprop ItalicOn $tprop ShadowOn $tprop SetColor 0 0 1
# Create the RenderWindow, Renderer and both Actors vtkRenderer ren1 vtkRenderWindow renWin renWin AddRenderer ren1 vtkRenderWindowInteractor iren iren SetRenderWindow renWin
# Add the actors to the renderer ren1 AddViewProp textActor ren1 sphereActor
Instances of the class vtkTextProperty allow you to control font family (Arial, Courier, or Times), set text color, turn bolding and italics on and off, and apply font shadowing. (Shadowing is used to make the font more readable when placed on top of complex background images.) The position and color of the text is controlled by the associated vtkActor2D. (In this example, the position is set using display or pixel coordinates.) vtkTextProperty also supports justification (vertical and horizontal) and multi-line text. Use the methods SetJustificationToLeft(), SetJustificationToCentered(), and SetJustificationToRight() to control the horizontal justification. Use the methods SetVerticalJustificationToBottom(), SetVerticalJustificationToCentered(), and SetVerticalJustificationToTop() to control vertical justification. By default, text is left-bottom justified. To insert multi-line text, use the \n character embedded in the text. The example in Figure 4–8 demonstrates justification and multi-line text (taken from VTK/Examples/Annotation/Tcl/multiLineText.tcl). The essence of the example is shown below.
vtkTextMapper textMapperL textMapperL SetInput "This is\nmulti-line\ntext output\n(left-top)" set tprop [textMapperL GetTextProperty]


4.11 Text Annotation 65
$tprop ShallowCopy multiLineTextProp $tprop SetJustificationToLeft $tprop SetVerticalJustificationToTop $tprop SetColor 1 0 0 vtkActor2D textActorL textActorL SetMapper textMapperL [textActorL GetPositionCoordinate] \ SetCoordinateSystemToNormalizedDisplay [textActorL GetPositionCoordinate] SetValue 0.05 0.5
Note the use of the vtkCoordinate object (obtained by invoking the GetPositionCoordinate() method) to control the position of the actor in the normalized display coordinate system. See the section “vtkCoordinate and Coordinate Systems” on page 62 for more information about placing annotation.
3D Text Annotation and vtkFollower
3D text annotation is implemented using vtkVectorText to create a polygonal representation of a text string, which is then appropriately positioned in the scene. One useful class for positioning 3D text is vtkFollower. This class is a type of actor that always faces the renderer’s active camera, thereby insuring that the text is readable. This Tcl script found in VTK/Examples/Annotation/Tcl/ textOrigin.tcl shows how to do this (Figure 4–7). The example creates an axes and labels the origin using an instance of vtkVectorText in combination with a vtkFollower.
vtkAxes axes axes SetOrigin 0 0 0 vtkPolyDataMapper axesMapper axesMapper SetInputConnection [axes GetOutputPort] vtkActor axesActor axesActor SetMapper axesMapper
vtkVectorText atext atext SetText "Origin" vtkPolyDataMapper textMapper textMapper SetInputConnection [atext GetOutputPort] vtkFollower textActor textActor SetMapper textMapper textActor SetScale 0.2 0.2 0.2 textActor AddPosition 0 -0.1 0 ...etc...after rendering... textActor SetCamera [ren1 GetActiveCamera]
Figure 4–8 Justification and use of multi-line text. Use the \n character embedded in the text string to generate line breaks. Both vertical and horizontal justification is supported.


66 The Basics
As the camera moves around the axes, the follower will orient itself to face the camera. (Try this by mousing in the rendering window to move the camera.)
4.12 Special Plotting Classes
The Visualization Toolkit provides several composite classes that perform supplemental plotting operations. These include the ability to plot scalar bars, perform simple x-y plotting, and place flying axes for 3D spatial context.
Scalar Bar
The class vtkScalarBar is used to create a colorcoded key that relates color values to numerical data values as shown in Figure 4–9. There are three parts to the scalar bar: a rectangular bar with colored segments, labels, and a title. To use vtkScalarBar, you must reference an instance of vtkLookupTable (defines colors and the range of data values), position and orient the scalar bar on the overlay plane, and optionally specify attributes such as color (of the labels and the title), number of labels, and text string for the title. The following example shows typical usage.
vtkScalarBarActor scalarBar scalarBar SetLookupTable [mapper GetLookupTable] scalarBar SetTitle "Temperature" [scalarBar GetPositionCoordinate] \ SetCoordinateSystemToNormalizedViewport [scalarBar GetPositionCoordinate] SetValue 0.1 0.01 scalarBar SetOrientationToHorizontal scalarBar SetWidth 0.8 scalarBar SetHeight 0.17
The orientation of the scalar bar is controlled by the methods SetOrientationToVertical() and vtkSetOrientationToHorizontal(). To control the position of the scalar bar (i.e., its lower-left corner), set the position coordinate (in whatever coordinate system you desire—see “vtkCoordinate and Coordinate Systems” on page 62), and then specify the width and height using normalized viewport values (or alternatively, specify the Position2 instance variable to set the upper-right corner).
X-Y Plots
The class vtkXYPlotActor generates x-y plots from one or more input datasets, as shown in Figure 410. This class is particularly useful for showing the variation of data across a sequence of points such as a line probe or a boundary edge. To use vtkXYPlotActor2D, you must specify one or more input datasets, axes, and the plot title, and position the composite actor on the overlay plane. The PositionCoordinate instance variable
Figure 4–9 vtkScalarBarActor used to create color legends.


4.12 Special Plotting Classes 67
defines the location of the lower-left corner of the x-y plot (specified in normalized viewport coordinates), and the Position2Coordinate instance variable defines the upper-right corner. (Note: The Position2Coordinate is relative to PositionCoordinate, so you can move the vtkXYPlotActor around the viewport by setting just the PositionCoordinate.) The combination of the two position coordinates specifies a rectangle in which the plot will lie. The following example (from VTK/Examples/ Annotation/Tcl/xyPlot.tcl) shows how the class is used.
vtkXYPlotActor xyplot xyplot AddInput [probe GetOutput] xyplot AddInput [probe2 GetOutput] xyplot AddInput [probe3 GetOutput] [xyplot GetPositionCoordinate] SetValue 0.0 0.67 0 [xyplot GetPosition2Coordinate] SetValue 1.0 0.33 0 xyplot SetXValuesToArcLength xyplot SetNumberOfXLabels 6 xyplot SetTitle "Pressure vs. Arc Length (Zoomed View)" xyplot SetXTitle "" xyplot SetYTitle "P" xyplot SetXRange .1 .35 xyplot SetYRange .2 .4 [xyplot GetProperty] SetColor 0 0 0
Note the x axis definition. By default, the x coordinate is set as the point index in the input datasets. Alternatively, you can use arc length and normalized arc length of lines used as input to vtkXYPlotActor to generate the x values.
Figure 4–10 Example of using the vtkXYPlotActor2D class to display three probe lines using three different techniques (see VTK/Hybrid/Testing/ Tcl/xyPlot.tcl).
Figure 4–11 Use of vtkCubeAxisActor2D. On the left, outer edges of the cube are used to draw the axes. On the right, the closest vertex to the camera is used.


68 The Basics
Bounding Box Axes (vtkCubeAxesActor2D)
Another composite actor class is vtkCubeAxesActor2D. This class can be used to indicate the position in space that the camera is viewing, as shown in Figure 4–11. The class draws axes around the bounding box of the input dataset labeled with x-y-z coordinate values. As the camera zooms in, the axes are scaled to fit within the cameras viewport, and the label values are updated. The user can control various font attributes as well as the relative font size (The font size is selected automaticallythe method SetFontFactor() can be used to affect the size of the selected font.) The following script demonstrates how to use the class (taken from VTK/Examples/Annotation/Tcl/ cubeAxes.tcl).
vtkTextProperty tprop tprop SetColor 1 1 1 tprop ShadowOn vtkCubeAxesActor2D axes axes SetInput [normals GetOutput] axes SetCamera [ren1 GetActiveCamera] axes SetLabelFormat "%6.4g" axes SetFlyModeToOuterEdges axes SetFontFactor 0.8 axes SetAxisTitleTextProperty tprop axis SetAxisLabelTextProperty tprop
Note that there are two ways that the axes can be drawn. By default, the outer edges of the bounding box are used (SetFlyModeToOuterEdges()). You can also place the axes at the vertex closest to the camera position (SetFlyModeToClosestTriad()).
Labeling Data
In some applications, you may wish to display numerical values from an underlying data set. The class vtkLabeledDataMapper allows you to label the data associated with the points of a dataset. This includes scalars, vectors, tensors, normals, texture coordinates, and field data, as well as the point ids of the dataset. The text labels are placed on the overlay plane of the rendered image as shown in Figure 4–12. The figure was generated from the Tcl script VTK/Examples/Annotation/Tcl/ labeledMesh.tcl which is included in part below. The script uses three new classes,
Figure 4–12 Labelling point and cell ids on a sphere within a rectangular window.


4.12 Special Plotting Classes 69
vtkCellCenters (to generate points at the parametric centers of cells), vtkIdFilter (to generate ids as scalar or field data from dataset ids), and vtkSelectVisiblePoints (to select those points currently visible), to label the cell and point ids of the sphere. In addition, vtkSelectVisiblePoints has the ability to define a “window” in display (pixel) coordinates in which it operates—all points outside of the window are discarded.
# Create a sphere vtkSphereSource sphere vtkPolyDataMapper sphereMapper sphereMapper SetInputConnection [sphere GetOutputPort] sphereMapper GlobalImmediateModeRenderingOn vtkActor sphereActor sphereActor SetMapper sphereMapper # Generate ids for labeling vtkIdFilter ids ids SetInputConnection [sphere GetOutputPort] ids PointIdsOn ids CellIdsOn ids FieldDataOn
vtkRenderer ren1
# Create labels for points vtkSelectVisiblePoints visPts visPts SetInputConnection [ids GetOutputPort] visPts SetRenderer ren1 visPts SelectionWindowOn visPts SetSelection $xmin [expr $xmin + $xLength] \ $ymin [expr $ymin + $yLength] vtkLabeledDataMapper ldm ldm SetInput [visPts GetOutput] ldm SetLabelFormat "%g" ldm SetLabelModeToLabelFieldData vtkActor2D pointLabels pointLabels SetMapper ldm
# Create labels for cells vtkCellCenters cc cc SetInputConnection [ids GetOutputPort] vtkSelectVisiblePoints visCells visCells SetInputConnection [cc GetOutputPort] visCells SetRenderer ren1 visCells SelectionWindowOn visCells SetSelection $xmin [expr $xmin + $xLength] \ $ymin [expr $ymin + $yLength] vtkLabeledDataMapper cellMapper cellMapper SetInputConnection [visCells GetOutputPort] cellMapper SetLabelFormat "%g" cellMapper SetLabelModeToLabelFieldData [cellMapper GetLabelTextProperty] SetColor 0 1 0 vtkActor2D cellLabels


70 The Basics
cellLabels SetMapper cellMapper
# Add the actors to the renderer, set the background and size ren1 AddActor sphereActor ren1 AddActor2D pointLabels ren1 AddActor2D cellLabels
4.13 Transforming Data
As we saw in the section “Notice how we use vtkAssembly’s AddPart() method to build the hierarchies. Assemblies can be nested arbitrarily deeply as long as there are not any self-referencing cycles. Note that vtkAssembly is a subclass of vtkProp3D, so it has no notion of properties or of an associated mapper. Therefore, the leaf nodes of the vtkAssembly hierarchy must carry information about material properties (color, etc.) and any associated geometry. Actors may also be used by more than one assembly (notice how coneActor is used in the assembly and as an actor). Also, the renderer’s AddActor() method is used to associate the top level of the assembly with the renderer; those actors at lower levels in the assembly hierarchy do not need to be added to the renderer since they are recursively rendered.” on page 57, it is possible to position and orient vtkProp3D’s in world space. However, in many applications we wish to transform the data prior to using it in the visualization pipeline. For example, to use a plane to cut (“Cutting” on page 98) or clip (“Clip Data” on page 110) an object, the plane must be positioned within the pipeline, not via the actor transformation matrix. Some objects (especially procedural source objects) can be created at a specific position and orientation in space. For example, vtkSphereSource has Center and Radius instance variables, and vtkPlaneSource has Origin, Point1, and Point2 instance variables that allow you to position the plane using three points. However, many classes do not provide this capability without moving data into a new position. In this case, you must transform the data using vtkTransformFilter or vtkTransformPolyDataFilter. vtkTransformFilter is a filter that takes vtkPointSet dataset objects as input. Datasets that are subclasses of the abstract class vtkPointSet represent points explicitly, that is, an instance of vtkPoints is used to store coordinate information. vtkTransformFilter applies a transformation matrix to the points and create a transformed points array; the rest of the dataset structure (i.e., cell topology) and attribute data (e.g., scalars, vectors, etc.) remains unchanged. vtkTransformPolyDataFilter does the same thing as vtkTransformFilter except that it is more convenient to use in a visualization pipeline containing polygonal data. The following example (taken from VTK/Examples/ DataManipulation/Tcl/marching.tcl with results shown in Figure 4–13) uses a vtkTransformPolyDataFilter to reposition a 3D text string. (See “3D Text Annotation and vtkFollower” on page 65 for more information about 3D text.)
#define the text for the labels vtkVectorText caseLabel caseLabel SetText "Case 12c - 11000101" vtkTransform aLabelTransform
Figure 4–13 Transforming data within the pipeline.


4.13 Transforming Data 71
aLabelTransform Identity aLabelTransform Translate -.2 0 1.25 aLabelTransform Scale .05 .05 .05 vtkTransformPolyDataFilter labelTransform labelTransform SetTransform aLabelTransform labelTransform SetInputConnection [caseLabel GetOutputPort] vtkPolyDataMapper labelMapper labelMapper SetInputConnection [labelTransform GetOutputPort]; vtkActor labelActor labelActor SetMapper labelMapper
Notice that vtkTransformPolyDataFilter requires that you supply it with an instance of vtkTransform. Recall that vtkTransform is used by actors to control their position and orientation in space. Instances of vtkTransform support many methods, some of the most commonly used are shown here.
• RotateX(angle) — apply rotation (angle in degrees) around the x axis
• RotateY(angle) — apply rotation around the y axis
• RotateZ(angle) — apply rotation around the z axis
• RotateWXYZ(angle,x,y,z) — apply rotation around a vector defined by x-y-z components
• Scale(x,y,z) — apply scale in the x, y, and z directions
• Translate(x,y,z) — apply translation
• Inverse() — invert the transformation matrix
• SetMatrix(m) — specify the 4x4 transformation matrix directly
• GetMatrix(m) — get the 4x4 transformation matrix
• PostMultiply() — control the order of multiplication of transformation matrices. If PostMultiply() is invoked, matrix operations are applied on the left hand side of the current matrix.
• PreMultiply() — matrix multiplications are applied on the right hand side of the current transformation matrix
The last two methods described above remind us that the order in which transformations are applied dramatically affects the resulting transformation matrix. (See “Notice how we use vtkAssembly’s AddPart() method to build the hierarchies. Assemblies can be nested arbitrarily deeply as long as there are not any self-referencing cycles. Note that vtkAssembly is a subclass of vtkProp3D, so it has no notion of properties or of an associated mapper. Therefore, the leaf nodes of the vtkAssembly hierarchy must carry information about material properties (color, etc.) and any associated geometry. Actors may also be used by more than one assembly (notice how coneActor is used in the assembly and as an actor). Also, the renderer’s AddActor() method is used to associate the top level of the assembly with the renderer; those actors at lower levels in the assembly hierarchy do not need to be added to the renderer since they are recursively rendered.” on page 57.) We recommend that you spend some time experimenting with these methods and the order of application to fully understand vtkTransform.


72 The Basics
Advanced Transformation
Advanced users may wish to use VTK’s extensive transformation hierarchy. (Much of this work was done by David Gobbi.) The hierarchy, of which the class hierarchy is shown in Figure 19–17, supports a variety of linear and non-linear transformations. A wonderful feature of the VTK transformation hierarchy is that different types of transformation can be used in a filter to give very different results. For example, the vtkTransformPolyDataFilter accepts any transform of type vtkAbstractTransform (or a subclass). This includes transformation types ranging from the linear, affine vtkTransform (represented by a 4x4 matrix) to the non-linear, warping vtkThinPlateSplineTransform, which is a complex function representing a correlation between a set of source and target landmarks.
3D Widgets
Interactor styles (see “Using VTK Interactors” on page 45) are generally used to control the camera and provide simple keypress and mouse-oriented interaction techniques. Interactor styles have no representation in the scene; that is, they cannot be “seen” or interacted with, the user must know what the mouse and key bindings are in order to use them. Certain operations, however, are greatly facilitated by the ability to operate directly on objects in the scene. For example, starting a rake of streamlines along a line is easily performed if the endpoints of the line can be interactively positioned. 3D widgets have been designed to provide this functionality. Like the class vtkInteractorStyle, 3D widgets are subclasses of vtkInteractorObserver. That is, they watch for events invoked by vtkRenderWindowInteractor. (Recall that vtkRenderWindowInteractor translates windowing-system specific events into VTK event invocations.) Unlike vtkInteractorStyle, however, 3D widgets represent themselves in the scene in various ways. Figure 4–14 illustrates some of the many 3D widgets found in VTK. The following is a list of the most important widgets currently found in VTK and a brief description of their features. Note that some of the concepts mentioned here have not yet been covered in this text. Please refer to “Interaction, Widgets and Selections” on page 255 to learn more about a particular concept and the various widgets available in VTK.
• vtkScalarBarWidget — Manage a vtkScalarBar including positioning, scaling, and orienting it. (See “Scalar Bar” on page 66 for more information about scalar bars.)
• vtkPointWidget — Position a point x-y-z location in 3D space. The widget produces a polygonal output. Point widgets are typically used for probing. (See “Probing” on page 100.)
• vtkLineWidget — Place a straight line with a specified subdivision resolution. The widget produces a polygonal output. A common use of the line widget is to probe (“Probing” on page 100) and plot data (“X-Y Plots” on page 66) or produce streamlines (“Streamlines” on page 95) or stream surfaces (“Stream Surfaces” on page 97).
• vtkPlaneWidget — Orient and position a finite plane. The plane resolution is variable, and the widget produces an implicit function and a polygonal output. The plane widget is used for probing (“Probing” on page 100) and seeding streamlines (“Streamlines” on page 95).
• vtkImplicitPlaneWidget — Orient and position an unbounded plane. The widget produces an implicit function and a polygonal output. The polygonal output is created by clipping the plane with a bounding box. The implicit plane widget is typically used for probing (“Probing” on page 100), cutting (“Cutting” on page 98), and clipping data (“Clip Data” on page 110).


4.13 Transforming Data 73
• vtkBoxWidget — Orient and position a bounding box. The widget produces an implicit function and a transformation matrix. The box widget is used to transform vtkProp3D’s and subclasses (“Transforming Data” on page 70) or to cut (“Cutting” on page 98) or clip data (“Clip Data” on page 110).
Figure 4–14 Some of the 3D widgets found in VTK.
vtkScalarBarWidget vtkPointWidget vtkLineWidget
vtkPlaneWidget vtkImplicitPlaneWidget vtkBoxWidget
vtkImagePlaneWidget vtkSphereWidget vtkSplineWidget


74 The Basics
• vtkImagePlaneWidget — Manipulate three orthogonal planes within a 3D volumetric data set. Probing of the planes to obtain data position, pixel value, and window-level is possible. The image plane widget is used to visualize volume data (“Image Processing and Visualization” on page 103).
• vtkSphereWidget — Manipulate a sphere of variable resolution. The widget produces an implicit function and a transformation matrix and enables the control of focal point and position to support such classes as vtkCamera and vtkLight. The sphere widget can be used for controlling lights and cameras (“Controlling The Camera” on page 49 and “Controlling Lights” on page 51), for clipping (“Clip Data” on page 110), and for cutting (“Cutting” on page 98).
• vtkSplineWidget — Manipulate an interpolating 3D spline (“Creating Movie Files” on page 248). The widget produces polygonal data represented by a series of line segments of specified resolution. The widget also directly manages underlying splines for each of the x-y-z coordinate values.
While each widget provides different functionality and offers a different API, 3D widgets are similar in how they are set up and used. The general procedure is as follows.
1. Instantiate the widget.
2. Specify the vtkRenderWindowInteractor to observe. The vtkRenderWindowInteractor invokes events that the widget may process.
3. Create callbacks (i.e., commands) as necessary using the Command/Observer mechanism—see “User Methods, Observers, and Commands” on page 29. The widgets invoke the events StartInteractionEvent, InteractionEvent, and EndInteractionEvent.
4. Most widgets require “placing” – positioning in the scene. This typically entails specifying an instance of vtkProp3D, a dataset, or explicitly specifying a bounding box, and then invoking the PlaceWidget() method.
5. Finally, the widget must be enabled. By default, a keypress i will enable the widget and it will appear in the scene.
Note that more than one widget can be enabled at any given time, and the widgets function fine in combination with an instance of vtkInteractorStyle. Thus mousing in the scene not on any particular widget will engage the vtkInteractorStyle, but mousing on a particular widget will engage just that widget—typically no other widget or interactor style will see the events. (One notable exception is the class vtkInteractorEventRecorder that records events and then passes them along. It can also playback events. This is a very useful class for recording sessions and testing.)


4.13 Transforming Data 75
The following example (found in VTK/Examples/ GUI/Tcl/ImplicitPlaneWidget.tcl) demonstrates how to use a 3D widget. The vtkImplicitPlaneWidget will be used to clip an object. (See “Clip Data” on page 110 for more information in clipping.) In this example the vtkProp3D to be clipped is a mace formed from a sphere and cone glyphs located at the sphere points and oriented in the direction of the sphere normals. (See “Glyphing” on page 94 for more information about glyphing.) The mace is clipped with a plane that separates it into two parts, one of which is colored green. The vtkImplicitPlaneWidget is used to control the position and orientation of the clip plane by mousing on the widget normal vector, moving the point defining the origin of the plane, or translating the plane by grabbing the widget bounding box.
vtkSphereSource sphere vtkConeSource cone vtkGlyph3D glyph glyph SetInputConnection [sphere GetOutputPort] glyph SetSourceConnection [cone GetOutputPort] glyph SetVectorModeToUseNormal glyph SetScaleModeToScaleByVector glyph SetScaleFactor 0.25
# The sphere and spikes are appended # into a single polydata. # This makes things simpler to manage. vtkAppendPolyData apd apd AddInputConnection [glyph GetOutputPort] apd AddInputConnection [sphere GetOutputPort]
vtkPolyDataMapper maceMapper maceMapper SetInputConnection [apd GetOutputPort] vtkLODActor maceActor maceActor SetMapper maceMapper maceActor VisibilityOn
# This portion of the code clips the mace with the vtkPlanes # implicit function. The clipped region is colored green. vtkPlane plane vtkClipPolyData clipper clipper SetInputConnection [apd GetOutputPort] clipper SetClipFunction plane clipper InsideOutOn
vtkPolyDataMapper selectMapper selectMapper SetInputConnection [clipper GetOutputPort]
vtkLODActor selectActor
Figure 4–15 Using the implicit plane widget (vtkImplicitPlaneWidget).


76 The Basics
selectActor SetMapper selectMapper [selectActor GetProperty] SetColor 0 1 0 selectActor VisibilityOff selectActor SetScale 1.01 1.01 1.01 vtkRenderer ren1 vtkRenderWindow renWin renWin AddRenderer ren1 vtkRenderWindowInteractor iren iren SetRenderWindow renWin
# Associate the line widget with the interactor vtkImplicitPlaneWidget planeWidget planeWidget SetInteractor iren planeWidget SetPlaceFactor 1.25 planeWidget SetInput [glyph GetOutput] planeWidget PlaceWidget planeWidget AddObserver InteractionEvent myCallback
ren1 AddActor maceActor ren1 AddActor selectActor
iren AddObserver UserEvent {wm deiconify .vtkInteract} renWin Render
# Prevent the tk window from showing up then start the event loop. wm withdraw .
proc myCallback {} { planeWidget GetPlane plane selectActor VisibilityOn }
As shown above, the implicit plane widget is instantiated and placed. The placing of the widget is with respect to a dataset. (The Tcl statement “[glyph GetOutput]” returns a vtkPolyData, a subclass of vtkDataSet.) The PlaceFactor adjusts the relative size of the widget. In this example the widget is grown 25% larger than the bounding box of the input dataset. The key to the behavior of the widget is the addition of an observer that responds to the InteractionEvent. StartInteraction and EndInteraction are typically invoked by the widget on mouse down and mouse up respectively; the InteractionEvent is invoked on mouse move. The InteractionEvent is tied to the Tcl procedure myCallback that copies the plane maintained by the widget to an instance of vtkPlane—an implicit function used to do the clipping. (See “Implicit Modeling” on page 213.) The 3D widgets are a powerful feature in VTK that can quickly add complex interaction to any application. We encourage you to explore the examples included with the VTK distribution (in Examples/GUI and Hybrid/Testing/Cxx) to see the breadth and power of their capabilities.
4.14 Antialiasing
There are two ways to enable antialiasing with VTK: per primitive type or through multisampling. Multisampling usually gives more pleasant result.


4.14 Antialiasing 77
Both antialiasing methods are controlled with the vtkRenderWindow API. When multisampling is enabled and supported by the graphics card, the per-primitive-type antialiasing flags are ignored. In both cases, the setting has to be done after the creation of a vtkRenderWindow object but before its initialization on the the screen. Note that in general, the antialiasing result differs among actual OpenGL implementations. (an OpenGL implementation is either a software implementation, like Mesa, or the combination of a graphics card and its driver)
Per-primitive type antialiasing
Three flags, one for each type of primitive, control antialiasing:
• PointSmoothing,
• LineSmoothing and
• PolygonSmoothing.
Initially, they are all disabled. Here are the 4 steps in required order to enable antialiasing on point primitives:
1. vtkRenderWindow *w=vtkRenderWindow::New();
2. w->SetMultiSamples(0);
3. w->SetPointSmoothing(1);
4. w->Render();
Here is a complete example to display the vertices of a mesh representing a sphere with point antialiasing:
#include "vtkRenderWindowInteractor.h" #include "vtkRenderWindow.h" #include "vtkRenderer.h" #include "vtkSphereSource.h" #include "vtkPolyDataMapper.h" #include "vtkProperty.h"
int main() {
Figure 4–16 Effect of antialiasing techniques on a wireframe sphere.


78 The Basics
vtkRenderWindowInteractor *i=vtkRenderWindowInteractor::New(); vtkRenderWindow *w=vtkRenderWindow::New(); i->SetRenderWindow(w);
w->SetMultiSamples(0); // no multisampling w->SetPointSmoothing(1); // point antialiasing
vtkRenderer *r=vtkRenderer::New(); w->AddRenderer(r);
vtkSphereSource *s=vtkSphereSource::New(); vtkPolyDataMapper *m=vtkPolyDataMapper::New(); m->SetInputConnection(s->GetOutputPort());
vtkActor *a=vtkActor::New(); a->SetMapper(m); vtkProperty *p=a->GetProperty(); p->SetRepresentationToPoints(); // we want to see points p->SetPointSize(2.0); // big enough to notice antialiasing p->SetLighting(0); // don't be disturb by shading r->AddActor(a);
i->Start();
s->Delete(); m->Delete(); a->Delete(); r->Delete(); w->Delete(); i->Delete(); }
The following lines are specific to point antialiasing:
w->SetPointSmoothing(1); p->SetRepresentationToPoints(); p->SetPointSize(2.0);
You can visualize line antialiasing by changing them to:
w->SetLineSmoothing(1); p->SetRepresentationToWireframe(); p->SetLineWidth(2.0);
You can visualize polygon antialiasing with simply:
w->PolygonSmoothing(1); p->SetRepresentationToSurface();


4.15 Translucent polygonal geometry 79
Multisampling
Multisampling gives better result than the previous method. Initially, multisampling is enabled. But it is only effective if the graphics card support it. Currently, VTK supports multisampling on X window only. To disable multisampling, set the MultiSamples value (initially set to 8) to 0:
1. 1 vtkRenderWindow *w=vtkRenderWindow::New();
2. 2 w->SetMultiSamples(0); // disable multisampling.
3. 3 w->Render();
Going back to the previous example, if you are using X11, just get rid of line disabling multisampling and we will see the effect of multisampling on points, lines or polygons.
4.15 Translucent polygonal geometry
Rendering the geometry as translucent is a powerful tool for visualization. It allows to "see through" the data. It can be used also to focus on a region of interest; the region of interest is rendered as opaque and the context is renderered as translucent. Rendering translucent geometry is not trivial: the final color of a pixel on the screen is the contribution of all the geometry primitives visible through the pixel. The color of the pixel is the result of blending operations between the colors of all visible primitives. Blending operations themselves are usually order-dependent (ie not commutative). Therefore, for a correct rendering, depth sorting is required. However, depth sorting has a computational cost. VTK offers three ways to render translucent polygonal geometry. Each of them is a tradeoff between correctness (quality) and cost (of depth sorting).
Fast and Incorrect. Start ignoring the previous remark about depth sorting. There is then no extra computational cost but the result on the screen is incorrect. However, depending of the application context, the result might be good enough.
Slower and Almost Correct. This method consists in using two filters. First, append all the polygonal geometry with vtkAppendPolyData. Then connect the output port of vtkAppendPolyData to the input port of vtkDepthSortPolyData. Depth sorting is performed per centroid of geometry primitives, not per pixel. For this reason it is not correct but it solves most of the ordering issues and gives a result usually good enough. Look at VTK/Hybrid/Testing/Tcl/depthSort.tcl for an example.
Very Slow and Correct. If the graphics card supports it (nVidia only), use "depth peeling". It performs per pixel sorting (better result) but it is really slow. Before the first Render, ask for alpha bits on the vtkRenderWindow:
vtkRenderWindow *w=vtkRenderWindow::New(); w->SetAlphaBitPlanes(1);
Make sure multisampling is disabled: w->SetMultiSamples(0);
On the renderer, enable depth peeling:


80 The Basics
vtkRenderer *r=vtkRenderer::New(); r->SetUseDepthPeeling(1);
Set the depth peeling parameters (the maximum number of rendering passes and the occlusion ratio). The parameters are explained in the next section.
r->SetMaximumNumberOfPeels(100); r->SetOcclusionRatio(0.1);
Render the scene:
w->Render();
Finally, you can check that the graphics card supported depth peeling:
r->GetLastRenderingUsedDepthPeeling();
Depth Peeling Parameters. In order to play with the depth peeling parameters, it is necessary to understand the algorithm itself. The algorithm peels the translucent geometry from front to back until there is no more geometry to render. The iteration loop stops either if it reaches the maximum number of iterations set by the user or if the number of pixels modified by the last peel is less than some ratio of the area of the window (this ratio is set by the user, if the ratio is set to 0.0, it means the user wants the exact result. A ratio of 0.2 will render faster than a ratio of 0.1).
OpenGL requirements. The graphics card supports depth peeling, if the following OpenGL extensions are supported:
* GL_ARB_depth_texture or OpenGL>=1.4 * GL_ARB_shadow or OpenGL>=1.4 * GL_EXT_shadow_funcs or OpenGL>=1.5 * GL_ARB_vertex_shader or OpenGL>=2.0 * GL_ARB_fragment_shader or OpenGL>=2.0 * GL_ARB_shader_objects or OpenGL>=2.0 * GL_ARB_occlusion_query or OpenGL>=1.5 * GL_ARB_multitexture or OpenGL>=1.3 * GL_ARB_texture_rectangle * GL_SGIS_texture_edge_clamp, GL_EXT_texture_edge_clamp or OpenGL>=1.2
In practice, it works with nVidia GeForce 6 series and above or with Mesa (e.g. 7.4). It does not work with ATI cards.
Example. Here a complete example that uses depth peeling (you can also look for files having DepthPeeling in their name in VTK/Rendering/Testing/Cxx).
#include "vtkRenderWindowInteractor.h" #include "vtkRenderWindow.h" #include "vtkRenderer.h" #include "vtkActor.h"
#include "vtkImageSinusoidSource.h"


4.15 Translucent polygonal geometry 81
#include "vtkImageData.h" #include "vtkImageDataGeometryFilter.h" #include "vtkDataSetSurfaceFilter.h" #include "vtkPolyDataMapper.h" #include "vtkLookupTable.h" #include "vtkCamera.h"
int main() {
vtkRenderWindowInteractor *iren=vtkRenderWindowInteractor::New(); vtkRenderWindow *renWin = vtkRenderWindow::New(); renWin->SetMultiSamples(0);
renWin->SetAlphaBitPlanes(1); iren->SetRenderWindow(renWin); renWin->Delete();
vtkRenderer *renderer = vtkRenderer::New(); renWin->AddRenderer(renderer); renderer->Delete(); renderer->SetUseDepthPeeling(1); renderer->SetMaximumNumberOfPeels(200); renderer->SetOcclusionRatio(0.1);
vtkImageSinusoidSource *imageSource=vtkImageSinusoidSource::New(); imageSource->SetWholeExtent(0,9,0,9,0,9); imageSource->SetPeriod(5); imageSource->Update();
vtkImageData *image=imageSource->GetOutput(); double range[2]; image->GetScalarRange(range);
vtkDataSetSurfaceFilter *surface=vtkDataSetSurfaceFilter::New();
surface->SetInputConnection(imageSource->GetOutputPort()); imageSource->Delete();
vtkPolyDataMapper *mapper=vtkPolyDataMapper::New(); mapper->SetInputConnection(surface->GetOutputPort()); surface->Delete();
vtkLookupTable *lut=vtkLookupTable::New(); lut->SetTableRange(range); lut->SetAlphaRange(0.5,0.5); lut->SetHueRange(0.2,0.7); lut->SetNumberOfTableValues(256); lut->Build();
mapper->SetScalarVisibility(1);


82 The Basics
mapper->SetLookupTable(lut); lut->Delete();
vtkActor *actor=vtkActor::New(); renderer->AddActor(actor); actor->Delete(); actor->SetMapper(mapper); mapper->Delete();
renderer->SetBackground(0.1,0.3,0.0); renWin->SetSize(400,400);
renWin->Render(); if(renderer->GetLastRenderingUsedDepthPeeling()) {
cout<<"depth peeling was used"<<endl; } else {
cout<<"depth peeling was not used (alpha blending instead)"<<endl; }
vtkCamera *camera=renderer->GetActiveCamera(); camera->Azimuth(-40.0); camera->Elevation(20.0); renWin->Render();
iren->Start(); }
Painter mechanism: customizing the polydata mapper. Sometimes you want full control of the steps used to render a polydata. VTK makes it possible with the use of the painter mechanism. Thanks to the factory design pattern, the following line actually creates a vtkPainterPolyDataMapper:
vtkPolyDataMapper *m=vtkPolyDataMapper::New();
You can have access to the vtkPainterPolyDataMapper API by downcasting:
vtkPainterPolyDataMapper *m2=vtkPainterPolyDataMapper::SafeDownCast(m);
This polydata mapper delegates the rendering to a vtkPainter object. SetPainter() and GetPainter() gives access to this delegate. vtkPainter itself is just an abstract API shared by concrete Painters. Each of them is responsible for one stage of the rendering. This mechanism allows to choose and combine stages. For example vtkPolygonsPainter is responsible for drawing polygons whereas vtkLightingPainter is responsible for setting lighting parameters. The combination of painters forms a chain of painters. It is a chain because each painter can delegate part of the execution of the rendering to another painter. Most of the time, you don't need to explicitly set the chain of painters: vtkDefaultPainter already set a standard chain of painters for you.


4.16 Animation 83
Writing your own painter. Writing your own painter consists essentially in writing 2 classes: an abstract subclass of vtkPainter, a concrete class with the OpenGL implementation. Let's take a look at an existing Painter: vtkLightingPainter. vtkLightingPainter derives from vtkPainter and is almost empty. The real implementation is in the concrete class vtkOpenGLLightingPainter which overrides the protected method RenderInternal(). The arguments of RenderInternal() are essentially the renderer and the actor. Implementing RenderInternal() consists in writing the actual rendering stage code and calling the next Painter in the painter chain (the "delegate") by calling this->Superclass::RenderInternal().
4.16 Animation
• Animation is important component of Visualization System, etc.
• It is possible to create simple animations by writing loops that continuously change some parameter on a filter and render. However such implementations can become complicated when multiple parameter changes are involved.
• VTK provides a framework comprising of vtkAnimationCue and vtkAnimationScene to manage animation setup and playback.
• vtkAnimationCue corresponds to an entity that changes with time e.g. position of an actor; while vtkAnimationScene represents a scene or a setup for the animation comprising of instances of vtkAnimationCue.
Animation Scene (vtkAnimationScene)
vtkAnimationScene represents a scene or a setup for the animation. An animation is generated by rendering frames in a sequence while changing some visualization parameter(s) before rendering each frame. Every frame has an animation time associated with it, which can be used to determine the frame's place in the animation. Animation time is simply a counter that continuously increases over the duration of the animation based on the play-mode. Following are important methods on a vtkAnimationScene:
SetStartTime()/SetEndTime()
These represent the start and end times of the animation scene. This is the range that the animation time covers during playback.
SetPlayMode()
This is used to control they playback mode i.e. how the animation time is changed. There are two modes available:
Sequence Mode (PLAYMODE_SEQUENCE)
In this mode, the animation time is increased by (1/frame-rate) for every frame until the EndTime is reached. Hence the number of frames rendered in a single run is fixed irrespective of how long each frame takes to render.
RealTime Mode (PLAYMODE_REALTIME)
In this mode, the animation runs for approximately (EndTime-StartTime) seconds, where the animation time at nth frame is given by (animation time and (n-1)th frame + time to render (n-1)th frame). Thus the number of frames rendered changes depending on how


84 The Basics
long each frame takes to render.
SetFrameRate()
Frame rate is the number of frames per unit time. This is used only in sequence playmode.
AddCue(), RemoveCue(), RemoveAllCue()
Methods to add/remove animation cues from the scene.
SetAnimationTime()
SetAnimationTime can be used to explicitly advance to a particular frame.
GetAnimationTime()
GetAnimationTime() can be called during playback to query the animation clock time.
Play()
Starts playing the animation.
SetLoop()
When set to True, Play() results in playing the animation in a loop.
Animation Cue (vtkAnimationCue)
vtkAnimationCue corresponds to an entity that changes in an animation. vtkAnimationCue does not know how to bring about the changes to the parameters. So the user has to either subclass vtkAnimationCue or use event observers to perform the changes as the animation progresses.
A cue has a start-time and an end-time in an animation scene. During playback, a cue is active when the scene's animation time is within the range specified the start and end times for the cue. When the cue is activated, it fires the vtkCommand::StartAnimationCueEvent. For every subsequent frame, it fires the vtkCommand::AnimationCueTickEvent until the end-time is reached when the vtkCommand::EndAnimationCueEvent is fired. Following are the important methods of vtkAnimationCue
SetTimeMode
TimeMode defines how the start and time times are specified. There are two modes available.
Relative (TIMEMODE_RELATIVE)
In this mode the animation cue times are specified relative to the start of the animation scene.
Normalized (TIMEMODE_NORMALIZED)
In this mode, the cue start and end times are always in the range [0, 1] where 0 corresponds to the start and 1 corresponds to the end of the animation scene.
SetStartTime/SetEndTime
These are used to indicate the range of animation time when this cue is active. When the TimeMode is TIMEMODE_RELATIVE, these are specified in the same unit as the animation scene start and end times and are relative to the start of the animation scene. If TimeMode is TIMEMODE_NORMALIZED, these are in the range [0, 1] where 0 corresponds to the start of the animation scene while 1 corresponds to the end of the animation scene.
GetAnimationTime()


4.16 Animation 85
This is provided for the event handler for vtkCommand::AnimationCueTickEvent. It can be used by the handler to determine how far along in the animation the current frame it. It's value depends on the TimeMode. If TimeMode is Relative, then the value will be number of time units since the cue was activated. If TimeMode is Normalized then it will be value in the range [0, 1] where 0 is the start of the cue, while 1 is the end of the cue.
GetClockTime()
This is same as the animation clock time returned by vtkAnimationScene::GetAnimationTime(). It is valid only in the event handler for vtkCommand::AnimationCueTickEvent.
GetDeltaTime()
This can be used to obtain the change in animation click time from when the previous frame was rendered, if any. Again, this is valid in only in the event handler for vtkCommand::AnimationCueTickEvent.
TickInternal(double currentime, double deltatime, double clocktime)
As mentioned earlier, one can subclasses vtkAnimationCue, instead of writing event handlers to do the animation, in which case you can override this method. The arguments correspond to the values returned by GetAnimationTime(), GetDeltaTime() and GetClockTime() respectively.
StartCueInternal(), EndCueInternal()
These methods can be overridden in subclasses to do setup and cleanup and start and end of the cue during playback. Alternatively, one can add event observers for the vtkCommand::StartAnimationCueEvent and vtkCommand::EndAnimationCueEvent to do the same.
In the following example, we create a simple animation where the StartTheta of a vtkSphereSource is varied over the length of the animation. We use normalized time mode for the animation cue in this example, so that we can change the scene times or the cue times and the code to change the StartTheta value can still remain unchanged.
class vtkCustomAnimationCue: public vtkAnimationCue {
public: static vtkCustomAnimationCue* New(); vtkTypeRevisionMacro(vtkCustomAnimationCue, vtkAnimationCue);
vtkRenderWindow *RenWin; vtkSphereSource* Sphere;
protected: vtkCustomAnimationCue() {
this->RenWin = 0; this->Sphere = 0; }
// Overridden to adjust the sphere's radius depending on the frame we // are rendering. In this animation we want to change the StartTheta


86 The Basics
// of the sphere from 0 to 180 over the length of the cue. virtual void TickInternal(double currenttime, double deltatime, double clocktime) {
double new_st = currenttime * 180; // since the cue is in normalized mode, the currentime will be in the // range [0,1], where 0 is start of the cue and 1 is end of the cue. this->Sphere->SetStartTheta(new_st); this->RenWin->Render(); }
}; vtkStandardNewMacro(vtkCustomAnimationCue); vtkCxxRevisionMacro(vtkCustomAnimationCue, "$Revision$");
int main(int argc, char *argv[]) {
// Create the graphics structure. The renderer renders into the // render window. vtkRenderer *ren1=vtkRenderer::New(); vtkRenderWindow *renWin=vtkRenderWindow::New(); renWin->SetMultiSamples(0); renWin->AddRenderer(ren1);
vtkSphereSource* sphere = vtkSphereSource::New(); vtkPolyDataMapper* mapper = vtkPolyDataMapper::New(); mapper->SetInputConnection(sphere->GetOutputPort()); vtkActor* actor = vtkActor::New(); actor->SetMapper(mapper); ren1->AddActor(actor);
ren1->ResetCamera(); renWin->Render();
// Create an Animation Scene vtkAnimationScene *scene = vtkAnimationScene::New(); scene->SetModeToSequence(); scene->SetFrameRate(30); scene->SetStartTime(0); scene->SetEndTime(60);
// Create an Animation Cue to animate the camera. vtkCustomAnimationCue *cue1 = vtkCustomAnimationCue::New(); cue1->Sphere = sphere; cue1->RenWin = renWin; cue1->SetTimeModeToNormalized(); cue1->SetStartTime(0); cue1->SetEndTime(1.0); scene->AddCue(cue1);