Springer Texts in Statistics
Gareth James · DanielaWitten · Trevor Hastie · Robert Tibshirani · Jonathan Taylor
An Introduction
to Statistical
Learning
with Applications in Python


Springer Texts in Statistics
Series Editors
R. De Veaux, Department of Mathematics and Statistics, Williams College, Williamstown, MA, USA
R. Nugent, Department of Statistics, Carnegie Mellon University, Pittsburgh, PA, USA
G. Allen, Department of Statistics, Rice University, Houston, TX, USA


Springer Texts in Statistics (STS) includes advanced textbooks from 3rd- to 4th-year undergraduate levels to 1st- to 2nd-year graduate levels. Exercise sets should be included. The series editors are currently Genevera I. Allen, Richard D. De Veaux, and Rebecca Nugent. Stephen Fienberg, George Casella, and Ingram Olkin were editors of the series for many years.


Gareth James • Daniela Witten • Trevor Hastie Robert Tibshirani • Jonathan Taylor
An Introduction to Statistical Learning
with Applications in Python


ISSN 1431-875X ISSN 2197-4136 (electronic) Springer Texts in Statistics ISBN 978-3-031-38746-3 ISBN 978-3-031-38747-0 (eBook) https://doi.org/10.1007/978-3-031-38747-0
© Springer Nature Switzerland AG 2023 This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not imply, even in the absence of a specific statement, that such names are exempt from the relevant protective laws and regulations and therefore free for general use. The publisher, the authors, and the editors are safe to assume that the advice and information in this book are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or the editors give a warranty, expressed or implied, with respect to the material contained herein or for any errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.
This Springer imprint is published by the registered company Springer Nature Switzerland AG The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland
Gareth James Daniela Witten
Emory University University of Washington
Atlanta, GA, USA Seattle, WA, USA Trevor Hastie Robert Tibshirani
Stanford University Stanford University
Stanford, CA, USA Stanford, CA, USA Jonathan Taylor
Stanford University Stanford, CA, USA
Goizueta Business School Departments of Statistics
Departments of Statistics
Department of Statistics
and Biostatistics
and Biomedical Data Science Departments of Biomedical Data Science and Statistics


To our parents:
Alison and Michael James
Chiara Nappi and Edward Witten
Valerie and Patrick Hastie
Vera and Sami Tibshirani
John and Brenda Taylor
and to our families:
Michael, Daniel, and Catherine
Tessa, Theo, Otto, and Ari
Samantha, Timothy, and Lynda
Charlie, Ryan, Julie, and Cheryl
Lee-Ann and Isobel


Preface
Statistical learning refers to a set of tools for making sense of complex datasets. In recent years, we have seen a staggering increase in the scale and scope of data collection across virtually all areas of science and industry. As a result, statistical learning has become a critical toolkit for anyone who wishes to understand data — and as more and more of today’s jobs involve data, this means that statistical learning is fast becoming a critical toolkit for everyone.
One of the first books on statistical learning — The Elements of Statistical Learning (ESL, by Hastie, Tibshirani, and Friedman) — was published in 2001, with a second edition in 2009. ESL has become a popular text not only in statistics but also in related fields. One of the reasons for ESL’s popularity is its relatively accessible style. But ESL is best-suited for individuals with advanced training in the mathematical sciences.
An Introduction to Statistical Learning, With Applications in R (ISLR) — first published in 2013, with a second edition in 2021 — arose from the clear need for a broader and less technical treatment of the key topics in statistical learning. In addition to a review of linear regression, ISLR covers many of today’s most important statistical and machine learning approaches, including resampling, sparse methods for classification and regression, generalized additive models, tree-based methods, support vector machines, deep learning, survival analysis, clustering, and multiple testing. Since it was published in 2013, ISLR has become a mainstay of undergraduate and graduate classrooms worldwide, as well as an important reference book for data scientists. One of the keys to its success has been that, beginning with Chapter 2, each chapter contains an R lab illustrating how to implement the statistical learning methods seen in that chapter, providing the reader with valuable hands-on experience. However, in recent years Python has become an increasingly popular language for data science, and there has been increasing demand for a Python
vii


viii
based alternative to ISLR. Hence, this book, An Introduction to Statistical Learning, With Applications in Python (ISLP), covers the same materials as ISLR but with labs implemented in Python — a feat accomplished by the addition of a new co-author, Jonathan Taylor. Several of the labs make use of the ISLP Python package, which we have written to facilitate carrying out the statistical learning methods covered in each chapter in Python. These labs will be useful both for Python novices, as well as experienced users. The intention behind ISLP (and ISLR) is to concentrate more on the applications of the methods and less on the mathematical details, so it is appropriate for advanced undergraduates or master’s students in statistics or related quantitative fields, or for individuals in other disciplines who wish to use statistical learning tools to analyze their data. It can be used as a textbook for a course spanning two semesters. We are grateful to these readers for providing valuable comments on the first edition of ISLR: Pallavi Basu, Alexandra Chouldechova, Patrick Danaher, Will Fithian, Luella Fu, Sam Gross, Max Grazier G’Sell, Courtney Paulson, Xinghao Qiao, Elisa Sheng, Noah Simon, Kean Ming Tan, Xin Lu Tan. We thank these readers for helpful input on the second edition of ISLR: Alan Agresti, Iain Carmichael, Yiqun Chen, Erin Craig, Daisy Ding, Lucy Gao, Ismael Lemhadri, Bryan Martin, Anna Neufeld, Geoff Tims, Carsten Voelkmann, Steve Yadlowsky, and James Zou. We are immensely grateful to Balasubramanian “Naras” Narasimhan for his assistance on both ISLR and ISLP. It has been an honor and a privilege for us to see the considerable impact that ISLR has had on the way in which statistical learning is practiced, both in and out of the academic setting. We hope that this new Python edition will continue to give today’s and tomorrow’s applied statisticians and data scientists the tools they need for success in a data-driven world.
It’s tough to make predictions, especially about the future.
-Yogi Berra
Preface


Contents
Preface vii
1 Introduction 1
2 Statistical Learning 15 2.1 What Is Statistical Learning? . . . . . . . . . . . . . . . . . 15 2.1.1 Why Estimate f ? . . . . . . . . . . . . . . . . . . . 17 2.1.2 How Do We Estimate f ? . . . . . . . . . . . . . . . 20 2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability . . . . . . . . . . . . . . 23 2.1.4 Supervised Versus Unsupervised Learning . . . . . 25 2.1.5 Regression Versus Classification Problems . . . . . 27 2.2 Assessing Model Accuracy . . . . . . . . . . . . . . . . . . 27 2.2.1 Measuring the Quality of Fit . . . . . . . . . . . . 28 2.2.2 The Bias-Variance Trade-Off . . . . . . . . . . . . . 31 2.2.3 The Classification Setting . . . . . . . . . . . . . . 34 2.3 Lab: Introduction to Python . . . . . . . . . . . . . . . . . 40 2.3.1 Getting Started . . . . . . . . . . . . . . . . . . . . 40 2.3.2 Basic Commands . . . . . . . . . . . . . . . . . . . 40 2.3.3 Introduction to Numerical Python . . . . . . . . . 42 2.3.4 Graphics . . . . . . . . . . . . . . . . . . . . . . . . 48 2.3.5 Sequences and Slice Notation . . . . . . . . . . . . 51 2.3.6 Indexing Data . . . . . . . . . . . . . . . . . . . . . 51 2.3.7 Loading Data . . . . . . . . . . . . . . . . . . . . . 55 2.3.8 For Loops . . . . . . . . . . . . . . . . . . . . . . . 59 2.3.9 Additional Graphical and Numerical Summaries . . 61 2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3 Linear Regression 69 3.1 Simple Linear Regression . . . . . . . . . . . . . . . . . . . 70 3.1.1 Estimating the Coefficients . . . . . . . . . . . . . 71 3.1.2 Assessing the Accuracy of the Coefficient Estimates . . . . . . . . . . . . . . . . . . . . . . . 72 3.1.3 Assessing the Accuracy of the Model . . . . . . . . 77 3.2 Multiple Linear Regression . . . . . . . . . . . . . . . . . . 80 3.2.1 Estimating the Regression Coefficients . . . . . . . 81
ix


x Contents
3.2.2 Some Important Questions . . . . . . . . . . . . . . 83 3.3 Other Considerations in the Regression Model . . . . . . . 91 3.3.1 Qualitative Predictors . . . . . . . . . . . . . . . . 91 3.3.2 Extensions of the Linear Model . . . . . . . . . . . 94 3.3.3 Potential Problems . . . . . . . . . . . . . . . . . . 100 3.4 The Marketing Plan . . . . . . . . . . . . . . . . . . . . . . 109 3.5 Comparison of Linear Regression with K-Nearest Neighbors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 3.6 Lab: Linear Regression . . . . . . . . . . . . . . . . . . . . 116 3.6.1 Importing packages . . . . . . . . . . . . . . . . . . 116 3.6.2 Simple Linear Regression . . . . . . . . . . . . . . . 117 3.6.3 Multiple Linear Regression . . . . . . . . . . . . . . 122 3.6.4 Multivariate Goodness of Fit . . . . . . . . . . . . 123 3.6.5 Interaction Terms . . . . . . . . . . . . . . . . . . . 124 3.6.6 Non-linear Transformations of the Predictors . . . 125 3.6.7 Qualitative Predictors . . . . . . . . . . . . . . . . 126 3.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
4 Classification 135 4.1 An Overview of Classification . . . . . . . . . . . . . . . . . 135 4.2 Why Not Linear Regression? . . . . . . . . . . . . . . . . . 136 4.3 Logistic Regression . . . . . . . . . . . . . . . . . . . . . . 138 4.3.1 The Logistic Model . . . . . . . . . . . . . . . . . . 139 4.3.2 Estimating the Regression Coefficients . . . . . . . 140 4.3.3 Making Predictions . . . . . . . . . . . . . . . . . . 141 4.3.4 Multiple Logistic Regression . . . . . . . . . . . . . 142 4.3.5 Multinomial Logistic Regression . . . . . . . . . . . 144 4.4 Generative Models for Classification . . . . . . . . . . . . . 146 4.4.1 Linear Discriminant Analysis for p = 1 . . . . . . . 147 4.4.2 Linear Discriminant Analysis for p >1 . . . . . . . 150 4.4.3 Quadratic Discriminant Analysis . . . . . . . . . . 156 4.4.4 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 158 4.5 A Comparison of Classification Methods . . . . . . . . . . 161 4.5.1 An Analytical Comparison . . . . . . . . . . . . . . 161 4.5.2 An Empirical Comparison . . . . . . . . . . . . . . 164 4.6 Generalized Linear Models . . . . . . . . . . . . . . . . . . 167 4.6.1 Linear Regression on the Bikeshare Data . . . . . . 167 4.6.2 Poisson Regression on the Bikeshare Data . . . . . 169 4.6.3 Generalized Linear Models in Greater Generality . 172 4.7 Lab: Logistic Regression, LDA, QDA, and KNN . . . . . . 173 4.7.1 The Stock Market Data . . . . . . . . . . . . . . . 173 4.7.2 Logistic Regression . . . . . . . . . . . . . . . . . . 174 4.7.3 Linear Discriminant Analysis . . . . . . . . . . . . 179 4.7.4 Quadratic Discriminant Analysis . . . . . . . . . . 181 4.7.5 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 182 4.7.6 K-Nearest Neighbors . . . . . . . . . . . . . . . . . 183 4.7.7 Linear and Poisson Regression on the Bikeshare Data188 4.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193


Contents xi
5 Resampling Methods 201 5.1 Cross-Validation . . . . . . . . . . . . . . . . . . . . . . . . 202 5.1.1 The Validation Set Approach . . . . . . . . . . . . 202 5.1.2 Leave-One-Out Cross-Validation . . . . . . . . . . 204 5.1.3 k-Fold Cross-Validation . . . . . . . . . . . . . . . 206 5.1.4 Bias-Variance Trade-Off for k-Fold Cross-Validation . . . . . . . . . . . . . . . . . . . 208 5.1.5 Cross-Validation on Classification Problems . . . . 209 5.2 The Bootstrap . . . . . . . . . . . . . . . . . . . . . . . . . 212 5.3 Lab: Cross-Validation and the Bootstrap . . . . . . . . . . 215 5.3.1 The Validation Set Approach . . . . . . . . . . . . 216 5.3.2 Cross-Validation . . . . . . . . . . . . . . . . . . . 217 5.3.3 The Bootstrap . . . . . . . . . . . . . . . . . . . . 220 5.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
6 Linear Model Selection and Regularization 229 6.1 Subset Selection . . . . . . . . . . . . . . . . . . . . . . . . 231 6.1.1 Best Subset Selection . . . . . . . . . . . . . . . . . 231 6.1.2 Stepwise Selection . . . . . . . . . . . . . . . . . . 233 6.1.3 Choosing the Optimal Model . . . . . . . . . . . . 235 6.2 Shrinkage Methods . . . . . . . . . . . . . . . . . . . . . . 240 6.2.1 Ridge Regression . . . . . . . . . . . . . . . . . . . 240 6.2.2 The Lasso . . . . . . . . . . . . . . . . . . . . . . . 244 6.2.3 Selecting the Tuning Parameter . . . . . . . . . . . 252 6.3 Dimension Reduction Methods . . . . . . . . . . . . . . . . 253 6.3.1 Principal Components Regression . . . . . . . . . . 254 6.3.2 Partial Least Squares . . . . . . . . . . . . . . . . . 260 6.4 Considerations in High Dimensions . . . . . . . . . . . . . 262 6.4.1 High-Dimensional Data . . . . . . . . . . . . . . . . 262 6.4.2 What Goes Wrong in High Dimensions? . . . . . . 263 6.4.3 Regression in High Dimensions . . . . . . . . . . . 265 6.4.4 Interpreting Results in High Dimensions . . . . . . 266 6.5 Lab: Linear Models and Regularization Methods . . . . . . 267 6.5.1 Subset Selection Methods . . . . . . . . . . . . . . 268 6.5.2 Ridge Regression and the Lasso . . . . . . . . . . . 273 6.5.3 PCR and PLS Regression . . . . . . . . . . . . . . 280 6.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
7 Moving Beyond Linearity 289 7.1 Polynomial Regression . . . . . . . . . . . . . . . . . . . . . 290 7.2 Step Functions . . . . . . . . . . . . . . . . . . . . . . . . . 292 7.3 Basis Functions . . . . . . . . . . . . . . . . . . . . . . . . 293 7.4 Regression Splines . . . . . . . . . . . . . . . . . . . . . . . 294 7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . 294 7.4.2 Constraints and Splines . . . . . . . . . . . . . . . 296 7.4.3 The Spline Basis Representation . . . . . . . . . . 296 7.4.4 Choosing the Number and Locations of the Knots . . . . . . . . . . . . . . . . . . . . . . 297 7.4.5 Comparison to Polynomial Regression . . . . . . . 299


xii Contents
7.5 Smoothing Splines . . . . . . . . . . . . . . . . . . . . . . . 300 7.5.1 An Overview of Smoothing Splines . . . . . . . . . 300 7.5.2 Choosing the Smoothing Parameter λ . . . . . . . 301 7.6 Local Regression . . . . . . . . . . . . . . . . . . . . . . . . 303 7.7 Generalized Additive Models . . . . . . . . . . . . . . . . . 305 7.7.1 GAMs for Regression Problems . . . . . . . . . . . 306 7.7.2 GAMs for Classification Problems . . . . . . . . . . 308 7.8 Lab: Non-Linear Modeling . . . . . . . . . . . . . . . . . . 309 7.8.1 Polynomial Regression and Step Functions . . . . . 310 7.8.2 Splines . . . . . . . . . . . . . . . . . . . . . . . . . 315 7.8.3 Smoothing Splines and GAMs . . . . . . . . . . . . 317 7.8.4 Local Regression . . . . . . . . . . . . . . . . . . . 324 7.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
8 Tree-Based Methods 331 8.1 The Basics of Decision Trees . . . . . . . . . . . . . . . . . 331 8.1.1 Regression Trees . . . . . . . . . . . . . . . . . . . 331 8.1.2 Classification Trees . . . . . . . . . . . . . . . . . . 337 8.1.3 Trees Versus Linear Models . . . . . . . . . . . . . 341 8.1.4 Advantages and Disadvantages of Trees . . . . . . . 341 8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees . . . . . . . . . . . . . . . . . . . . . . . . 343 8.2.1 Bagging . . . . . . . . . . . . . . . . . . . . . . . . 343 8.2.2 Random Forests . . . . . . . . . . . . . . . . . . . . 346 8.2.3 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 347 8.2.4 Bayesian Additive Regression Trees . . . . . . . . . 350 8.2.5 Summary of Tree Ensemble Methods . . . . . . . . 353 8.3 Lab: Tree-Based Methods . . . . . . . . . . . . . . . . . . . 354 8.3.1 Fitting Classification Trees . . . . . . . . . . . . . . 355 8.3.2 Fitting Regression Trees . . . . . . . . . . . . . . . 358 8.3.3 Bagging and Random Forests . . . . . . . . . . . . 360 8.3.4 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 361 8.3.5 Bayesian Additive Regression Trees . . . . . . . . . 362 8.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
9 Support Vector Machines 367 9.1 Maximal Margin Classifier . . . . . . . . . . . . . . . . . . 367 9.1.1 What Is a Hyperplane? . . . . . . . . . . . . . . . . 368 9.1.2 Classification Using a Separating Hyperplane . . . 368 9.1.3 The Maximal Margin Classifier . . . . . . . . . . . 370 9.1.4 Construction of the Maximal Margin Classifier . . 372 9.1.5 The Non-separable Case . . . . . . . . . . . . . . . 372 9.2 Support Vector Classifiers . . . . . . . . . . . . . . . . . . . 373 9.2.1 Overview of the Support Vector Classifier . . . . . 373 9.2.2 Details of the Support Vector Classifier . . . . . . . 374 9.3 Support Vector Machines . . . . . . . . . . . . . . . . . . . 377 9.3.1 Classification with Non-Linear Decision Boundaries . . . . . . . . . . . . . . . . . . . . . . 378 9.3.2 The Support Vector Machine . . . . . . . . . . . . 379


Contents xiii
9.3.3 An Application to the Heart Disease Data . . . . . 382 9.4 SVMs with More than Two Classes . . . . . . . . . . . . . 383 9.4.1 One-Versus-One Classification . . . . . . . . . . . . 384 9.4.2 One-Versus-All Classification . . . . . . . . . . . . 384 9.5 Relationship to Logistic Regression . . . . . . . . . . . . . 384 9.6 Lab: Support Vector Machines . . . . . . . . . . . . . . . . 387 9.6.1 Support Vector Classifier . . . . . . . . . . . . . . . 387 9.6.2 Support Vector Machine . . . . . . . . . . . . . . . 390 9.6.3 ROC Curves . . . . . . . . . . . . . . . . . . . . . . 392 9.6.4 SVM with Multiple Classes . . . . . . . . . . . . . 393 9.6.5 Application to Gene Expression Data . . . . . . . . 394 9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
10 Deep Learning 399 10.1 Single Layer Neural Networks . . . . . . . . . . . . . . . . 400 10.2 Multilayer Neural Networks . . . . . . . . . . . . . . . . . . 402 10.3 Convolutional Neural Networks . . . . . . . . . . . . . . . . 406 10.3.1 Convolution Layers . . . . . . . . . . . . . . . . . . 407 10.3.2 Pooling Layers . . . . . . . . . . . . . . . . . . . . 410 10.3.3 Architecture of a Convolutional Neural Network . . 410 10.3.4 Data Augmentation . . . . . . . . . . . . . . . . . . 411 10.3.5 Results Using a Pretrained Classifier . . . . . . . . 412 10.4 Document Classification . . . . . . . . . . . . . . . . . . . . 413 10.5 Recurrent Neural Networks . . . . . . . . . . . . . . . . . . 416 10.5.1 Sequential Models for Document Classification . . 418 10.5.2 Time Series Forecasting . . . . . . . . . . . . . . . 420 10.5.3 Summary of RNNs . . . . . . . . . . . . . . . . . . 424 10.6 When to Use Deep Learning . . . . . . . . . . . . . . . . . 425 10.7 Fitting a Neural Network . . . . . . . . . . . . . . . . . . . 427 10.7.1 Backpropagation . . . . . . . . . . . . . . . . . . . 428 10.7.2 Regularization and Stochastic Gradient Descent . . 429 10.7.3 Dropout Learning . . . . . . . . . . . . . . . . . . . 431 10.7.4 Network Tuning . . . . . . . . . . . . . . . . . . . . 431 10.8 Interpolation and Double Descent . . . . . . . . . . . . . . 432 10.9 Lab: Deep Learning . . . . . . . . . . . . . . . . . . . . . . 435 10.9.1 Single Layer Network on Hitters Data . . . . . . . 437 10.9.2 Multilayer Network on the MNIST Digit Data . . . 444 10.9.3 Convolutional Neural Networks . . . . . . . . . . . 448 10.9.4 Using Pretrained CNN Models . . . . . . . . . . . 452 10.9.5 IMDB Document Classification . . . . . . . . . . . 454 10.9.6 Recurrent Neural Networks . . . . . . . . . . . . . 458 10.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
11 Survival Analysis and Censored Data 469 11.1 Survival and Censoring Times . . . . . . . . . . . . . . . . 470 11.2 A Closer Look at Censoring . . . . . . . . . . . . . . . . . . 470 11.3 The Kaplan–Meier Survival Curve . . . . . . . . . . . . . . 472 11.4 The Log-Rank Test . . . . . . . . . . . . . . . . . . . . . . 474 11.5 Regression Models With a Survival Response . . . . . . . . 476


xiv Contents
11.5.1 The Hazard Function . . . . . . . . . . . . . . . . . 476 11.5.2 Proportional Hazards . . . . . . . . . . . . . . . . . 478 11.5.3 Example: Brain Cancer Data . . . . . . . . . . . . 482 11.5.4 Example: Publication Data . . . . . . . . . . . . . 482 11.6 Shrinkage for the Cox Model . . . . . . . . . . . . . . . . . 484 11.7 Additional Topics . . . . . . . . . . . . . . . . . . . . . . . 486 11.7.1 Area Under the Curve for Survival Analysis . . . . 486 11.7.2 Choice of Time Scale . . . . . . . . . . . . . . . . . 487 11.7.3 Time-Dependent Covariates . . . . . . . . . . . . . 488 11.7.4 Checking the Proportional Hazards Assumption . . 488 11.7.5 Survival Trees . . . . . . . . . . . . . . . . . . . . . 488 11.8 Lab: Survival Analysis . . . . . . . . . . . . . . . . . . . . . 489 11.8.1 Brain Cancer Data . . . . . . . . . . . . . . . . . . 489 11.8.2 Publication Data . . . . . . . . . . . . . . . . . . . 493 11.8.3 Call Center Data . . . . . . . . . . . . . . . . . . . 494 11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498
12 Unsupervised Learning 503 12.1 The Challenge of Unsupervised Learning . . . . . . . . . . 503 12.2 Principal Components Analysis . . . . . . . . . . . . . . . . 504 12.2.1 What Are Principal Components? . . . . . . . . . . 505 12.2.2 Another Interpretation of Principal Components . 508 12.2.3 The Proportion of Variance Explained . . . . . . . 510 12.2.4 More on PCA . . . . . . . . . . . . . . . . . . . . . 512 12.2.5 Other Uses for Principal Components . . . . . . . . 515 12.3 Missing Values and Matrix Completion . . . . . . . . . . . 515 12.4 Clustering Methods . . . . . . . . . . . . . . . . . . . . . . 520 12.4.1 K-Means Clustering . . . . . . . . . . . . . . . . . 521 12.4.2 Hierarchical Clustering . . . . . . . . . . . . . . . . 525 12.4.3 Practical Issues in Clustering . . . . . . . . . . . . 532 12.5 Lab: Unsupervised Learning . . . . . . . . . . . . . . . . . 535 12.5.1 Principal Components Analysis . . . . . . . . . . . 535 12.5.2 Matrix Completion . . . . . . . . . . . . . . . . . . 539 12.5.3 Clustering . . . . . . . . . . . . . . . . . . . . . . . 542 12.5.4 NCI60 Data Example . . . . . . . . . . . . . . . . . 546 12.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552
13 Multiple Testing 557 13.1 A Quick Review of Hypothesis Testing . . . . . . . . . . . 558 13.1.1 Testing a Hypothesis . . . . . . . . . . . . . . . . . 558 13.1.2 Type I and Type II Errors . . . . . . . . . . . . . . 562 13.2 The Challenge of Multiple Testing . . . . . . . . . . . . . . 563 13.3 The Family-Wise Error Rate . . . . . . . . . . . . . . . . . 565 13.3.1 What is the Family-Wise Error Rate? . . . . . . . 565 13.3.2 Approaches to Control the Family-Wise Error Rate 567 13.3.3 Trade-Off Between the FWER and Power . . . . . 572 13.4 The False Discovery Rate . . . . . . . . . . . . . . . . . . . 573 13.4.1 Intuition for the False Discovery Rate . . . . . . . 573 13.4.2 The Benjamini–Hochberg Procedure . . . . . . . . 575


Contents xv
13.5 A Re-Sampling Approach to p-Values and False Discovery Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577 13.5.1 A Re-Sampling Approach to the p-Value . . . . . . 578 13.5.2 A Re-Sampling Approach to the False Discovery Rate579 13.5.3 When Are Re-Sampling Approaches Useful? . . . . 581 13.6 Lab: Multiple Testing . . . . . . . . . . . . . . . . . . . . . 583 13.6.1 Review of Hypothesis Tests . . . . . . . . . . . . . 583 13.6.2 Family-Wise Error Rate . . . . . . . . . . . . . . . 585 13.6.3 False Discovery Rate . . . . . . . . . . . . . . . . . 588 13.6.4 A Re-Sampling Approach . . . . . . . . . . . . . . 590 13.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Index 597


1
Introduction
An Overview of Statistical Learning
Statistical learning refers to a vast set of tools for understanding data. These tools can be classified as supervised or unsupervised. Broadly speaking, supervised statistical learning involves building a statistical model for predicting, or estimating, an output based on one or more inputs. Problems of this nature occur in fields as diverse as business, medicine, astrophysics, and public policy. With unsupervised statistical learning, there are inputs but no supervising output; nevertheless we can learn relationships and structure from such data. To provide an illustration of some applications of statistical learning, we briefly discuss three real-world data sets that are considered in this book.
Wage Data
In this application (which we refer to as the Wage data set throughout this book), we examine a number of factors that relate to wages for a group of men from the Atlantic region of the United States. In particular, we wish to understand the association between an employee’s age and education, as well as the calendar year, on his wage. Consider, for example, the left-hand panel of Figure 1.1, which displays wage versus age for each of the individuals in the data set. There is evidence that wage increases with age but then decreases again after approximately age 60. The blue line, which provides an estimate of the average wage for a given age, makes this trend clearer. Given an employee’s age, we can use this curve to predict his wage. However, it is also clear from Figure 1.1 that there is a significant amount of variability associated with this average value, and so age alone is unlikely to provide an accurate prediction of a particular man’s wage.
© Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_1
1


2 1. Introduction
20 40 60 80
50 100 200 300
Age
Wage
2003 2006 2009
50 100 200 300
Year
Wage
12345
50 100 200 300
Education Level
Wage
FIGURE 1.1. Wage data, which contains income survey information for men from the central Atlantic region of the United States. Left: wage as a function of age. On average, wage increases with age until about 60 years of age, at which point it begins to decline. Center: wage as a function of year. There is a slow but steady increase of approximately $10,000 in the average wage between 2003 and 2009. Right: Boxplots displaying wage as a function of education, with 1 indicating the lowest level (no high school diploma) and 5 the highest level (an advanced graduate degree). On average, wage increases with the level of education.
We also have information regarding each employee’s education level and the year in which the wage was earned. The center and right-hand panels of Figure 1.1, which display wage as a function of both year and education, indicate that both of these factors are associated with wage. Wages increase by approximately $10,000, in a roughly linear (or straight-line) fashion, between 2003 and 2009, though this rise is very slight relative to the variability in the data. Wages are also typically greater for individuals with higher education levels: men with the lowest education level (1) tend to have substantially lower wages than those with the highest education level (5). Clearly, the most accurate prediction of a given man’s wage will be obtained by combining his age, his education, and the year. In Chapter 3, we discuss linear regression, which can be used to predict wage from this data set. Ideally, we should predict wage in a way that accounts for the non-linear relationship between wage and age. In Chapter 7, we discuss a class of approaches for addressing this problem.
Stock Market Data
The Wage data involves predicting a continuous or quantitative output value. This is often referred to as a regression problem. However, in certain cases we may instead wish to predict a non-numerical value—that is, a categorical or qualitative output. For example, in Chapter 4 we examine a stock market data set that contains the daily movements in the Standard & Poor’s 500 (S&P) stock index over a 5-year period between 2001 and 2005. We refer to this as the Smarket data. The goal is to predict whether the index will increase or decrease on a given day, using the past 5 days’ percentage changes in the index. Here the statistical learning problem does not involve predicting a numerical value. Instead it involves predicting whether a given


1. Introduction 3
Down Up
−4 −2 0 2 4 6
Yesterday
Today’s Direction
Percentage change in S&P
Down Up
−4 −2 0 2 4 6
Two Days Previous
Today’s Direction
Percentage change in S&P
Down Up
−4 −2 0 2 4 6
Three Days Previous
Today’s Direction
Percentage change in S&P
FIGURE 1.2. Left: Boxplots of the previous day’s percentage change in the S&P index for the days for which the market increased or decreased, obtained from the Smarket data. Center and Right: Same as left panel, but the percentage changes for 2 and 3 days previous are shown.
day’s stock market performance will fall into the Up bucket or the Down bucket. This is known as a classification problem. A model that could accurately predict the direction in which the market will move would be very useful! The left-hand panel of Figure 1.2 displays two boxplots of the previous day’s percentage changes in the stock index: one for the 648 days for which the market increased on the subsequent day, and one for the 602 days for which the market decreased. The two plots look almost identical, suggesting that there is no simple strategy for using yesterday’s movement in the S&P to predict today’s returns. The remaining panels, which display boxplots for the percentage changes 2 and 3 days previous to today, similarly indicate little association between past and present returns. Of course, this lack of pattern is to be expected: in the presence of strong correlations between successive days’ returns, one could adopt a simple trading strategy to generate profits from the market. Nevertheless, in Chapter 4, we explore these data using several different statistical learning methods. Interestingly, there are hints of some weak trends in the data that suggest that, at least for this 5-year period, it is possible to correctly predict the direction of movement in the market approximately 60% of the time (Figure 1.3).
Gene Expression Data
The previous two applications illustrate data sets with both input and output variables. However, another important class of problems involves situations in which we only observe input variables, with no corresponding output. For example, in a marketing setting, we might have demographic information for a number of current or potential customers. We may wish to understand which types of customers are similar to each other by grouping individuals according to their observed characteristics. This is known as a


4 1. Introduction
Down Up
0.46 0.48 0.50 0.52
Today’s Direction
Predicted Probability
FIGURE 1.3. We fit a quadratic discriminant analysis model to the subset of the Smarket data corresponding to the 2001–2004 time period, and predicted the probability of a stock market decrease using the 2005 data. On average, the predicted probability of decrease is higher for the days in which the market does decrease. Based on these results, we are able to correctly predict the direction of movement in the market 60% of the time.
clustering problem. Unlike in the previous examples, here we are not trying to predict an output variable. We devote Chapter 12 to a discussion of statistical learning methods for problems in which no natural output variable is available. We consider the NCI60 data set, which consists of 6,830 gene expression measurements for each of 64 cancer cell lines. Instead of predicting a particular output variable, we are interested in determining whether there are groups, or clusters, among the cell lines based on their gene expression measurements. This is a difficult question to address, in part because there are thousands of gene expression measurements per cell line, making it hard to visualize the data. The left-hand panel of Figure 1.4 addresses this problem by representing each of the 64 cell lines using just two numbers, Z1 and Z2. These are the first two principal components of the data, which summarize the 6,830 expression measurements for each cell line down to two numbers or dimensions. While it is likely that this dimension reduction has resulted in some loss of information, it is now possible to visually examine the data for evidence of clustering. Deciding on the number of clusters is often a difficult problem. But the left-hand panel of Figure 1.4 suggests at least four groups of cell lines, which we have represented using separate colors. In this particular data set, it turns out that the cell lines correspond to 14 different types of cancer. (However, this information was not used to create the left-hand panel of Figure 1.4.) The right-hand panel of Figure 1.4 is identical to the left-hand panel, except that the 14 cancer types are shown using distinct colored symbols. There is clear evidence that cell lines with the same cancer type tend to be located near each other in this two-dimensional representation. In addition, even though the cancer information was not used to produce the left-hand panel, the clustering obtained does bear some resemblance to some of the actual cancer types observed in the right-hand panel. This provides some independent verification of the accuracy of our clustering analysis.


1. Introduction 5
−40 −20 0 20 40 60
−60 −40 −20 0 20
−40 −20 0 20 40 60
−60 −40 −20 0 20
Z1
Z1
Z2
Z2
FIGURE 1.4. Left: Representation of the NCI60 gene expression data set in a two-dimensional space, Z1 and Z2. Each point corresponds to one of the 64 cell lines. There appear to be four groups of cell lines, which we have represented using different colors. Right: Same as left panel except that we have represented each of the 14 different types of cancer using a different colored symbol. Cell lines corresponding to the same cancer type tend to be nearby in the two-dimensional space.
A Brief History of Statistical Learning
Though the term statistical learning is fairly new, many of the concepts that underlie the field were developed long ago. At the beginning of the nineteenth century, the method of least squares was developed, implementing the earliest form of what is now known as linear regression. The approach was first successfully applied to problems in astronomy. Linear regression is used for predicting quantitative values, such as an individual’s salary. In order to predict qualitative values, such as whether a patient survives or dies, or whether the stock market increases or decreases, linear discriminant analysis was proposed in 1936. In the 1940s, various authors put forth an alternative approach, logistic regression. In the early 1970s, the term generalized linear model was developed to describe an entire class of statistical learning methods that include both linear and logistic regression as special cases. By the end of the 1970s, many more techniques for learning from data were available. However, they were almost exclusively linear methods because fitting non-linear relationships was computationally difficult at the time. By the 1980s, computing technology had finally improved sufficiently that non-linear methods were no longer computationally prohibitive. In the mid 1980s, classification and regression trees were developed, followed shortly by generalized additive models. Neural networks gained popularity in the 1980s, and support vector machines arose in the 1990s. Since that time, statistical learning has emerged as a new subfield in statistics, focused on supervised and unsupervised modeling and prediction. In recent years, progress in statistical learning has been marked by the increasing availability of powerful and relatively user-friendly software, such as the popular and freely available Python system. This has the potential to continue the transformation of the field from a set of techniques used and


6 1. Introduction
developed by statisticians and computer scientists to an essential toolkit for a much broader community.
This Book
The Elements of Statistical Learning (ESL) by Hastie, Tibshirani, and Friedman was first published in 2001. Since that time, it has become an important reference on the fundamentals of statistical machine learning. Its success derives from its comprehensive and detailed treatment of many important topics in statistical learning, as well as the fact that (relative to many upper-level statistics textbooks) it is accessible to a wide audience. However, the greatest factor behind the success of ESL has been its topical nature. At the time of its publication, interest in the field of statistical learning was starting to explode. ESL provided one of the first accessible and comprehensive introductions to the topic. Since ESL was first published, the field of statistical learning has continued to flourish. The field’s expansion has taken two forms. The most obvious growth has involved the development of new and improved statistical learning approaches aimed at answering a range of scientific questions across a number of fields. However, the field of statistical learning has also expanded its audience. In the 1990s, increases in computational power generated a surge of interest in the field from non-statisticians who were eager to use cutting-edge statistical tools to analyze their data. Unfortunately, the highly technical nature of these approaches meant that the user community remained primarily restricted to experts in statistics, computer science, and related fields with the training (and time) to understand and implement them. In recent years, new and improved software packages have significantly eased the implementation burden for many statistical learning methods. At the same time, there has been growing recognition across a number of fields, from business to health care to genetics to the social sciences and beyond, that statistical learning is a powerful tool with important practical applications. As a result, the field has moved from one of primarily academic interest to a mainstream discipline, with an enormous potential audience. This trend will surely continue with the increasing availability of enormous quantities of data and the software to analyze it.
The purpose of An Introduction to Statistical Learning (ISL) is to facilitate the transition of statistical learning from an academic to a mainstream field. ISL is not intended to replace ESL, which is a far more comprehensive text both in terms of the number of approaches considered and the depth to which they are explored. We consider ESL to be an important companion for professionals (with graduate degrees in statistics, machine learning, or related fields) who need to understand the technical details behind statistical learning approaches. However, the community of users of statistical learning techniques has expanded to include individuals with a wider range of interests and backgrounds. Therefore, there is a place for a less technical and more accessible version of ESL.


1. Introduction 7
In teaching these topics over the years, we have discovered that they are of interest to master’s and PhD students in fields as disparate as business administration, biology, and computer science, as well as to quantitativelyoriented upper-division undergraduates. It is important for this diverse group to be able to understand the models, intuitions, and strengths and weaknesses of the various approaches. But for this audience, many of the technical details behind statistical learning methods, such as optimization algorithms and theoretical properties, are not of primary interest. We believe that these students do not need a deep understanding of these aspects in order to become informed users of the various methodologies, and in order to contribute to their chosen fields through the use of statistical learning tools. ISL is based on the following four premises.
1. Many statistical learning methods are relevant and useful in a wide range of academic and non-academic disciplines, beyond just the statistical sciences. We believe that many contemporary statistical learning procedures should, and will, become as widely available and used as is currently the case for classical methods such as linear regression. As a result, rather than attempting to consider every possible approach (an impossible task), we have concentrated on presenting the methods that we believe are most widely applicable.
2. Statistical learning should not be viewed as a series of black boxes. No single approach will perform well in all possible applications. Without understanding all of the cogs inside the box, or the interaction between those cogs, it is impossible to select the best box. Hence, we have attempted to carefully describe the model, intuition, assumptions, and trade-offs behind each of the methods that we consider.
3. While it is important to know what job is performed by each cog, it is not necessary to have the skills to construct the machine inside the box! Thus, we have minimized discussion of technical details related to fitting procedures and theoretical properties. We assume that the reader is comfortable with basic mathematical concepts, but we do not assume a graduate degree in the mathematical sciences. For instance, we have almost completely avoided the use of matrix algebra, and it is possible to understand the entire book without a detailed knowledge of matrices and vectors.
4. We presume that the reader is interested in applying statistical learning methods to real-world problems. In order to facilitate this, as well as to motivate the techniques discussed, we have devoted a section within each chapter to computer labs. In each lab, we walk the reader through a realistic application of the methods considered in that chapter. When we have taught this material in our courses, we have allocated roughly one-third of classroom time to working through the labs, and we have found them to be extremely useful. Many of the less computationally-oriented students who were initially intimidated by the labs got the hang of things over the course of the quarter or semester. This book originally appeared (2013, second edition 2021)


8 1. Introduction
with computer labs written in the R language. Since then, there has been increasing demand for Python implementations of the important techniques in statistical learning. Consequently, this version has labs in Python. There are a rapidly growing number of Python packages available, and by examination of the imports at the beginning of each lab, readers will see that we have carefully selected and used the most appropriate. We have also supplied some additional code and functionality in our package ISLP. However, the labs in ISL are selfcontained, and can be skipped if the reader wishes to use a different software package or does not wish to apply the methods discussed to real-world problems.
Who Should Read This Book?
This book is intended for anyone who is interested in using modern statistical methods for modeling and prediction from data. This group includes scientists, engineers, data analysts, data scientists, and quants, but also less technical individuals with degrees in non-quantitative fields such as the social sciences or business. We expect that the reader will have had at least one elementary course in statistics. Background in linear regression is also useful, though not required, since we review the key concepts behind linear regression in Chapter 3. The mathematical level of this book is modest, and a detailed knowledge of matrix operations is not required. This book provides an introduction to Python. Previous exposure to a programming language, such as MATLAB or R, is useful but not required. The first edition of this textbook has been used to teach master’s and PhD students in business, economics, computer science, biology, earth sciences, psychology, and many other areas of the physical and social sciences. It has also been used to teach advanced undergraduates who have already taken a course on linear regression. In the context of a more mathematically rigorous course in which ESL serves as the primary textbook, ISL could be used as a supplementary text for teaching computational aspects of the various approaches.
Notation and Simple Matrix Algebra
Choosing notation for a textbook is always a difficult task. For the most part we adopt the same notational conventions as ESL. We will use n to represent the number of distinct data points, or observations, in our sample. We will let p denote the number of variables that are available for use in making predictions. For example, the Wage data set consists of 11 variables for 3,000 people, so we have n = 3,000 observations and p = 11 variables (such as year, age, race, and more). Note that throughout this book, we indicate variable names using colored font: Variable Name. In some examples, p might be quite large, such as on the order of thousands or even millions; this situation arises quite often, for example, in the analysis of modern biological data or web-based advertising data.


1. Introduction 9
In general, we will let xij represent the value of the jth variable for the ith observation, where i = 1, 2, . . . , n and j = 1, 2, . . . , p. Throughout this book, i will be used to index the samples or observations (from 1 to n) and j will be used to index the variables (from 1 to p). We let X denote an n × p matrix whose (i, j)th element is xij. That is,
X=


x11 x12 . . . x1p x21 x22 . . . x2p
... ... . . . ...
xn1 xn2 . . . xnp

 .
For readers who are unfamiliar with matrices, it is useful to visualize X as a spreadsheet of numbers with n rows and p columns. At times we will be interested in the rows of X, which we write as x1, x2, . . . , xn. Here xi is a vector of length p, containing the p variable measurements for the ith observation. That is,
xi =


xi1
x...i2
xip

 . (1.1)
(Vectors are by default represented as columns.) For example, for the Wage data, xi is a vector of length 11, consisting of year, age, race, and other values for the ith individual. At other times we will instead be interested in the columns of X, which we write as x1, x2, . . . , xp. Each is a vector of length n. That is,
xj =


x1j
x...2j
xnj

 .
For example, for the Wage data, x1 contains the n = 3,000 values for year. Using this notation, the matrix X can be written as
X = (x1 x2 · · · xp
),
or
X=


x1T
x...2T
xTn

 .
The T notation denotes the transpose of a matrix or vector. So, for example,
XT =


x11 x21 . . . xn1 x12 x22 . . . xn2
... ... ...
x1p x2p . . . xnp

 ,


10 1. Introduction
while
xT
i = (xi1 xi2 · · · xip
).
We use yi to denote the ith observation of the variable on which we wish to make predictions, such as wage. Hence, we write the set of all n observations in vector form as
y=


y1
y...2
yn

 .
Then our observed data consists of {(x1, y1), (x2, y2), . . . , (xn, yn)}, where each xi is a vector of length p. (If p = 1, then xi is simply a scalar.) In this text, a vector of length n will always be denoted in lower case bold; e.g.
a=


a1
a...2
an

 .
However, vectors that are not of length n (such as feature vectors of length p, as in (1.1)) will be denoted in lower case normal font, e.g. a. Scalars will also be denoted in lower case normal font, e.g. a. In the rare cases in which these two uses for lower case normal font lead to ambiguity, we will clarify which use is intended. Matrices will be denoted using bold capitals, such as A. Random variables will be denoted using capital normal font, e.g. A, regardless of their dimensions. Occasionally we will want to indicate the dimension of a particular object. To indicate that an object is a scalar, we will use the notation a ∈ R. To indicate that it is a vector of length k, we will use a ∈ Rk (or a ∈ Rn if it is of length n). We will indicate that an object is an r × s matrix using A ∈ Rr×s.
We have avoided using matrix algebra whenever possible. However, in a few instances it becomes too cumbersome to avoid it entirely. In these rare instances it is important to understand the concept of multiplying two matrices. Suppose that A ∈ Rr×d and B ∈ Rd×s. Then the product of A and B is denoted AB. The (i, j)th element of AB is computed by multiplying each element of the ith row of A by the corresponding element
of the jth column of B. That is, (AB)ij = ∑d
k=1 aikbkj . As an example,
consider
A=
(1 2 34
)
and B =
(5 6 78
) .
Then
AB =
(1 2 34
) (5 6
78
) =
(1 × 5 + 2 × 7 1 × 6 + 2 × 8 3×5+4×7 3×6+4×8
) =
(19 22 43 50
) .
Note that this operation produces an r × s matrix. It is only possible to compute AB if the number of columns of A is the same as the number of rows of B.


1. Introduction 11
Organization of This Book
Chapter 2 introduces the basic terminology and concepts behind statistical learning. This chapter also presents the K-nearest neighbor classifier, a very simple method that works surprisingly well on many problems. Chapters 3 and 4 cover classical linear methods for regression and classification. In particular, Chapter 3 reviews linear regression, the fundamental starting point for all regression methods. In Chapter 4 we discuss two of the most important classical classification methods, logistic regression and linear discriminant analysis.
A central problem in all statistical learning situations involves choosing the best method for a given application. Hence, in Chapter 5 we introduce cross-validation and the bootstrap, which can be used to estimate the accuracy of a number of different methods in order to choose the best one. Much of the recent research in statistical learning has concentrated on non-linear methods. However, linear methods often have advantages over their non-linear competitors in terms of interpretability and sometimes also accuracy. Hence, in Chapter 6 we consider a host of linear methods, both classical and more modern, which offer potential improvements over standard linear regression. These include stepwise selection, ridge regression, principal components regression, and the lasso.
The remaining chapters move into the world of non-linear statistical learning. We first introduce in Chapter 7 a number of non-linear methods that work well for problems with a single input variable. We then show how these methods can be used to fit non-linear additive models for which there is more than one input. In Chapter 8, we investigate tree-based methods, including bagging, boosting, and random forests. Support vector machines, a set of approaches for performing both linear and non-linear classification, are discussed in Chapter 9. We cover deep learning, an approach for non-linear regression and classification that has received a lot of attention in recent years, in Chapter 10. Chapter 11 explores survival analysis, a regression approach that is specialized to the setting in which the output variable is censored, i.e. not fully observed. In Chapter 12, we consider the unsupervised setting in which we have input variables but no output variable. In particular, we present principal components analysis, K-means clustering, and hierarchical clustering. Finally, in Chapter 13 we cover the very important topic of multiple hypothesis testing. At the end of each chapter, we present one or more Python lab sections in which we systematically work through applications of the various methods discussed in that chapter. These labs demonstrate the strengths and weaknesses of the various approaches, and also provide a useful reference for the syntax required to implement the various methods. The reader may choose to work through the labs at their own pace, or the labs may be the focus of group sessions as part of a classroom environment. Within each Python lab, we present the results that we obtained when we performed the lab at the time of writing this book. However, new versions of Python are continuously released, and over time, the packages called in the labs will be updated. Therefore, in the future, it is possible that the results shown in


12 1. Introduction
Name Description
Auto Gas mileage, horsepower, and other information for cars. Bikeshare Hourly usage of a bike sharing program in Washington, DC. Boston Housing values and other information about Boston census tracts. BrainCancer Survival times for patients diagnosed with brain cancer. Caravan Information about individuals offered caravan insurance. Carseats Information about car seat sales in 400 stores. College Demographic characteristics, tuition, and more for USA colleges. Credit Information about credit card debt for 400 customers. Default Customer default records for a credit card company. Fund Returns of 2,000 hedge fund managers over 50 months. Hitters Records and salaries for baseball players. Khan Gene expression measurements for four cancer types. NCI60 Gene expression measurements for 64 cancer cell lines. NYSE Returns, volatility, and volume for the New York Stock Exchange. OJ Sales information for Citrus Hill and Minute Maid orange juice. Portfolio Past values of financial assets, for use in portfolio allocation. Publication Time to publication for 244 clinical trials. Smarket Daily percentage returns for S&P 500 over a 5-year period. USArrests Crime statistics per 100,000 residents in 50 states of USA. Wage Income survey data for men in central Atlantic region of USA. Weekly 1,089 weekly stock market returns for 21 years.
TABLE 1.1. A list of data sets needed to perform the labs and exercises in this textbook. All data sets are available in the ISLP package, with the exception of USArrests, which is part of the base R distribution, but accessible from Python.
the lab sections may no longer correspond precisely to the results obtained by the reader who performs the labs. As necessary, we will post updates to the labs on the book website. We use the symbol to denote sections or exercises that contain more challenging concepts. These can be easily skipped by readers who do not wish to delve as deeply into the material, or who lack the mathematical background.
Data Sets Used in Labs and Exercises
In this textbook, we illustrate statistical learning methods using applications from marketing, finance, biology, and other areas. The ISLP package contains a number of data sets that are required in order to perform the labs and exercises associated with this book. One other data set is part of the base R distribution (the USArrests data), and we show how to access it from Python in Section 12.5.1. Table 1.1 contains a summary of the data sets required to perform the labs and exercises. A couple of these data sets are also available as text files on the book website, for use in Chapter 2.


1. Introduction 13
Book Website
The website for this book is located at
www.statlearning.com
It contains a number of resources, including the Python package associated with this book, and some additional data sets.
Acknowledgements
A few of the plots in this book were taken from ESL: Figures 6.7, 8.3, and 12.14. All other plots were produced for the R version of ISL, except for Figure 13.10 which differs because of the Python software supporting the plot.


2
Statistical Learning
2.1 What Is Statistical Learning?
In order to motivate our study of statistical learning, we begin with a simple example. Suppose that we are statistical consultants hired by a client to investigate the association between advertising and sales of a particular product. The Advertising data set consists of the sales of that product in 200 different markets, along with advertising budgets for the product in each of those markets for three different media: TV, radio, and newspaper. The data are displayed in Figure 2.1. It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each of the three media. Therefore, if we determine that there is an association between advertising and sales, then we can instruct our client to adjust advertising budgets, thereby indirectly increasing sales. In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets. In this setting, the advertising budgets are input variables while sales input
variable
is an output variable. The input variables are typically denoted using the
output variable
symbol X, with a subscript to distinguish them. So X1 might be the TV budget, X2 the radio budget, and X3 the newspaper budget. The inputs
go by different names, such as predictors, independent variables, features, predictor
independent variable feature
or sometimes just variables. The output variable—in this case, sales—is
variable
often called the response or dependent variable, and is typically denoted
response
dependent variable
using the symbol Y . Throughout this book, we will use all of these terms interchangeably. More generally, suppose that we observe a quantitative response Y and p different predictors, X1, X2, . . . , Xp. We assume that there is some relationship between Y and X = (X1, X2, . . . , Xp), which can be written in the very general form
Y = f (X) + ε. (2.1)
© Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_2
15


16 2. Statistical Learning
0 50 100 200 300
5 10 15 20 25
TV
Sales
0 10 20 30 40 50
5 10 15 20 25
Radio
Sales
0 20 40 60 80 100
5 10 15 20 25
Newspaper
Sales
FIGURE 2.1. The Advertising data set. The plot displays sales, in thousands of units, as a function of TV, radio, and newspaper budgets, in thousands of dollars, for 200 different markets. In each plot we show the simple least squares fit of sales to that variable, as described in Chapter 3. In other words, each blue line represents a simple model that can be used to predict sales using TV, radio, and newspaper, respectively.
Here f is some fixed but unknown function of X1, . . . , Xp, and ε is a random error term, which is independent of X and has mean zero. In this formula- error term
tion, f represents the systematic information that X provides about Y . systematic
10 12 14 16 18 20 22
20 30 40 50 60 70 80
Years of Education
Income
10 12 14 16 18 20 22
20 30 40 50 60 70 80
Years of Education
Income
FIGURE 2.2. The Income data set. Left: The red dots are the observed values of income (in thousands of dollars) and years of education for 30 individuals. Right: The blue curve represents the true underlying relationship between income and years of education, which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated with each observation. Note that some errors are positive (if an observation lies above the blue curve) and some are negative (if an observation lies below the curve). Overall, these errors have approximately mean zero.
As another example, consider the left-hand panel of Figure 2.2, a plot of income versus years of education for 30 individuals in the Income data set. The plot suggests that one might be able to predict income using years of education. However, the function f that connects the input variable to the


2.1 What Is Statistical Learning? 17
output variable is in general unknown. In this situation one must estimate f based on the observed points. Since Income is a simulated data set, f is known and is shown by the blue curve in the right-hand panel of Figure 2.2. The vertical lines represent the error terms ε. We note that some of the 30 observations lie above the blue curve and some lie below it; overall, the errors have approximately mean zero. In general, the function f may involve more than one input variable. In Figure 2.3 we plot income as a function of years of education and seniority. Here f is a two-dimensional surface that must be estimated based on the observed data. In essence, statistical learning refers to a set of approaches for estimating f . In this chapter we outline some of the key theoretical concepts that arise in estimating f , as well as tools for evaluating the estimates obtained.
2.1.1 Why Estimate f ?
There are two main reasons that we may wish to estimate f : prediction and inference. We discuss each in turn.
Prediction
In many situations, a set of inputs X are readily available, but the output Y cannot be easily obtained. In this setting, since the error term averages to zero, we can predict Y using
Yˆ = fˆ(X), (2.2)
where fˆ represents our estimate for f , and Yˆ represents the resulting prediction for Y . In this setting, fˆ is often treated as a black box, in the sense that one is not typically concerned with the exact form of fˆ, provided that it yields accurate predictions for Y . As an example, suppose that X1, . . . , Xp are characteristics of a patient’s blood sample that can be easily measured in a lab, and Y is a variable encoding the patient’s risk for a severe adverse reaction to a particular drug. It is natural to seek to predict Y using X, since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients for whom the estimate of Y is high. The accuracy of Yˆ as a prediction for Y depends on two quantities, which we will call the reducible error and the irreducible error. In general, reducible
error irreducible error
fˆ will not be a perfect estimate for f , and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of fˆ by using the most appropriate statistical learning technique to estimate f . However, even if it were possible to form a perfect estimate for f , so that our estimated response took the form Yˆ = f (X), our prediction would still have some error in it! This is because Y is also a function of ε, which, by definition, cannot be predicted using X. Therefore, variability associated with ε also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate f , we cannot reduce the error introduced by ε. Why is the irreducible error larger than zero? The quantity ε may contain unmeasured variables that are useful in predicting Y : since we don’t


18 2. Statistical Learning
YearsofEducation
Seniority
Income
FIGURE 2.3. The plot displays income as a function of years of education and seniority in the Income data set. The blue surface represents the true underlying relationship between income and years of education and seniority, which is known since the data are simulated. The red dots indicate the observed values of these quantities for 30 individuals.
measure them, f cannot use them for its prediction. The quantity ε may also contain unmeasurable variation. For example, the risk of an adverse reaction might vary for a given patient on a given day, depending on manufacturing variation in the drug itself or the patient’s general feeling of well-being on that day. Consider a given estimate fˆ and a set of predictors X, which yields the prediction Yˆ = fˆ(X). Assume for a moment that both fˆ and X are fixed, so that the only variability comes from ε. Then, it is easy to show that
E(Y − Yˆ )2 = E[f (X) + ε − fˆ(X)]2
= [f (X) − fˆ(X)]2
} {{ } Reducible
+ Var(ε)
} {{ } Irreducible
, (2.3)
where E(Y − Yˆ )2 represents the average, or expected value, of the squared expected
value
difference between the predicted and actual value of Y , and Var(ε) represents the variance associated with the error term ε. variance
The focus of this book is on techniques for estimating f with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for Y . This bound is almost always unknown in practice.
Inference
We are often interested in understanding the association between Y and X1, . . . , Xp. In this situation we wish to estimate f , but our goal is not necessarily to make predictions for Y . Now fˆ cannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions:


2.1 What Is Statistical Learning? 19
• Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y . Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application.
• What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y , in the sense that larger values of the predictor are associated with larger values of Y . Other predictors may have the opposite relationship. Depending on the complexity of f , the relationship between the response and a given predictor may also depend on the values of the other predictors.
• Can the relationship between Y and each predictor be adequately summarized using a linear equation, or is the relationship more complicated? Historically, most methods for estimating f have taken a linear form. In some situations, such an assumption is reasonable or even desirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables.
In this book, we will see a number of examples that fall into the prediction setting, the inference setting, or a combination of the two. For instance, consider a company that is interested in conducting a direct-marketing campaign. The goal is to identify individuals who are likely to respond positively to a mailing, based on observations of demographic variables measured on each individual. In this case, the demographic variables serve as predictors, and response to the marketing campaign (either positive or negative) serves as the outcome. The company is not interested in obtaining a deep understanding of the relationships between each individual predictor and the response; instead, the company simply wants to accurately predict the response using the predictors. This is an example of modeling for prediction. In contrast, consider the Advertising data illustrated in Figure 2.1. One may be interested in answering questions such as:
– Which media are associated with sales?
– Which media generate the biggest boost in sales? or
– How large of an increase in sales is associated with a given increase in TV advertising?
This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one might really be most interested in the association between each variable and the probability of purchase. For instance, to what extent is the product’s price associated with sales? This is an example of modeling for inference. Finally, some modeling could be conducted both for prediction and inference. For example, in a real estate setting, one may seek to relate values


20 2. Statistical Learning
of homes to inputs such as crime rate, zoning, distance from a river, air quality, schools, income level of community, size of houses, and so forth. In this case one might be interested in the association between each individual input variable and housing price—for instance, how much extra will a house be worth if it has a view of the river? This is an inference problem. Alternatively, one may simply be interested in predicting the value of a home given its characteristics: is this house under- or over-valued? This is a prediction problem. Depending on whether our ultimate goal is prediction, inference, or a combination of the two, different methods for estimating f may be appropriate. For example, linear models allow for relatively simple and in- linear model
terpretable inference, but may not yield as accurate predictions as some other approaches. In contrast, some of the highly non-linear approaches that we discuss in the later chapters of this book can potentially provide quite accurate predictions for Y , but this comes at the expense of a less interpretable model for which inference is more challenging.
2.1.2 How Do We Estimate f ?
Throughout this book, we explore many linear and non-linear approaches for estimating f . However, these methods generally share certain characteristics. We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of n different data points. For example in Figure 2.2 we observed n = 30 data points. These observations are called the training data because we will use these training
data
observations to train, or teach, our method how to estimate f . Let xij represent the value of the jth predictor, or input, for observation i, where i = 1, 2, . . . , n and j = 1, 2, . . . , p. Correspondingly, let yi represent the response variable for the ith observation. Then our training data consist of {(x1, y1), (x2, y2), . . . , (xn, yn)} where xi = (xi1, xi2, . . . , xip)T .
Our goal is to apply a statistical learning method to the training data in order to estimate the unknown function f . In other words, we want to find a function fˆ such that Y ≈ fˆ(X) for any observation (X, Y ). Broadly speaking, most statistical learning methods for this task can be characterized as either parametric or non-parametric. We now briefly discuss these parametric
nonparametric
two types of approaches.
Parametric Methods
Parametric methods involve a two-step model-based approach.
1. First, we make an assumption about the functional form, or shape, of f . For example, one very simple assumption is that f is linear in X: f (X) = β0 + β1X1 + β2X2 + · · · + βpXp. (2.4)
This is a linear model, which will be discussed extensively in Chapter 3. Once we have assumed that f is linear, the problem of estimating f is greatly simplified. Instead of having to estimate an entirely arbitrary p-dimensional function f (X), one only needs to estimate the p + 1 coefficients β0, β1, . . . , βp.


2.1 What Is Statistical Learning? 21
YearsofEducation
Seniority
Income
FIGURE 2.4. A linear model fit by least squares to the Income data from Figure 2.3. The observations are shown in red, and the yellow plane indicates the least squares fit to the data.
2. After a model has been selected, we need a procedure that uses the training data to fit or train the model. In the case of the linear model fit
train
(2.4), we need to estimate the parameters β0, β1, . . . , βp. That is, we want to find values of these parameters such that
Y ≈ β0 + β1X1 + β2X2 + · · · + βpXp.
The most common approach to fitting the model (2.4) is referred to as (ordinary) least squares, which we discuss in Chapter 3. However, least squares
least squares is one of many possible ways to fit the linear model. In Chapter 6, we discuss other approaches for estimating the parameters in (2.4).
The model-based approach just described is referred to as parametric; it reduces the problem of estimating f down to one of estimating a set of parameters. Assuming a parametric form for f simplifies the problem of estimating f because it is generally much easier to estimate a set of parameters, such as β0, β1, . . . , βp in the linear model (2.4), than it is to fit an entirely arbitrary function f . The potential disadvantage of a parametric approach is that the model we choose will usually not match the true unknown form of f . If the chosen model is too far from the true f , then our estimate will be poor. We can try to address this problem by choosing flexible models that can fit many different possible functional forms flexible
for f . But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they overfitting
follow the errors, or noise, too closely. These issues are discussed through- noise
out this book. Figure 2.4 shows an example of the parametric approach applied to the Income data from Figure 2.3. We have fit a linear model of the form
income ≈ β0 + β1 × education + β2 × seniority.


22 2. Statistical Learning
YearsofEducation
Seniority
Income
FIGURE 2.5. A smooth thin-plate spline fit to the Income data from Figure 2.3 is shown in yellow; the observations are displayed in red. Splines are discussed in Chapter 7.
Since we have assumed a linear relationship between the response and the two predictors, the entire fitting problem reduces to estimating β0, β1, and β2, which we do using least squares linear regression. Comparing Figure 2.3 to Figure 2.4, we can see that the linear fit given in Figure 2.4 is not quite right: the true f has some curvature that is not captured in the linear fit. However, the linear fit still appears to do a reasonable job of capturing the positive relationship between years of education and income, as well as the slightly less positive relationship between seniority and income. It may be that with such a small number of observations, this is the best we can do.
Non-Parametric Methods
Non-parametric methods do not make explicit assumptions about the functional form of f . Instead they seek an estimate of f that gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for f , they have the potential to accurately fit a wider range of possible shapes for f . Any parametric approach brings with it the possibility that the functional form used to estimate f is very different from the true f , in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of f is made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating f to a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for f . An example of a non-parametric approach to fitting the Income data is shown in Figure 2.5. A thin-plate spline is used to estimate f . This ap- thin-plate
spline
proach does not impose any pre-specified model on f . It instead attempts


2.1 What Is Statistical Learning? 23
YearsofEducation
Seniority
Income
FIGURE 2.6. A rough thin-plate spline fit to the Income data from Figure 2.3. This fit makes zero errors on the training data.
to produce an estimate for f that is as close as possible to the observed data, subject to the fit—that is, the yellow surface in Figure 2.5—being smooth. In this case, the non-parametric fit has produced a remarkably accurate estimate of the true f shown in Figure 2.3. In order to fit a thin-plate spline, the data analyst must select a level of smoothness. Figure 2.6 shows the same thin-plate spline fit using a lower level of smoothness, allowing for a rougher fit. The resulting estimate fits the observed data perfectly! However, the spline fit shown in Figure 2.6 is far more variable than the true function f , from Figure 2.3. This is an example of overfitting the data, which we discussed previously. It is an undesirable situation because the fit obtained will not yield accurate estimates of the response on new observations that were not part of the original training data set. We discuss methods for choosing the correct amount of smoothness in Chapter 5. Splines are discussed in Chapter 7. As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. We explore both types of methods throughout this book.
2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability
Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f . For example, linear regression is a relatively inflexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.4. Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6, are considerably more flexible because they can generate a much wider range of possible shapes to estimate f .


24 2. Statistical Learning
Flexibility
Interpretability
Low High
Low High
Subset Selection Lasso
Least Squares
Generalized Additive Models Trees
Bagging, Boosting
Support Vector Machines Deep Learning
FIGURE 2.7. A representation of the tradeoff between flexibility and interpretability, using different statistical learning methods. In general, as the flexibility of a method increases, its interpretability decreases.
One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between Y and X1, X2, . . . , Xp. In contrast, very flexible approaches, such as the splines discussed in Chapter 7 and displayed in Figures 2.5 and 2.6, and the boosting methods discussed in Chapter 8, can lead to such complicated estimates of f that it is difficult to understand how any individual predictor is associated with the response. Figure 2.7 provides an illustration of the trade-off between flexibility and interpretability for some of the methods that we cover in this book. Least squares linear regression, discussed in Chapter 3, is relatively inflexible but is quite interpretable. The lasso, discussed in Chapter 6, relies upon the lasso
linear model (2.4) but uses an alternative fitting procedure for estimating the coefficients β0, β1, . . . , βp. The new procedure is more restrictive in estimating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors—namely, those with nonzero coefficient estimates. Generalized additive models (GAMs), discussed in Chapter 7, instead extend the lin- generalized
additive model
ear model (2.4) to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally,
fully non-linear methods such as bagging, boosting, support vector machines bagging
boosting
with non-linear kernels, and neural networks (deep learning), discussed in
support vector machine
Chapters 8, 9, and 10, are highly flexible approaches that are harder to interpret.


2.1 What Is Statistical Learning? 25
We have established that when inference is the goal, there are clear advantages to using simple and relatively inflexible statistical learning methods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accuratelyinterpretability is not a concern. In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintuitive at first glance, has to do with the potential for overfitting in highly flexible methods. We saw an example of overfitting in Figure 2.6. We will discuss this very important concept further in Section 2.2 and throughout this book.
2.1.4 Supervised Versus Unsupervised Learning
Most statistical learning problems fall into one of two categories: supervised supervised
or unsupervised. The examples that we have discussed so far in this chap- unsupervised
ter all fall into the supervised learning domain. For each observation of the predictor measurement(s) xi, i = 1, . . . , n there is an associated response measurement yi. We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference). Many classical statistical learning methods such as linear regression and logistic regression (Chapter 4), as logistic
regression
well as more modern approaches such as GAM, boosting, and support vector machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting. By contrast, unsupervised learning describes the somewhat more challenging situation in which for every observation i = 1, . . . , n, we observe a vector of measurements xi but no associated response yi. It is not possible to fit a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the situation is referred to as unsupervised because we lack a response variable that can supervise our analysis. What sort of statistical analysis is possible? We can seek to understand the relationships between the variables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis, or clustering. The goal of cluster analysis cluster
analysis
is to ascertain, on the basis of x1, . . . , xn, whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might believe that the customers fall into different groups, such as big spenders versus low spenders. If the information about each customer’s spending patterns were available, then a supervised analysis would be possible. However, this information is not available—that is, we do not know whether each potential customer is a big spender or not. In this setting, we can try to cluster the customers on the basis of the variables measured, in order to identify


26 2. Statistical Learning
0 2 4 6 8 10 12
2 4 6 8 10 12
0246
2468
X1
X1
X2
X2
FIGURE 2.8. A clustering data set involving three groups. Each group is shown using a different colored symbol. Left: The three groups are well-separated. In this setting, a clustering approach should successfully identify the three groups. Right: There is some overlap among the groups. Now the clustering task is more chal lenging.
distinct groups of potential customers. Identifying such groups can be of interest because it might be that the groups differ with respect to some property of interest, such as spending habits. Figure 2.8 provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X1 and X2. Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the members of each group using different colors and symbols. However, in practice the group memberships are unknown, and the goal is to determine the group to which each observation belongs. In the left-hand panel of Figure 2.8, this is a relatively easy task because the groups are well-separated. By contrast, the right-hand panel illustrates a more challenging setting in which there is some overlap between the groups. A clustering method could not be expected to assign all of the overlapping points to their correct group (blue, green, or orange). In the examples shown in Figure 2.8, there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are p variables in our data set, then p(p − 1)/2 distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important. We discuss clustering and other unsupervised learning approaches in Chapter 12. Many problems fall naturally into the supervised or unsupervised learning paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut. For instance, suppose that we have a set of n observations. For m of the observations, where m < n, we have both predictor measurements and a response


2.2 Assessing Model Accuracy 27
measurement. For the remaining n − m observations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as a semi-supervised learning problem. In this setting, we wish to use a sta- semi
supervised learning
tistical learning method that can incorporate the m observations for which response measurements are available as well as the n − m observations for which they are not. Although this is an interesting topic, it is beyond the scope of this book.
2.1.5 Regression Versus Classification Problems
Variables can be characterized as either quantitative or qualitative (also quantitative
qualitative
known as categorical). Quantitative variables take on numerical values. Ex
categorical
amples include a person’s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes, or categories. Examples of qualitative variables class
include a person’s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involving a regression
qualitative response are often referred to as classification problems. How- classification
ever, the distinction is not always that crisp. Least squares linear regression (Chapter 3) is used with a quantitative response, whereas logistic regression (Chapter 4) is typically used with a qualitative (two-class, or binary) re- binary
sponse. Thus, despite its name, logistic regression is a classification method. But since it estimates class probabilities, it can be thought of as a regression method as well. Some statistical methods, such as K-nearest neighbors (Chapters 2 and 4) and boosting (Chapter 8), can be used in the case of either quantitative or qualitative responses. We tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regression when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally considered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly coded before the analysis is performed. This is discussed in Chapter 3.
2.2 Assessing Model Accuracy
One of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many different statistical learning approaches, rather than just a single best method? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one specific method may work


28 2. Statistical Learning
best, but some other method may work better on a similar but different data set. Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice. In this section, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a specific data set. As the book progresses, we will explain how the concepts presented here can be applied in practice.
2.2.1 Measuring the Quality of Fit
In order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by mean
squared error
MSE = 1
n
∑n
i=1
(yi − fˆ(xi))2, (2.5)
where fˆ(xi) is the prediction that fˆ gives for the ith observation. The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially. The MSE in (2.5) is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE. But in general, we do not really care how well the method works training
MSE
on the training data. Rather, we are interested in the accuracy of the predictions that we obtain when we apply our method to previously unseen
test data. Why is this what we care about? Suppose that we are interested test data
in developing an algorithm to predict a stock’s price based on previous stock returns. We can train the method using stock returns from the past 6 months. But we don’t really care how well our method predicts last week’s stock price. We instead care about how well it will predict tomorrow’s price or next month’s price. On a similar note, suppose that we have clinical measurements (e.g. weight, blood pressure, height, age, family history of disease) for a number of patients, as well as information about whether each patient has diabetes. We can use these patients to train a statistical learning method to predict risk of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurements. We are not very interested in whether or not the method accurately predicts diabetes risk for patients used to train the model, since we already know which of those patients have diabetes. To state it more mathematically, suppose that we fit our statistical learning method on our training observations {(x1, y1), (x2, y2), . . . , (xn, yn)}, and we obtain the estimate fˆ. We can then compute fˆ(x1), fˆ(x2), . . . , fˆ(xn).


2.2 Assessing Model Accuracy 29
0 20 40 60 80 100
2 4 6 8 10 12
X
Y
2 5 10 20
0.0 0.5 1.0 1.5 2.0 2.5
Flexibility
Mean Squared Error
FIGURE 2.9. Left: Data simulated from f , shown in black. Three estimates of f are shown: the linear regression line (orange curve), and two smoothing spline fits (blue and green curves). Right: Training MSE (grey curve), test MSE (red curve), and minimum possible test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three fits shown in the left-hand panel.
If these are approximately equal to y1, y2, . . . , yn, then the training MSE given by (2.5) is small. However, we are really not interested in whether fˆ(xi) ≈ yi; instead, we want to know whether fˆ(x0) is approximately equal to y0, where (x0, y0) is a previously unseen test observation not used to train the statistical learning method. We want to choose the method that gives the lowest test MSE, as opposed to the lowest training MSE. In other words, test MSE
if we had a large number of test observations, we could compute
Ave(y0 − fˆ(x0))2, (2.6)
the average squared prediction error for these test observations (x0, y0). We’d like to select the model for which this quantity is as small as possible. How can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available—that is, we may have access to a set of observations that were not used to train the statistical learning method. We can then simply evaluate (2.6) on the test observations, and select the learning method for which the test MSE is smallest. But what if no test observations are available? In that case, one might imagine simply selecting a statistical learning method that minimizes the training MSE (2.5). This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger. Figure 2.9 illustrates this phenomenon on a simple example. In the lefthand panel of Figure 2.9, we have generated observations from (2.1) with


30 2. Statistical Learning
the true f given by the black curve. The orange, blue and green curves illustrate three possible estimates for f obtained using methods with increasing levels of flexibility. The orange line is the linear regression fit, which is relatively inflexible. The blue and green curves were produced using smoothing splines, discussed in Chapter 7, with different levels of smoothness. It is smoothing
spline
clear that as the level of flexibility increases, the curves fit the observed data more closely. The green curve is the most flexible and matches the data very well; however, we observe that it fits the true f (shown in black) poorly because it is too wiggly. By adjusting the level of flexibility of the smoothing spline fit, we can produce many different fits to this data. We now move on to the right-hand panel of Figure 2.9. The grey curve displays the average training MSE as a function of flexibility, or more formally the degrees of freedom, for a number of smoothing splines. The degrees of
freedom
degrees of freedom is a quantity that summarizes the flexibility of a curve; it is discussed more fully in Chapter 7. The orange, blue and green squares indicate the MSEs associated with the corresponding curves in the lefthand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve—note that in Figure 2.9, linear regression is at the most restrictive end, with two degrees of freedom. The training MSE declines monotonically as flexibility increases. In this example the true f is non-linear, and so the orange linear fit is not flexible enough to estimate f well. The green curve has the lowest training MSE of all three methods, since it corresponds to the most flexible of the three curves fit in the left-hand panel. In this example, we know the true function f , and so we can also compute the test MSE over a very large test set, as a function of flexibility. (Of course, in general f is unknown, so this will not be possible.) The test MSE is displayed using the red curve in the right-hand panel of Figure 2.9. As with the training MSE, the test MSE initially declines as the level of flexibility increases. However, at some point the test MSE levels off and then starts to increase again. Consequently, the orange and green curves both have high test MSE. The blue curve minimizes the test MSE, which should not be surprising given that visually it appears to estimate f the best in the left-hand panel of Figure 2.9. The horizontal dashed line indicates Var(ε), the irreducible error in (2.3), which corresponds to the lowest achievable test MSE among all possible methods. Hence, the smoothing spline represented by the blue curve is close to optimal. In the right-hand panel of Figure 2.9, as the flexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE. This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model flexibility increases, the training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f . When we overfit the training data, the test MSE will be very large because the supposed


2.2 Assessing Model Accuracy 31
0 20 40 60 80 100
2 4 6 8 10 12
X
Y
2 5 10 20
0.0 0.5 1.0 1.5 2.0 2.5
Flexibility
Mean Squared Error
FIGURE 2.10. Details are as in Figure 2.9, using a different true f that is much closer to linear. In this setting, linear regression provides a very good fit to the data.
patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE. Figure 2.10 provides another example in which the true f is approximately linear. Again we observe that the training MSE decreases monotonically as the model flexibility increases, and that there is a U-shape in the test MSE. However, because the truth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares fit is substantially better than the highly flexible green curve. Finally, Figure 2.11 displays an example in which f is highly non-linear. The training and test MSE curves still exhibit the same general patterns, but now there is a rapid decrease in both curves before the test MSE starts to increase slowly. In practice, one can usually compute the training MSE with relative ease, but estimating the test MSE is considerably more difficult because usually no test data are available. As the previous three examples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that can be used in practice to estimate this minimum point. One important method is cross-validation (Chapter 5), which is a cross
validation
method for estimating the test MSE using the training data.
2.2.2 The Bias-Variance Trade-Off
The U-shape observed in the test MSE curves (Figures 2.9–2.11) turns out to be the result of two competing properties of statistical learning methods.


32 2. Statistical Learning
0 20 40 60 80 100
−10 0 10 20
X
Y
2 5 10 20
0 5 10 15 20
Flexibility
Mean Squared Error
FIGURE 2.11. Details are as in Figure 2.9, using a different f that is far from linear. In this setting, linear regression provides a very poor fit to the data.
Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, for a given value x0, can always be decomposed into the sum of three fundamental quantities: the variance of fˆ(x0), the squared bias of fˆ(x0) and the variance of the error variance
bias
terms ε. That is,
E
(
y0 − fˆ(x0)
)2
= Var(fˆ(x0)) + [Bias(fˆ(x0))]2 + Var(ε). (2.7)
Here the notation E
(
y0 − fˆ(x0)
)2 defines the expected test MSE at x0, expected
test MSE
and refers to the average test MSE that we would obtain if we repeatedly estimated f using a large number of training sets, and tested each at x0. The
overall expected test MSE can be computed by averaging E
(
y0 − fˆ(x0)
)2
over all possible values of x0 in the test set. Equation 2.7 tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias. Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below Var(ε), the irreducible error from (2.3). What do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which fˆ would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different fˆ. But ideally the estimate for f should not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in fˆ. In general, more flexible statistical methods have higher variance. Consider the green and orange curves in Figure 2.9. The flexible green curve is following the observations very closely. It has high variance because changing any one of these data points may cause the estimate fˆ to change considerably.


2.2 Assessing Model Accuracy 33
2 5 10 20
0.0 0.5 1.0 1.5 2.0 2.5
Flexibility
2 5 10 20
0.0 0.5 1.0 1.5 2.0 2.5
Flexibility
2 5 10 20
0 5 10 15 20
Flexibility
MSE Bias Var
FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var(ε) (dashed line), and test MSE (red curve) for the three data sets in Figures 2.9–2.11. The vertical dotted line indicates the flexibility level corresponding to the smallest test MSE.
In contrast, the orange least squares line is relatively inflexible and has low variance, because moving any single observation will likely cause only a small shift in the position of the line. On the other hand, bias refers to the error that is introduced by approximating a real-life problem, which may be extremely complicated, by a much simpler model. For example, linear regression assumes that there is a linear relationship between Y and X1, X2, . . . , Xp. It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing linear regression will undoubtedly result in some bias in the estimate of f . In Figure 2.11, the true f is substantially non-linear, so no matter how many training observations we are given, it will not be possible to produce an accurate estimate using linear regression. In other words, linear regression results in high bias in this example. However, in Figure 2.10 the true f is very close to linear, and so given enough data, it should be possible for linear regression to produce an accurate estimate. Generally, more flexible methods result in less bias. As a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand panels of Figures 2.9–2.11. The three plots in Figure 2.12 illustrate Equation 2.7 for the examples in Figures 2.9–2.11. In each case the blue solid curve represents the squared bias, for different levels of flexibility, while the orange curve corresponds to the variance. The horizontal dashed line represents Var(ε), the irreducible error. Finally, the red curve, corresponding to the test set MSE, is the sum


34 2. Statistical Learning
of these three quantities. In all three cases, the variance increases and the bias decreases as the method’s flexibility increases. However, the flexibility level corresponding to the optimal test MSE differs considerably among the three data sets, because the squared bias and variance change at different rates in each of the data sets. In the left-hand panel of Figure 2.12, the bias initially decreases rapidly, resulting in an initial sharp decrease in the expected test MSE. On the other hand, in the center panel of Figure 2.12 the true f is close to linear, so there is only a small decrease in bias as flexibility increases, and the test MSE only declines slightly before increasing rapidly as the variance increases. Finally, in the right-hand panel of Figure 2.12, as flexibility increases, there is a dramatic decline in bias because the true f is very non-linear. There is also very little increase in variance as flexibility increases. Consequently, the test MSE declines substantially before experiencing a small increase as model flexibility increases. The relationship between bias, variance, and test set MSE given in Equation 2.7 and displayed in Figure 2.12 is referred to as the bias-variance trade-off. Good test set performance of a statistical learning method re- bias-variance
trade-off
quires low variance as well as low squared bias. This is referred to as a trade-off because it is easy to obtain a method with extremely low bias but high variance (for instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias (by fitting a horizontal line to the data). The challenge lies in finding a method for which both the variance and the squared bias are low. This trade-off is one of the most important recurring themes in this book. In a real-life situation in which f is unobserved, it is generally not possible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind. In this book we explore methods that are extremely flexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true f is linear. In this situation linear regression will have no bias, making it very hard for a more flexible method to compete. In contrast, if the true f is highly non-linear and we have an ample number of training observations, then we may do better using a highly flexible approach, as in Figure 2.11. In Chapter 5 we discuss cross-validation, which is a way to estimate the test MSE using the training data.
2.2.3 The Classification Setting
Thus far, our discussion of model accuracy has been focused on the regression setting. But many of the concepts that we have encountered, such as the bias-variance trade-off, transfer over to the classification setting with only some modifications due to the fact that yi is no longer quantitative. Suppose that we seek to estimate f on the basis of training observations {(x1, y1), . . . , (xn, yn)}, where now y1, . . . , yn are qualitative. The most common approach for quantifying the accuracy of our estimate fˆ is the training error rate, the proportion of mistakes that are made if we apply error rate


2.2 Assessing Model Accuracy 35
our estimate fˆ to the training observations:
1 n
∑n
i=1
I(yi ̸= yˆi). (2.8)
Here yˆi is the predicted class label for the ith observation using fˆ. And I(yi ̸= yˆi) is an indicator variable that equals 1 if yi ̸= yˆi and zero if yi = yˆi. indicator
variable
If I(yi ̸= yˆi) = 0 then the ith observation was classified correctly by our classification method; otherwise it was misclassified. Hence Equation 2.8 computes the fraction of incorrect classifications. Equation 2.8 is referred to as the training error rate because it is com- training
error
puted based on the data that was used to train our classifier. As in the regression setting, we are most interested in the error rates that result from applying our classifier to test observations that were not used in training. The test error rate associated with a set of test observations of the form test error
(x0, y0) is given by Ave (I(y0 ̸= yˆ0)) , (2.9)
where yˆ0 is the predicted class label that results from applying the classifier to the test observation with predictor x0. A good classifier is one for which the test error (2.9) is smallest.
The Bayes Classifier
It is possible to show (though the proof is outside of the scope of this book) that the test error rate given in (2.9) is minimized, on average, by a very simple classifier that assigns each observation to the most likely class, given its predictor values. In other words, we should simply assign a test observation with predictor vector x0 to the class j for which
Pr(Y = j|X = x0) (2.10)
is largest. Note that (2.10) is a conditional probability: it is the probability conditional
probability
that Y = j, given the observed predictor vector x0. This very simple classifier is called the Bayes classifier. In a two-class problem where there are Bayes
classifier
only two possible response values, say class 1 or class 2, the Bayes classifier corresponds to predicting class one if Pr(Y = 1|X = x0) > 0.5, and class two otherwise. Figure 2.13 provides an example using a simulated data set in a twodimensional space consisting of predictors X1 and X2. The orange and blue circles correspond to training observations that belong to two different classes. For each value of X1 and X2, there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of X1 and X2. The orange shaded region reflects the set of points for which Pr(Y = orange|X) is greater than 50 %, while the blue shaded region indicates the set of points for which the probability is below 50 %. The purple dashed line represents the points where the probability is exactly 50 %. This is called the Bayes decision boundary. The Bayes Bayes
decision boundary
classifier’s prediction is determined by the Bayes decision boundary; an observation that falls on the orange side of the boundary will be assigned


36 2. Statistical Learning
o o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
oo
o
o
oo o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o o o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
oo o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
X1
X2
FIGURE 2.13. A simulated data set consisting of 100 observations in each of two groups, indicated in blue and in orange. The purple dashed line represents the Bayes decision boundary. The orange background grid indicates the region in which a test observation will be assigned to the orange class, and the blue background grid indicates the region in which a test observation will be assigned to the blue class.
to the orange class, and similarly an observation on the blue side of the boundary will be assigned to the blue class. The Bayes classifier produces the lowest possible test error rate, called the Bayes error rate. Since the Bayes classifier will always choose the class Bayes error
rate
for which (2.10) is largest, the error rate will be 1−maxj Pr(Y = j|X = x0) at X = x0. In general, the overall Bayes error rate is given by
1−E
(
mjax Pr(Y = j|X)
)
, (2.11)
where the expectation averages the probability over all possible values of X. For our simulated data, the Bayes error rate is 0.133. It is greater than zero, because the classes overlap in the true population, which implies that maxj Pr(Y = j|X = x0) < 1 for some values of x0. The Bayes error rate is analogous to the irreducible error, discussed earlier.
K-Nearest Neighbors
In theory we would always like to predict qualitative responses using the Bayes classifier. But for real data, we do not know the conditional distribution of Y given X, and so computing the Bayes classifier is impossible. Therefore, the Bayes classifier serves as an unattainable gold standard against which to compare other methods. Many approaches attempt to estimate the conditional distribution of Y given X, and then classify a given observation to the class with highest estimated probability. One such method is the K-nearest neighbors (KNN) classifier. Given a positive in- K-nearest
neighbors


2.2 Assessing Model Accuracy 37
teger K and a test observation x0, the KNN classifier first identifies the K points in the training data that are closest to x0, represented by N0. It then estimates the conditional probability for class j as the fraction of points in N0 whose response values equal j:
Pr(Y = j|X = x0) = 1
K
∑
i∈N0
I(yi = j). (2.12)
Finally, KNN classifies the test observation x0 to the class with the largest probability from (2.12). Figure 2.14 provides an illustrative example of the KNN approach. In the left-hand panel, we have plotted a small training data set consisting of six blue and six orange observations. Our goal is to make a prediction for the point labeled by the black cross. Suppose that we choose K = 3. Then KNN will first identify the three observations that are closest to the cross. This neighborhood is shown as a circle. It consists of two blue points and one orange point, resulting in estimated probabilities of 2/3 for the blue class and 1/3 for the orange class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14 we have applied the KNN approach with K = 3 at all of the possible values for X1 and X2, and have drawn in the corresponding KNN decision boundary. Despite the fact that it is a very simple approach, KNN can often produce classifiers that are surprisingly close to the optimal Bayes classifier. Figure 2.15 displays the KNN decision boundary, using K = 10, when applied to the larger simulated data set from Figure 2.13. Notice that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier. The test error rate using KNN is 0.1363, which is close to the Bayes error rate of 0.1304. The choice of K has a drastic effect on the KNN classifier obtained. Figure 2.16 displays two KNN fits to the simulated data from Figure 2.13, using K = 1 and K = 100. When K = 1, the decision boundary is overly flexible and finds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance. As K grows, the method becomes less flexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classifier. On this simulated data set, neither K = 1 nor K = 100 give good predictions: they have test error rates of 0.1695 and 0.1925, respectively. Just as in the regression setting, there is not a strong relationship between the training error rate and the test error rate. With K = 1, the KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not. In Figure 2.17, we have plotted the KNN test and training errors as a function of 1/K. As 1/K increases, the method becomes more flexible. As in the regression setting, the training error rate consistently declines as the flexibility increases. However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately K = 10) before increasing again when the method becomes excessively flexible and overfits.


38 2. Statistical Learning
o
o
o
o
o
oo
o
o
o
o
oo
o
o
o
o
oo
o
o
o
o
o
FIGURE 2.14. The KNN approach, using K = 3, is illustrated in a simple situation with six blue observations and six orange observations. Left: a test observation at which a predicted class label is desired is shown as a black cross. The three closest points to the test observation are identified, and it is predicted that the test observation belongs to the most commonly-occurring class, in this case blue. Right: The KNN decision boundary for this example is shown in black. The blue grid indicates the region in which a test observation will be assigned to the blue class, and the orange grid indicates the region in which it will be assigned to the orange class.
o o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
oo
o
o
oo o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
oo o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
X1
X2
KNN: K=10
FIGURE 2.15. The black curve indicates the KNN decision boundary on the data from Figure 2.13, using K = 10. The Bayes decision boundary is shown as a purple dashed line. The KNN and Bayes decision boundaries are very similar.
In both the regression and classification settings, choosing the correct level of flexibility is critical to the success of any statistical learning method. The bias-variance tradeoff, and the resulting U-shape in the test error, can make this a difficult task. In Chapter 5, we return to this topic and discuss


2.2 Assessing Model Accuracy 39
o o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
oo
o
o
oo o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
oo
o
o
o
o
o o o
oo
o
o
o
o
o
o
o o
o
o
o
o
o
o
o oo o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
oo
o
o
oo o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
oo
o
o
o
o
o o o
oo
o
o
o
o
o
o
o o
o
o
o
o
o
o
o oo o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
KNN: K=1 KNN: K=100
FIGURE 2.16. A comparison of the KNN decision boundaries (solid black curves) obtained using K = 1 and K = 100 on the data from Figure 2.13. With K = 1, the decision boundary is overly flexible, while with K = 100 it is not sufficiently flexible. The Bayes decision boundary is shown as a purple dashed line.
0.01 0.02 0.05 0.10 0.20 0.50 1.00
0.00 0.05 0.10 0.15 0.20
1/K
Error Rate
Training Errors Test Errors
FIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from Figure 2.13, as the level of flexibility (assessed using 1/K on the log scale) increases, or equivalently as the number of neighbors K decreases. The black dashed line indicates the Bayes error rate. The jumpiness of the curves is due to the small size of the training data set.
various methods for estimating test error rates and thereby choosing the optimal level of flexibility for a given statistical learning method.


40 2. Statistical Learning
2.3 Lab: Introduction to Python
2.3.1 Getting Started
To run the labs in this book, you will need two things:
1. An installation of Python3, which is the specific version of Python used in the labs.
2. Access to Jupyter, a very popular Python interface that runs code through a file called a notebook. notebook
You can download and install Python3 by following the instructions available at anaconda.com. There are a number of ways to get access to Jupyter. Here are just a few:
1. Using Google’s Colaboratory service: colab.research.google.com/.
2. Using JupyterHub, available at jupyter.org/hub.
3. Using your own jupyter installation. Installation instructions are available at jupyter.org/install.
Please see the Python resources page on the book website statlearning.com for up-to-date information about getting Python and Jupyter working on your computer. You will need to install the ISLP package, which provides access to the datasets and custom-built functions that we provide. Inside a macOS or Linux terminal type pip install ISLP; this also installs most other packages needed in the labs. The Python resources page has a link to the ISLP documentation website. To run this lab, download the file Ch2-statlearn-lab.ipynb from the Python resources page. Now run the following code at the command line: jupyter lab Ch2-statlearn-lab.ipynb.
If you’re using Windows, you can use the start menu to access anaconda, and follow the links. For example, to install ISLP and run this lab, you can run the same code above in an anaconda shell.
2.3.2 Basic Commands
In this lab, we will introduce some simple Python commands. For more resources about Python in general, readers may want to consult the tutorial at docs.python.org/3/tutorial/. Like most programming languages, Python uses functions to perform op- function
erations. To run a function called fun, we type fun(input1,input2), where the inputs (or arguments) input1 and input2 tell Python how to run the function. A function can have any number of inputs. For example, the argument
print() function outputs a text representation of all of its arguments to print()
the console.
In [1]: print('fit a model with ', 11, 'variables ')


2.3 Lab: Introduction to Python 41
fit a model with 11 variables
The following command will provide information about the print() function.
In [2]: print?
Adding two integers in Python is pretty intuitive.
In [3]: 3 + 5
Out[3]: 8
In Python, textual data is handled using strings. For instance, "hello" and string
'hello' are strings. We can concatenate them using the addition + symbol.
In [4]: "hello" + " " + "world"
Out[4]: 'hello world '
A string is actually a type of sequence: this is a generic term for an ordered sequence
list. The three most important types of sequences are lists, tuples, and strings. We introduce lists now. The following command instructs Python to join together the numbers 3, 4, and 5, and to save them as a list named x. When we type x, it gives us list
back the list.
In [5]: x = [3, 4, 5] x
Out[5]: [3, 4, 5]
Note that we used the brackets [] to construct this list. We will often want to add two sets of numbers together. It is reasonable to try the following code, though it will not produce the desired results.
In [6]: y = [4, 9, 7] x+y
Out[6]: [3, 4, 5, 4, 9, 7]
The result may appear slightly counterintuitive: why did Python not add the entries of the lists element-by-element? In Python, lists hold arbitrary objects, and are added using concatenation. In fact, concatenation is the concatenat
ion
behavior that we saw earlier when we entered "hello" + " " + "world". This example reflects the fact that Python is a general-purpose programming language. Much of Python’s data-specific functionality comes from other packages, notably numpy and pandas. In the next section, we will introduce the numpy package. See docs.scipy.org/doc/numpy/user/quickstart.html for more information about numpy.


42 2. Statistical Learning
2.3.3 Introduction to Numerical Python
As mentioned earlier, this book makes use of functionality that is contained in the numpy library, or package. A package is a collection of modules that numpy
package
are not necessarily included in the base Python distribution. The name numpy is an abbreviation for numerical Python. To access numpy, we must first import it. import
In [7]: import numpy as np
In the previous line, we named the numpy module np; an abbreviation for module
easier referencing. In numpy, an array is a generic term for a multidimensional set of numbers. array
We use the np.array() function to define x and y, which are one-dimensional np.array()
arrays, i.e. vectors.
In [8]: x = np.array ([3, 4, 5]) y = np.array([4, 9, 7])
Note that if you forgot to run the import numpy as np command earlier, then you will encounter an error in calling the np.array() function in the previous line. The syntax np.array() indicates that the function being called is part of the numpy package, which we have abbreviated as np. Since x and y have been defined using np.array(), we get a sensible result when we add them together. Compare this to our results in the previous section, when we tried to add two lists without using numpy.
In [9]: x + y
Out[9]: array ([ 7, 13, 12])
In numpy, matrices are typically represented as two-dimensional arrays, and vectors as one-dimensional arrays.1 We can create a two-dimensional array as follows.
In [10]: x = np.array ([[1, 2], [3, 4]]) x
Out[10]: array ([[1, 2], [3, 4]])
The object x has several attributes, or associated objects. To access an attribute
attribute of x, we type x.attribute, where we replace attribute with the name of the attribute. For instance, we can access the ndim attribute of x ndim
as follows.
In [11]: x.ndim
Out[11]: 2
The output indicates that x is a two-dimensional array. Similarly, x.dtype is the data type attribute of the object x. This indicates that x is comprised data type
of 64-bit integers:
1While it is also possible to create matrices using np.matrix(), we will use np.array() throughout the labs in this book.


2.3 Lab: Introduction to Python 43
In [12]: x.dtype
Out[12]: dtype('int64 ')
Why is x comprised of integers? This is because we created x by passing in exclusively integers to the np.array() function. If we had passed in any decimals, then we would have obtained an array of floating point numbers floating
point
(i.e. real-valued numbers).
In [13]: np.array ([[1, 2], [3.0, 4]]).dtype
Out[13]: dtype('float64 ')
Typing fun? will cause Python to display documentation associated with the function fun, if it exists. We can try this for np.array().
In [14]: np.array?
This documentation indicates that we could create a floating point array by passing a dtype argument into np.array(). dtype
In [15]: np.array ([[1, 2], [3, 4]], float).dtype
Out[15]: dtype('float64 ')
The array x is two-dimensional. We can find out the number of rows and columns by looking at its shape attribute. shape
In [16]: x.shape
Out[16]: (2, 2)
A method is a function that is associated with an object. For instance, method
given an array x, the expression x.sum() sums all of its elements, using the sum() method for arrays. The call x.sum() automatically provides x as the .sum()
first argument to its sum() method.
In [17]: x = np.array ([1, 2, 3, 4]) x.sum()
Out[17]: 10
We could also sum the elements of x by passing in x as an argument to the np.sum() function. np.sum()
In [18]: x = np.array ([1, 2, 3, 4]) np.sum(x)
Out[18]: 10
As another example, the reshape() method returns a new array with the .reshape()
same elements as x, but a different shape. We do this by passing in a tuple tuple


44 2. Statistical Learning
in our call to reshape(), in this case (2, 3). This tuple specifies that we would like to create a two-dimensional array with 2 rows and 3 columns.2 In what follows, the \n character creates a new line.
In [19]: x = np.array ([1, 2, 3, 4, 5, 6]) print('beginning x:\n', x) x_reshape = x.reshape((2, 3)) print('reshaped x:\n', x_reshape)
beginning x: [1 2 3 4 5 6] reshaped x: [[1 2 3] [4 5 6]]
The previous output reveals that numpy arrays are specified as a sequence of rows. This is called row-major ordering, as opposed to column-major ordering.
Python (and hence numpy) uses 0-based indexing. This means that to access the top left element of x_reshape, we type in x_reshape[0,0].
In [20]: x_reshape [0, 0]
Out[20]: 1
Similarly, x_reshape[1,2] yields the element in the second row and the third column of x_reshape.
In [21]: x_reshape [1, 2]
Out[21]: 6
Similarly, x[2] yields the third entry of x. Now, let’s modify the top left element of x_reshape. To our surprise, we discover that the first element of x has been modified as well!
In [22]: print('x before we modify x_reshape :\n', x) print('x_reshape before we modify x_reshape:\n', x_reshape) x_reshape[0, 0] = 5 print('x_reshape after we modify its top left element:\n', x_reshape) print('x after we modify top left element of x_reshape:\n', x)
Out[22]: x before we modify x_reshape: [1 2 3 4 5 6] x_reshape before we modify x_reshape: [[1 2 3] [4 5 6]] x_reshape after we modify its top left element: [[5 2 3]
2Like lists, tuples represent a sequence of objects. Why do we need more than one way to create a sequence? There are a few differences between tuples and lists, but perhaps the most important is that elements of a tuple cannot be modified, whereas elements of a list can be.


2.3 Lab: Introduction to Python 45
[4 5 6]] x after we modify top left element of x_reshape: [5 2 3 4 5 6]
Modifying x_reshape also modified x because the two objects occupy the same space in memory. We just saw that we can modify an element of an array. Can we also modify a tuple? It turns out that we cannot — and trying to do so introduces an exception, or error. exception
In [23]: my_tuple = (3, 4, 5) my_tuple[0] = 2
TypeError: 'tuple' object does not support item assignment
We now briefly mention some attributes of arrays that will come in handy. An array’s shape attribute contains its dimension; this is always a tuple. The ndim attribute yields the number of dimensions, and T provides its transpose.
In [24]: x_reshape.shape , x_reshape.ndim , x_reshape.T
Out[24]: ((2, 3), 2, array([[5, 4], [2, 5], [3, 6]]))
Notice that the three individual outputs (2,3), 2, and array([[5, 4],[2, 5], [3,6]]) are themselves output as a tuple. We will often want to apply functions to arrays. For instance, we can compute the square root of the entries using the np.sqrt() function: np.sqrt()
In [25]: np.sqrt(x)
Out[25]: array ([2.24 , 1.41, 1.73, 2., 2.24, 2.45])
We can also square the elements:
In [26]: x**2
Out[26]: array ([25, 4, 9, 16, 25, 36])
We can compute the square roots using the same notation, raising to the power of 1/2 instead of 2.
In [27]: x**0.5
Out[27]: array ([2.24 , 1.41, 1.73, 2., 2.24, 2.45])
Throughout this book, we will often want to generate random data. The np.random.normal() function generates a vector of random normal variables. np.random.
normal()
We can learn more about this function by looking at the help page, via a call to np.random.normal?. The first line of the help page reads normal(loc=0.0, scale=1.0, size=None). This signature line tells us that the function’s ar- signature


46 2. Statistical Learning
guments are loc, scale, and size. These are keyword arguments, which keyword
means that when they are passed into the function, they can be referred to by name (in any order).3 By default, this function will generate random normal variable(s) with mean (loc) 0 and standard deviation (scale) 1; furthermore, a single random variable will be generated unless the argument to size is changed. We now generate 50 independent random variables from a N (0, 1) distribution.
In [28]: x = np.random.normal(size =50) x
Out[28]: array ([ -1.19 , 0.41, 0.9 , -0.44, -0.9 , -0.38, 0.13, 1.87, -0.35, 1.16, 0.79, -0.97, -1.21, 0.06, -1.62, -0.6 , -0.77, -2.12, 0.38, -1.22, -0.06, -1.97, -1.74, -0.56, 1.7 , -0.95, 0.56, 0.35, 0.87, 0.88, -1.66, -0.32, -0.3 , -1.36, 0.92, -0.31, 1.28, -1.94, 1.07, 0.07, 0.79, -0.46, 2.19, -0.27, -0.64, 0.85, 0.13, 0.46, -0.09, 0.7 ])
We create an array y by adding an independent N (50, 1) random variable to each element of x.
In [29]: y = x + np.random.normal(loc=50, scale=1, size =50)
The np.corrcoef() function computes the correlation matrix between x and np.corrcoef()
y. The off-diagonal elements give the correlation between x and y.
In [30]: np.corrcoef(x, y)
Out[30]: array ([[1. , 0.69] , [0.69, 1. ]])
If you’re following along in your own Jupyter notebook, then you probably noticed that you got a different set of results when you ran the past few commands. In particular, each time we call np.random.normal(), we will get a different answer, as shown in the following example.
In [31]: print(np.random.normal(scale=5, size =2)) print(np.random.normal(scale=5, size=2))
Out[31]: [4.28 2.59] [4.62 -2.54]
In order to ensure that our code provides exactly the same results each time it is run, we can set a random seed using the np.random.default_rng() random seed
np.random. default_rng()
function. This function takes an arbitrary, user-specified integer argument. If we set a random seed before generating random data, then re-running our code will yield the same results. The object rng has essentially all the
3Python also uses positional arguments. Positional arguments do not need to use a keyword. To see an example, type in np.sum?. We see that a is a positional argument, i.e. this function assumes that the first unnamed argument that it receives is the array to be summed. By contrast, axis and dtype are keyword arguments: the position in which these arguments are entered into np.sum() does not matter.


2.3 Lab: Introduction to Python 47
random number generating methods found in np.random. Hence, to generate normal data we use rng.normal().
In [32]: rng = np.random.default_rng (1303) print(rng.normal(scale=5, size=2)) rng2 = np.random.default_rng(1303) print(rng2.normal(scale=5, size=2))
Out[32]: [4.09 -1.07 ] [4.09 -1.07 ]
Throughout the labs in this book, we use np.random.default_rng() whenever we perform calculations involving random quantities within numpy. In principle, this should enable the reader to exactly reproduce the stated results. However, as new versions of numpy become available, it is possible that some small discrepancies may occur between the output in the labs and the output from numpy. The np.mean(), np.var(), and np.std() functions can be used to compute np.mean()
np.var() np.std()
the mean, variance, and standard deviation of arrays. These functions are also available as methods on the arrays.
In [33]: rng = np.random.default_rng (3) y = rng.standard_normal(10) np.mean(y), y.mean()
Out[33]: (-0.11, -0.11)
In [34]: np.var(y), y.var(), np.mean ((y - y.mean ())**2)
Out[34]: (2.72 , 2.72, 2.72)
Notice that by default np.var() divides by the sample size n rather than n − 1; see the ddof argument in np.var?.
In [35]: np.sqrt(np.var(y)), np.std(y)
Out[35]: (1.65 , 1.65)
The np.mean(), np.var(), and np.std() functions can also be applied to the rows and columns of a matrix. To see this, we construct a 10 × 3 matrix of N (0, 1) random variables, and consider computing its row sums.
In [36]: X = rng.standard_normal ((10, 3)) X
Out[36]: array ([[ 0.23, -0.35, -0.28], [-0.67, -1.06, -0.39], [ 0.48, -0.24, 0.96], [-0.2 , 0.02, 1.55], [ 0.55, -0.51, -0.18], [ 0.54, 1.94, -0.27], [-0.24, 1. , -0.89], [-0.29, 0.88, 0.58], [ 0.09, 0.67, -2.83], [ 1.02, -0.96, -1.67]])


48 2. Statistical Learning
Since arrays are row-major ordered, the first axis, i.e. axis=0, refers to its rows. We pass this argument into the mean() method for the object X. .mean()
In [37]: X.mean(axis =0)
Out[37]: array ([0.15 , 0.14, -0.34])
The following yields the same result.
In [38]: X.mean (0)
Out[38]: array ([0.15 , 0.14, -0.34])
2.3.4 Graphics
In Python, common practice is to use the library matplotlib for graphics. matplotlib
However, since Python was not written with data analysis in mind, the notion of plotting is not intrinsic to the language. We will use the subplots() function from matplotlib.pyplot to create a figure and the axes onto which we plot our data. For many more examples of how to make plots in Python, readers are encouraged to visit matplotlib.org/stable/gallery/. In matplotlib, a plot consists of a figure and one or more axes. You can figure
axes
think of the figure as the blank canvas upon which one or more plots will be displayed: it is the entire plotting window. The axes contain important information about each plot, such as its x- and y-axis labels, title, and more. (Note that in matplotlib, the word axes is not the plural of axis: a plot’s axes contains much more information than just the x-axis and the y-axis.) We begin by importing the subplots() function from matplotlib. We subplots()
use this function throughout when creating figures. The function returns a tuple of length two: a figure object as well as the relevant axes object. We will typically pass figsize as a keyword argument. Having created our axes, we attempt our first plot using its plot() method. To learn more .plot()
about it, type ax.plot?.
In [39]: from matplotlib.pyplot import subplots fig, ax = subplots(figsize=(8, 8)) x = rng.standard_normal(100) y = rng.standard_normal(100) ax.plot(x, y);
We pause here to note that we have unpacked the tuple of length two returned by subplots() into the two distinct variables fig and ax. Unpacking is typically preferred to the following equivalent but slightly more verbose code:
In [40]: output = subplots(figsize =(8, 8)) fig = output[0] ax = output[1]
We see that our earlier cell produced a line plot, which is the default. To create a scatterplot, we provide an additional argument to ax.plot(), indicating that circles should be displayed.


2.3 Lab: Introduction to Python 49
In [41]: fig , ax = subplots(figsize =(8, 8)) ax.plot(x, y, 'o');
Different values of this additional argument can be used to produce different colored lines as well as different linestyles. As an alternative, we could use the ax.scatter() function to create a .scatter()
scatterplot.
In [42]: fig , ax = subplots(figsize =(8, 8)) ax.scatter(x, y, marker='o');
Notice that in the code blocks above, we have ended the last line with a semicolon. This prevents ax.plot(x, y) from printing text to the notebook. However, it does not prevent a plot from being produced. If we omit the trailing semi-colon, then we obtain the following output:
In [43]: fig , ax = subplots(figsize =(8, 8)) ax.scatter(x, y, marker='o')
Out[43]: <matplotlib.collections.PathCollection at 0x7fb3d9c8f310 > Figure(432x288)
In what follows, we will use trailing semicolons whenever the text that would be output is not germane to the discussion at hand. To label our plot, we make use of the set_xlabel(), set_ylabel(), and .set_xlabel()
.set_ylabel()
set_title() methods of ax.
.set_title()
In [44]: fig , ax = subplots(figsize =(8, 8)) ax.scatter(x, y, marker='o') ax.set_xlabel("this is the x-axis") ax.set_ylabel("this is the y-axis") ax.set_title("Plot of X vs Y");
Having access to the figure object fig itself means that we can go in and change some aspects and then redisplay it. Here, we change the size from (8, 8) to (12, 3).
fig.set_size_inches(12,3) fig
Occasionally we will want to create several plots within a figure. This can be achieved by passing additional arguments to subplots(). Below, we create a 2 × 3 grid of plots in a figure of size determined by the figsize argument. In such situations, there is often a relationship between the axes in the plots. For example, all plots may have a common x-axis. The subplots() function can automatically handle this situation when passed the keyword argument sharex=True. The axes object below is an array pointing to different plots in the figure.
In [45]: fig , axes = subplots(nrows=2, ncols=3, figsize=(15, 5))
We now produce a scatter plot with 'o' in the second column of the first row and a scatter plot with '+' in the third column of the second row.


50 2. Statistical Learning
In [46]: axes [0 ,1]. plot(x, y, 'o') axes[1,2].scatter(x, y, marker='+') fig
Type subplots? to learn more about subplots(). To save the output of fig, we call its savefig() method. The argument .savefig()
dpi is the dots per inch, used to determine how large the figure will be in pixels.
In [47]: fig.savefig("Figure.png", dpi =400) fig.savefig("Figure.pdf", dpi=200);
We can continue to modify fig using step-by-step updates; for example, we can modify the range of the x-axis, re-save the figure, and even re-display it.
In [48]: axes [0 ,1]. set_xlim ([-1 ,1]) fig.savefig("Figure_updated.jpg") fig
We now create some more sophisticated plots. The ax.contour() method .contour()
produces a contour plot in order to represent three-dimensional data, similar contour plot
to a topographical map. It takes three arguments:
• A vector of x values (the first dimension),
• A vector of y values (the second dimension), and
• A matrix whose elements correspond to the z value (the third dimension) for each pair of (x,y) coordinates.
To create x and y, we’ll use the command np.linspace(a, b, n), which np.linspace()
returns a vector of n numbers starting at a and ending at b.
In [49]: fig , ax = subplots(figsize =(8, 8)) x = np.linspace(-np.pi, np.pi, 50) y=x f = np.multiply.outer(np.cos(y), 1 / (1 + x**2)) ax.contour(x, y, f);
We can increase the resolution by adding more levels to the image.
In [50]: fig , ax = subplots(figsize =(8, 8)) ax.contour(x, y, f, levels=45);
To fine-tune the output of the ax.contour() function, take a look at the help file by typing ?plt.contour. The ax.imshow() method is similar to ax.contour(), except that it pro- .imshow()
duces a color-coded plot whose colors depend on the z value. This is known as a heatmap, and is sometimes used to plot temperature in weather fore- heatmap
casts.
In [51]: fig , ax = subplots(figsize =(8, 8)) ax.imshow(f);


2.3 Lab: Introduction to Python 51
2.3.5 Sequences and Slice Notation
As seen above, the function np.linspace() can be used to create a sequence of numbers.
In [52]: seq1 = np.linspace (0, 10, 11) seq1
Out[52]: array ([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])
The function np.arange() returns a sequence of numbers spaced out by np.arange()
step. If step is not specified, then a default value of 1 is used. Let’s create a sequence that starts at 0 and ends at 10.
In [53]: seq2 = np.arange (0, 10) seq2
Out[53]: array ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
Why isn’t 10 output above? This has to do with slice notation in Python. slice
Slice notation is used to index sequences such as lists, tuples and arrays. Suppose we want to retrieve the fourth through sixth (inclusive) entries of a string. We obtain a slice of the string using the indexing notation [3:6].
In [54]: "hello world"[3:6]
Out[54]: 'lo '
In the code block above, the notation 3:6 is shorthand for slice(3,6) when used inside [].
In [55]: "hello world"[slice (3,6)]
Out[55]: 'lo '
You might have expected slice(3,6) to output the fourth through seventh characters in the text string (recalling that Python begins its indexing at zero), but instead it output the fourth through sixth. This also explains why the earlier np.arange(0, 10) command output only the integers from 0 to 9. See the documentation slice? for useful options in creating slices.
2.3.6 Indexing Data
To begin, we create a two-dimensional numpy array.
In [56]: A = np.array(np.arange (16)).reshape ((4, 4)) A
Out[56]: array ([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])
Typing A[1,2] retrieves the element corresponding to the second row and third column. (As usual, Python indexes from 0.)


52 2. Statistical Learning
In [57]: A[1,2]
Out[57]: 6
The first number after the open-bracket symbol [ refers to the row, and the second number refers to the column.
Indexing Rows, Columns, and Submatrices
To select multiple rows at a time, we can pass in a list specifying our selection. For instance, [1,3] will retrieve the second and fourth rows:
In [58]: A[[1 ,3]]
Out[58]: array ([[ 4, 5, 6, 7], [12, 13, 14, 15]])
To select the first and third columns, we pass in [0,2] as the second argument in the square brackets. In this case we need to supply the first argument : which selects all rows.
In [59]: A[: ,[0 ,2]]
Out[59]: array ([[ 0, 2], [ 4, 6], [ 8, 10], [12, 14]])
Now, suppose that we want to select the submatrix made up of the second and fourth rows as well as the first and third columns. This is where indexing gets slightly tricky. It is natural to try to use lists to retrieve the rows and columns:
In [60]: A[[1 ,3] ,[0 ,2]]
Out[60]: array ([ 4, 14])
Oops — what happened? We got a one-dimensional array of length two identical to
In [61]: np.array ([A[1,0],A[3 ,2]])
Out[61]: array ([ 4, 14])
Similarly, the following code fails to extract the submatrix comprised of the second and fourth rows and the first, third, and fourth columns:
In [62]: A[[1 ,3] ,[0 ,2 ,3]]
IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (3,)


2.3 Lab: Introduction to Python 53
We can see what has gone wrong here. When supplied with two indexing lists, the numpy interpretation is that these provide pairs of i, j indices for a series of entries. That is why the pair of lists must have the same length. However, that was not our intent, since we are looking for a submatrix. One easy way to do this is as follows. We first create a submatrix by subsetting the rows of A, and then on the fly we make a further submatrix by subsetting its columns.
In [63]: A[[1 ,3]][: ,[0 ,2]]
Out[63]: array ([[ 4, 6], [12, 14]])
There are more efficient ways of achieving the same result. The convenience function np.ix_() allows us to extract a submatrix using convenience
function np.ix_()
lists, by creating an intermediate mesh object.
mesh
In [64]: idx = np.ix_ ([1 ,3] ,[0 ,2 ,3]) A[idx]
Out[64]: array ([[ 4, 6, 7], [12, 14, 15]])
Alternatively, we can subset matrices efficiently using slices. The slice 1:4:2 captures the second and fourth items of a sequence, while the slice 0:3:2 captures the first and third items (the third element in a slice sequence is the step size).
In [65]: A[1:4:2 ,0:3:2]
Out[65]: array ([[ 4, 6], [12, 14]])
Why are we able to retrieve a submatrix directly using slices but not using lists? Its because they are different Python types, and are treated differently by numpy. Slices can be used to extract objects from arbitrary sequences, such as strings, lists, and tuples, while the use of lists for indexing is more limited.
Boolean Indexing
In numpy, a Boolean is a type that equals either True or False (also rep- Boolean
resented as 1 and 0, respectively). The next line creates a vector of 0’s, represented as Booleans, of length equal to the first dimension of A.
In [66]: keep_rows = np.zeros(A.shape [0], bool) keep_rows
Out[66]: array ([False , False , False , False ])
We now set two of the elements to True.
In [67]: keep_rows [[1 ,3]] = True keep_rows


54 2. Statistical Learning
Out[67]: array ([False , True , False , True ])
Note that the elements of keep_rows, when viewed as integers, are the same as the values of np.array([0,1,0,1]). Below, we use == to verify their equality. When applied to two arrays, the == operation is applied elementwise.
In [68]: np.all(keep_rows == np.array ([0 ,1 ,0 ,1]))
Out[68]: True
(Here, the function np.all() has checked whether all entries of an array np.all()
are True. A similar function, np.any(), can be used to check whether any np.any()
entries of an array are True.) However, even though np.array([0,1,0,1]) and keep_rows are equal according to ==, they index different sets of rows! The former retrieves the first, second, first, and second rows of A.
In [69]: A[np.array ([0 ,1 ,0 ,1])]
Out[69]: array ([[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 2, 3], [4, 5, 6, 7]])
By contrast, keep_rows retrieves only the second and fourth rows of A i.e. the rows for which the Boolean equals TRUE.
In [70]: A[keep_rows]
Out[70]: array ([[ 4, 5, 6, 7], [12, 13, 14, 15]])
This example shows that Booleans and integers are treated differently by numpy.
We again make use of the np.ix_() function to create a mesh containing the second and fourth rows, and the first, third, and fourth columns. This time, we apply the function to Booleans, rather than lists.
In [71]: keep_cols = np.zeros(A.shape [1], bool) keep_cols[[0, 2, 3]] = True idx_bool = np.ix_(keep_rows , keep_cols) A[idx_bool]
Out[71]: array ([[ 4, 6, 7], [12, 14, 15]])
We can also mix a list with an array of Booleans in the arguments to np.ix_():
In [72]: idx_mixed = np.ix_([1,3], keep_cols) A[idx_mixed]
Out[72]: array ([[ 4, 6, 7], [12, 14, 15]])
For more details on indexing in numpy, readers are referred to the numpy tutorial mentioned earlier.


2.3 Lab: Introduction to Python 55
2.3.7 Loading Data
Data sets often contain different types of data, and may have names associated with the rows or columns. For these reasons, they typically are best accommodated using a data frame. We can think of a data frame as data frame
a sequence of arrays of identical length; these are the columns. Entries in the different arrays can be combined to form a row. The pandas library can be used to create and work with data frame objects.
Reading in a Data Set
The first step of most analyses involves importing a data set into Python. Before attempting to load a data set, we must make sure that Python knows where to find the file containing it. If the file is in the same location as this notebook file, then we are all set. Otherwise, the command os.chdir() can os.chdir()
be used to change directory. (You will need to call import os before calling os.chdir().)
We will begin by reading in Auto.csv, available on the book website. This is a comma-separated file, and can be read in using pd.read_csv(): pd.read_csv()
In [73]: import pandas as pd Auto = pd.read_csv('Auto.csv') Auto
The book website also has a whitespace-delimited version of this data, called Auto.data. This can be read in as follows:
In [74]: Auto = pd.read_csv('Auto.data ', delim_whitespace=True)
Both Auto.csv and Auto.data are simply text files. Before loading data into Python, it is a good idea to view it using a text editor or other software, such as Microsoft Excel. We now take a look at the column of Auto corresponding to the variable horsepower:
In [75]: Auto['horsepower ']
Out[75]: 0 130.0 1 165.0 2 150.0 3 150.0 4 140.0 ... 392 86.00 393 52.00 394 84.00 395 79.00 396 82.00 Name: horsepower , Length: 397, dtype: object
We see that the dtype of this column is object. It turns out that all values of the horsepower column were interpreted as strings when reading in the data. We can find out why by looking at the unique values.
In [76]: np.unique(Auto['horsepower '])


56 2. Statistical Learning
To save space, we have omitted the output of the previous code block. We see the culprit is the value ?, which is being used to encode missing values. To fix the problem, we must provide pd.read_csv() with an argument called na_values. Now, each instance of ? in the file is replaced with the value np.nan, which means not a number:
In [77]: Auto = pd.read_csv('Auto.data ', na_values=['?'], delim_whitespace=True) Auto['horsepower'].sum()
Out[77]: 40952.0
The Auto.shape attribute tells us that the data has 397 observations, or rows, and nine variables, or columns.
In [78]: Auto.shape
Out[78]: (397, 9)
There are various ways to deal with missing data. In this case, since only five of the rows contain missing observations, we choose to use the Auto.dropna() method to simply remove these rows. .dropna()
In [79]: Auto_new = Auto.dropna () Auto_new.shape
Out[79]: (392, 9)
Basics of Selecting Rows and Columns
We can use Auto.columns to check the variable names.
In [80]: Auto = Auto_new # overwrite the previous value Auto.columns
Out[80]: Index (['mpg', 'cylinders ', 'displacement ', 'horsepower ', 'weight', 'acceleration', 'year', 'origin', 'name'], dtype='object')
Accessing the rows and columns of a data frame is similar, but not identical, to accessing the rows and columns of an array. Recall that the first argument to the [] method is always applied to the rows of the array. Similarly, passing in a slice to the [] method creates a data frame whose rows are determined by the slice:
In [81]: Auto [:3]
Out[81]: mpg cylinders displacement horsepower weight ... 0 18.0 8 307.0 130.0 3504.0 ... 1 15.0 8 350.0 165.0 3693.0 ... 2 18.0 8 318.0 150.0 3436.0 ...
Similarly, an array of Booleans can be used to subset the rows:


2.3 Lab: Introduction to Python 57
In [82]: idx_80 = Auto['year '] > 80 Auto[idx_80]
However, if we pass in a list of strings to the [] method, then we obtain a data frame containing the corresponding set of columns.
In [83]: Auto [['mpg', 'horsepower ']]
Out[83]: mpg horsepower 0 18.0 130.0 1 15.0 165.0 2 18.0 150.0 3 16.0 150.0 4 17.0 140.0 ... ... ... 392 27.0 86.0 393 44.0 52.0 394 32.0 84.0 395 28.0 79.0 396 31.0 82.0 392 rows x 2 columns
Since we did not specify an index column when we loaded our data frame, the rows are labeled using integers 0 to 396.
In [84]: Auto.index
Out[84]: Int64Index ([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ... 387, 388, 389, 390, 391, 392, 393, 394, 395, 396], dtype='int64', length=392)
We can use the set_index() method to re-name the rows using the contents .set_index()
of Auto['name'].
In [85]: Auto_re = Auto.set_index('name ') Auto_re
Out[85]: mpg cylinders displacement ... name
chevrolet chevelle malibu 18.0 8 307.0 ... buick skylark 32 15.0 8 350.0 ... plymouth satellite 18.0 8 318.0 ... amc rebel sst 16.0 8 304.0 ...
In [86]: Auto_re.columns
Out[86]: Index (['mpg', 'cylinders ', 'displacement ', 'horsepower ', 'weight', 'acceleration', 'year', 'origin'], dtype='object')
We see that the column 'name' is no longer there. Now that the index has been set to name, we can access rows of the data frame by name using the loc[] method of Auto: .loc[]


58 2. Statistical Learning
In [87]: rows = ['amc rebel sst', 'ford torino '] Auto_re.loc[rows]
Out[87]: mpg cylinders displacement horsepower ... name amc rebel sst 16.0 8 304.0 150.0 ... ford torino 17.0 8 302.0 140.0 ...
As an alternative to using the index name, we could retrieve the 4th and 5th rows of Auto using the iloc[] method: .iloc[]
In [88]: Auto_re.iloc [[3 ,4]]
We can also use it to retrieve the 1st, 3rd and and 4th columns of Auto_re:
In [89]: Auto_re.iloc [: ,[0 ,2 ,3]]
We can extract the 4th and 5th rows, as well as the 1st, 3rd and 4th columns, using a single call to iloc[]:
In [90]: Auto_re.iloc [[3 ,4] ,[0 ,2 ,3]]
Out[90]: mpg displacement horsepower name amc rebel sst 16.0 304.0 150.0 ford torino 17.0 302.0 140.0
Index entries need not be unique: there are several cars in the data frame named ford galaxie 500.
In [91]: Auto_re.loc['ford galaxie 500', ['mpg', 'origin ']]
Out[91]: mpg origin name ford galaxie 500 15.0 1 ford galaxie 500 14.0 1 ford galaxie 500 14.0 1
More on Selecting Rows and Columns
Suppose now that we want to create a data frame consisting of the weight and origin of the subset of cars with year greater than 80 — i.e. those built after 1980. To do this, we first create a Boolean array that indexes the rows. The loc[] method allows for Boolean entries as well as strings:
In [92]: idx_80 = Auto_re['year '] > 80 Auto_re.loc[idx_80, ['weight', 'origin']]
To do this more concisely, we can use an anonymous function called a
lambda: lambda
In [93]: Auto_re.loc[lambda df: df['year '] > 80, ['weight ', 'origin ']]
The lambda call creates a function that takes a single argument, here df, and returns df['year']>80. Since it is created inside the loc[] method for


2.3 Lab: Introduction to Python 59
the dataframe Auto_re, that dataframe will be the argument supplied. As another example of using a lambda, suppose that we want all cars built after 1980 that achieve greater than 30 miles per gallon:
In [94]: Auto_re.loc[lambda df: (df['year '] > 80) & (df['mpg'] > 30), ['weight', 'origin'] ]
The symbol & computes an element-wise and operation. As another example, suppose that we want to retrieve all Ford and Datsun cars with displacement less than 300. We check whether each name entry contains either the string ford or datsun using the str.contains() method of the .str.
contains()
index attribute of of the dataframe:
In [95]: Auto_re.loc[lambda df: (df['displacement '] < 300) & (df.index.str.contains('ford') | df.index.str.contains('datsun')), ['weight', 'origin'] ]
Here, the symbol | computes an element-wise or operation. In summary, a powerful set of operations is available to index the rows and columns of data frames. For integer based queries, use the iloc[] method. For string and Boolean selections, use the loc[] method. For functional queries that filter rows, use the loc[] method with a function (typically a lambda) in the rows argument.
2.3.8 For Loops
A for loop is a standard tool in many languages that repeatedly evaluates for
some chunk of code while varying different values inside the code. For example, suppose we loop over elements of a list and compute their sum.
In [96]: total = 0
for value in [3,2,19]: total += value print('Total is: {0}'.format(total))
Total is: 24
The indented code beneath the line with the for statement is run for each value in the sequence specified in the for statement. The loop ends either when the cell ends or when code is indented at the same level as the original for statement. We see that the final line above which prints the total is executed only once after the for loop has terminated. Loops can be nested by additional indentation.
In [97]: total = 0
for value in [2,3,19]: for weight in [3, 2, 1]: total += value * weight print('Total is: {0}'.format(total))
Total is: 144


60 2. Statistical Learning
Above, we summed over each combination of value and weight. We also took advantage of the increment notation in Python: the expression a += b increment
is equivalent to a = a + b. Besides being a convenient notation, this can save time in computationally heavy tasks in which the intermediate value of a+b need not be explicitly created. Perhaps a more common task would be to sum over (value, weight) pairs. For instance, to compute the average value of a random variable that takes on possible values 2, 3 or 19 with probability 0.2, 0.3, 0.5 respectively we would compute the weighted sum. Tasks such as this can often be accomplished using the zip() function that loops over a sequence of tuples. zip()
In [98]: total = 0
for value, weight in zip([2,3,19], [0.2,0.3,0.5]): total += weight * value print('Weighted average is: {0}'.format(total))
Weighted average is: 10.8
String Formatting
In the code chunk above we also printed a string displaying the total. However, the object total is an integer and not a string. Inserting the value of something into a string is a common task, made simple using some of the powerful string formatting tools in Python. Many data cleaning tasks involve manipulating and programmatically producing strings. For example we may want to loop over the columns of a data frame and print the percent missing in each column. Let’s create a data frame D with columns in which 20% of the entries are missing i.e. set to np.nan. np.nan
We’ll create the values in D from a normal distribution with mean 0 and variance 1 using rng.standard_normal() and then overwrite some random entries using rng.choice().
In [99]: rng = np.random.default_rng (1) A = rng.standard_normal((127, 5)) M = rng.choice([0, np.nan], p=[0.8,0.2], size=A.shape) A += M D = pd.DataFrame(A, columns=['food', 'bar', 'pickle', 'snack', 'popcorn']) D[:3]
Out[99]: food bar pickle snack popcorn 0 0.345584 0.821618 0.330437 -1.303157 NaN 1 NaN -0.536953 0.581118 0.364572 0.294132 2 NaN 0.546713 NaN -0.162910 -0.482119
In [100]: for col in D.columns: template = 'Column "{0}" has {1:.2%} missing values' print ( template . format (col , np.isnan(D[col]).mean()))


2.3 Lab: Introduction to Python 61
Column "food" has 16.54% missing values Column "bar" has 25.98% missing values Column "pickle" has 29.13% missing values Column "snack" has 21.26% missing values Column "popcorn" has 22.83% missing values
We see that the template.format() method expects two arguments {0} and {1:.2%}, and the latter includes some formatting information. In particular, it specifies that the second argument should be expressed as a percent with two decimal digits. The reference docs.python.org/3/library/string.html includes many helpful and more complex examples.
2.3.9 Additional Graphical and Numerical Summaries
We can use the ax.plot() or ax.scatter() functions to display the quantitative variables. However, simply typing the variable names will produce an error message, because Python does not know to look in the Auto data set for those variables.
In [101]: fig , ax = subplots(figsize =(8, 8)) ax.plot(horsepower , mpg, 'o');
NameError: name 'horsepower' is not defined
We can address this by accessing the columns directly:
In [102]: fig , ax = subplots(figsize =(8, 8)) ax.plot(Auto['horsepower'], Auto['mpg'], 'o');
Alternatively, we can use the plot() method with the call Auto.plot(). Us- .plot()
ing this method, the variables can be accessed by name. The plot methods of a data frame return a familiar object: an axes. We can use it to update the plot as we did previously:
In [103]: ax = Auto.plot.scatter('horsepower ', 'mpg'); ax.set_title('Horsepower vs. MPG')
If we want to save the figure that contains a given axes, we can find the relevant figure by accessing the figure attribute:
In [104]: fig = ax.figure fig.savefig('horsepower_mpg.png');
We can further instruct the data frame to plot to a particular axes object. In this case the corresponding plot() method will return the modified axes we passed in as an argument. Note that when we request a one-dimensional grid of plots, the object axes is similarly one-dimensional. We place our scatter plot in the middle plot of a row of three plots within a figure.
In [105]: fig , axes = subplots(ncols=3, figsize =(15, 5)) Auto.plot.scatter('horsepower', 'mpg', ax=axes[1]);
Note also that the columns of a data frame can be accessed as attributes: try typing in Auto.horsepower.


62 2. Statistical Learning
We now consider the cylinders variable. Typing in Auto.cylinders.dtype reveals that it is being treated as a quantitative variable. However, since there is only a small number of possible values for this variable, we may wish to treat it as qualitative. Below, we replace the cylinders column with a categorical version of Auto.cylinders. The function pd.Series() owes its pd.Series()
name to the fact that pandas is often used in time series applications.
In [106]: Auto.cylinders = pd.Series(Auto.cylinders , dtype='category ') Auto.cylinders.dtype
Now that cylinders is qualitative, we can display it using the boxplot() .boxplot()
method.
In [107]: fig , ax = subplots(figsize =(8, 8)) Auto.boxplot('mpg', by='cylinders', ax=ax);
The hist() method can be used to plot a histogram. .hist()
In [108]: fig , ax = subplots(figsize =(8, 8)) Auto.hist('mpg', ax=ax);
The color of the bars and the number of bins can be changed:
In [109]: fig , ax = subplots(figsize =(8, 8)) Auto.hist('mpg', color='red', bins=12, ax=ax);
See Auto.hist? for more plotting options. We can use the pd.plotting.scatter_matrix() function to create a scat- pd.plotting.
scatter_ matrix()
terplot matrix to visualize all of the pairwise relationships between the columns in a data frame.
In [110]: pd.plotting.scatter_matrix(Auto);
We can also produce scatterplots for a subset of the variables.
In [111]: pd.plotting.scatter_matrix(Auto [['mpg', 'displacement', 'weight']]);
The describe() method produces a numerical summary of each column in .describe()
a data frame.
In [112]: Auto [['mpg', 'weight ']]. describe ()
We can also produce a summary of just a single column.
In [113]: Auto['cylinders ']. describe () Auto['mpg'].describe()
To exit Jupyter, select File / Close and Halt.


2.4 Exercises 63
2.4 Exercises
Conceptual
1. For each of parts (a) through (d), indicate whether we would generally expect the performance of a flexible statistical learning method to be better or worse than an inflexible method. Justify your answer.
(a) The sample size n is extremely large, and the number of predictors p is small.
(b) The number of predictors p is extremely large, and the number of observations n is small.
(c) The relationship between the predictors and response is highly non-linear.
(d) The variance of the error terms, i.e. σ2 = Var(ε), is extremely high.
2. Explain whether each scenario is a classification or regression problem, and indicate whether we are most interested in inference or prediction. Finally, provide n and p.
(a) We collect a set of data on the top 500 firms in the US. For each firm we record profit, number of employees, industry and the CEO salary. We are interested in understanding which factors affect CEO salary.
(b) We are considering launching a new product and wish to know whether it will be a success or a failure. We collect data on 20 similar products that were previously launched. For each product we have recorded whether it was a success or failure, price charged for the product, marketing budget, competition price, and ten other variables.
(c) We are interested in predicting the % change in the USD/Euro exchange rate in relation to the weekly changes in the world stock markets. Hence we collect weekly data for all of 2012. For each week we record the % change in the USD/Euro, the % change in the US market, the % change in the British market, and the % change in the German market.
3. We now revisit the bias-variance decomposition.
(a) Provide a sketch of typical (squared) bias, variance, training error, test error, and Bayes (or irreducible) error curves, on a single plot, as we go from less flexible statistical learning methods towards more flexible approaches. The x-axis should represent the amount of flexibility in the method, and the y-axis should represent the values for each curve. There should be five curves. Make sure to label each one.
(b) Explain why each of the five curves has the shape displayed in part (a).


64 2. Statistical Learning
4. You will now think of some real-life applications for statistical learning.
(a) Describe three real-life applications in which classification might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer.
(b) Describe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer.
(c) Describe three real-life applications in which cluster analysis might be useful.
5. What are the advantages and disadvantages of a very flexible (versus a less flexible) approach for regression or classification? Under what circumstances might a more flexible approach be preferred to a less flexible approach? When might a less flexible approach be preferred?
6. Describe the differences between a parametric and a non-parametric statistical learning approach. What are the advantages of a parametric approach to regression or classification (as opposed to a nonparametric approach)? What are its disadvantages?
7. The table below provides a training data set containing six observations, three predictors, and one qualitative response variable.
Obs. X1 X2 X3 Y 1 0 3 0 Red 2 2 0 0 Red 3 0 1 3 Red 4 0 1 2 Green 5 −1 0 1 Green 6 1 1 1 Red
Suppose we wish to use this data set to make a prediction for Y when X1 = X2 = X3 = 0 using K-nearest neighbors.
(a) Compute the Euclidean distance between each observation and the test point, X1 = X2 = X3 = 0.
(b) What is our prediction with K = 1? Why?
(c) What is our prediction with K = 3? Why?
(d) If the Bayes decision boundary in this problem is highly nonlinear, then would we expect the best value for K to be large or small? Why?


2.4 Exercises 65
Applied
8. This exercise relates to the College data set, which can be found in the file College.csv on the book website. It contains a number of variables for 777 different universities and colleges in the US. The variables are
• Private : Public/private indicator
• Apps : Number of applications received
• Accept : Number of applicants accepted
• Enroll : Number of new students enrolled
• Top10perc : New students from top 10 % of high school class
• Top25perc : New students from top 25 % of high school class
• F.Undergrad : Number of full-time undergraduates
• P.Undergrad : Number of part-time undergraduates
• Outstate : Out-of-state tuition
• Room.Board : Room and board costs
• Books : Estimated book costs
• Personal : Estimated personal spending
• PhD : Percent of faculty with Ph.D.s
• Terminal : Percent of faculty with terminal degree
• S.F.Ratio : Student/faculty ratio
• perc.alumni : Percent of alumni who donate
• Expend : Instructional expenditure per student
• Grad.Rate : Graduation rate
Before reading the data into Python, it can be viewed in Excel or a text editor.
(a) Use the pd.read_csv() function to read the data into Python. Call the loaded data college. Make sure that you have the directory set to the correct location for the data.
(b) Look at the data used in the notebook by creating and running a new cell with just the code college in it. You should notice that the first column is just the name of each university in a column named something like Unnamed: 0. We don’t really want pandas to treat this as data. However, it may be handy to have these names for later. Try the following commands and similarly look at the resulting data frames:
college2 = pd.read_csv('College.csv', index_col=0) college3 = college.rename({'Unnamed: 0': 'College'}, axis=1) college3 = college3.set_index('College')


66 2. Statistical Learning
This has used the first column in the file as an index for the data frame. This means that pandas has given each row a name corresponding to the appropriate university. Now you should see that the first data column is Private. Note that the names of the colleges appear on the left of the table. We also introduced a new python object above: a dictionary, which is specified by dictionary
(key, value) pairs. Keep your modified version of the data with the following:
college = college3
(c) Use the describe() method of to produce a numerical summary of the variables in the data set.
(d) Use the pd.plotting.scatter_matrix() function to produce a scatterplot matrix of the first columns [Top10perc, Apps, Enroll]. Recall that you can reference a list C of columns of a data frame A using A[C].
(e) Use the boxplot() method of college to produce side-by-side boxplots of Outstate versus Private.
(f) Create a new qualitative variable, called Elite, by binning the Top10perc variable into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%.
college['Elite'] = pd.cut(college['Top10perc'], [0,0.5,1], labels=['No', 'Yes'])
Use the value_counts() method of college['Elite'] to see how many elite universities there are. Finally, use the boxplot() method again to produce side-by-side boxplots of Outstate versus Elite.
(g) Use the plot.hist() method of college to produce some histograms with differing numbers of bins for a few of the quantitative variables. The command plt.subplots(2, 2) may be useful: it will divide the plot window into four regions so that four plots can be made simultaneously. By changing the arguments you can divide the screen up in other combinations.
(h) Continue exploring the data, and provide a brief summary of what you discover.
9. This exercise involves the Auto data set studied in the lab. Make sure that the missing values have been removed from the data.
(a) Which of the predictors are quantitative, and which are qualitative?
(b) What is the range of each quantitative predictor? You can answer this using the min() and max() methods in numpy. .min()
.max()
(c) What is the mean and standard deviation of each quantitative predictor?


2.4 Exercises 67
(d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains?
(e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings.
(f) Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer.
10. This exercise involves the Boston housing data set.
(a) To begin, load in the Boston data set, which is part of the ISLP library.
(b) How many rows are in this data set? How many columns? What do the rows and columns represent?
(c) Make some pairwise scatterplots of the predictors (columns) in this data set. Describe your findings.
(d) Are any of the predictors associated with per capita crime rate? If so, explain the relationship.
(e) Do any of the suburbs of Boston appear to have particularly high crime rates? Tax rates? Pupil-teacher ratios? Comment on the range of each predictor.
(f) How many of the suburbs in this data set bound the Charles river?
(g) What is the median pupil-teacher ratio among the towns in this data set?
(h) Which suburb of Boston has lowest median value of owneroccupied homes? What are the values of the other predictors for that suburb, and how do those values compare to the overall ranges for those predictors? Comment on your findings.
(i) In this data set, how many of the suburbs average more than seven rooms per dwelling? More than eight rooms per dwelling? Comment on the suburbs that average more than eight rooms per dwelling.


3
Linear Regression
This chapter is about linear regression, a very simple approach for supervised learning. In particular, linear regression is a useful tool for predicting a quantitative response. It has been around for a long time and is the topic of innumerable textbooks. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters of this book, linear regression is still a useful and widely used statistical learning method. Moreover, it serves as a good jumping-off point for newer approaches: as we will see in later chapters, many fancy statistical learning approaches can be seen as generalizations or extensions of linear regression. Consequently, the importance of having a good understanding of linear regression before studying more complex learning methods cannot be overstated. In this chapter, we review some of the key ideas underlying the linear regression model, as well as the least squares approach that is most commonly used to fit this model. Recall the Advertising data from Chapter 2. Figure 2.1 displays sales (in thousands of units) for a particular product as a function of advertising budgets (in thousands of dollars) for TV, radio, and newspaper media. Suppose that in our role as statistical consultants we are asked to suggest, on the basis of this data, a marketing plan for next year that will result in high product sales. What information would be useful in order to provide such a recommendation? Here are a few important questions that we might seek to address:
1. Is there a relationship between advertising budget and sales?
Our first goal should be to determine whether the data provide evidence of an association between advertising expenditure and sales. If the evidence is weak, then one might argue that no money should be spent on advertising!
© Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_3
69


70 3. Linear Regression
2. How strong is the relationship between advertising budget and sales? Assuming that there is a relationship between advertising and sales, we would like to know the strength of this relationship. Does knowledge of the advertising budget provide a lot of information about product sales?
3. Which media are associated with sales?
Are all three media—TV, radio, and newspaper—associated with sales, or are just one or two of the media associated? To answer this question, we must find a way to separate out the individual contribution of each medium to sales when we have spent money on all three media.
4. How large is the association between each medium and sales?
For every dollar spent on advertising in a particular medium, by what amount will sales increase? How accurately can we predict this amount of increase?
5. How accurately can we predict future sales?
For any given level of television, radio, or newspaper advertising, what is our prediction for sales, and what is the accuracy of this prediction?
6. Is the relationship linear?
If there is approximately a straight-line relationship between advertising expenditure in the various media and sales, then linear regression is an appropriate tool. If not, then it may still be possible to transform the predictor or the response so that linear regression can be used.
7. Is there synergy among the advertising media?
Perhaps spending $50,000 on television advertising and $50,000 on radio advertising is associated with higher sales than allocating $100,000 to either television or radio individually. In marketing, this is known as a synergy effect, while in statistics it is called an interaction effect. synergy
interaction
It turns out that linear regression can be used to answer each of these questions. We will first discuss all of these questions in a general context, and then return to them in this specific context in Section 3.4.
3.1 Simple Linear Regression
Simple linear regression lives up to its name: it is a very straightforward simple linear
regression
approach for predicting a quantitative response Y on the basis of a single predictor variable X. It assumes that there is approximately a linear relationship between X and Y . Mathematically, we can write this linear relationship as
Y ≈ β0 + β1X. (3.1)
You might read “≈” as “is approximately modeled as”. We will sometimes describe (3.1) by saying that we are regressing Y on X (or Y onto X).


3.1 Simple Linear Regression 71
For example, X may represent TV advertising and Y may represent sales. Then we can regress sales onto TV by fitting the model
sales ≈ β0 + β1 × TV.
In Equation 3.1, β0 and β1 are two unknown constants that represent the intercept and slope terms in the linear model. Together, β0 and β1 are intercept
slope
known as the model coefficients or parameters. Once we have used our
coefficient parameter
training data to produce estimates βˆ0 and βˆ1 for the model coefficients, we can predict future sales on the basis of a particular value of TV advertising by computing
yˆ = βˆ0 + βˆ1x, (3.2)
where yˆ indicates a prediction of Y on the basis of X = x. Here we use a hat symbol, ˆ , to denote the estimated value for an unknown parameter or coefficient, or to denote the predicted value of the response.
3.1.1 Estimating the Coefficients
In practice, β0 and β1 are unknown. So before we can use (3.1) to make predictions, we must use data to estimate the coefficients. Let
(x1, y1), (x2, y2), . . . , (xn, yn)
represent n observation pairs, each of which consists of a measurement of X and a measurement of Y . In the Advertising example, this data set consists of the TV advertising budget and product sales in n = 200 different markets. (Recall that the data are displayed in Figure 2.1.) Our goal is to obtain coefficient estimates βˆ0 and βˆ1 such that the linear model (3.1) fits the available data well—that is, so that yi ≈ βˆ0 + βˆ1xi for i = 1, . . . , n. In
other words, we want to find an intercept βˆ0 and a slope βˆ1 such that the resulting line is as close as possible to the n = 200 data points. There are a number of ways of measuring closeness. However, by far the most common approach involves minimizing the least squares criterion, and we take least squares
that approach in this chapter. Alternative approaches will be considered in Chapter 6. Let yˆi = βˆ0 + βˆ1xi be the prediction for Y based on the ith value of X. Then ei = yi − yˆi represents the ith residual—this is the difference between residual
the ith observed response value and the ith response value that is predicted by our linear model. We define the residual sum of squares (RSS) as residual sum
of squares
RSS = e2
1 + e2
2 + · · · + e2
n,
or equivalently as
RSS = (y1 − βˆ0 − βˆ1x1)2 + (y2 − βˆ0 − βˆ1x2)2 + · · · + (yn − βˆ0 − βˆ1xn)2. (3.3)
The least squares approach chooses βˆ0 and βˆ1 to minimize the RSS. Using some calculus, one can show that the minimizers are
βˆ1 =
∑n
i=1(xi − x ̄)(yi − y ̄)
∑n
i=1(xi − x ̄)2 ,
βˆ0 = y ̄ − βˆ1x ̄,
(3.4)


72 3. Linear Regression
0 50 100 150 200 250 300
5 10 15 20 25
TV
Sales
FIGURE 3.1. For the Advertising data, the least squares fit for the regression of sales onto TV is shown. The fit is found by minimizing the residual sum of squares. Each grey line segment represents a residual. In this case a linear fit captures the essence of the relationship, although it overestimates the trend in the left of the plot.
where y ̄ ≡ 1
n
∑n
i=1 yi and x ̄ ≡ 1
n
∑n
i=1 xi are the sample means. In other
words, (3.4) defines the least squares coefficient estimates for simple linear regression. Figure 3.1 displays the simple linear regression fit to the Advertising data, where βˆ0 = 7.03 and βˆ1 = 0.0475. In other words, according to this approximation, an additional $1,000 spent on TV advertising is associated with selling approximately 47.5 additional units of the product. In Figure 3.2, we have computed RSS for a number of values of β0 and β1, using the advertising data with sales as the response and TV as the predictor. In each plot, the red dot represents the pair of least squares estimates (βˆ0, βˆ1) given by (3.4). These values clearly minimize the RSS.
3.1.2 Assessing the Accuracy of the Coefficient Estimates
Recall from (2.1) that we assume that the true relationship between X and Y takes the form Y = f (X) + ε for some unknown function f , where ε is a mean-zero random error term. If f is to be approximated by a linear function, then we can write this relationship as
Y = β0 + β1X + ε. (3.5)
Here β0 is the intercept term—that is, the expected value of Y when X = 0, and β1 is the slope—the average increase in Y associated with a one-unit increase in X. The error term is a catch-all for what we miss with this simple model: the true relationship is probably not linear, there may be other variables that cause variation in Y , and there may be measurement error. We typically assume that the error term is independent of X.


3.1 Simple Linear Regression 73
FIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using sales as the response and TV as the predictor. The red dots correspond to the least squares estimates βˆ0 and βˆ1, given by (3.4).
The model given by (3.5) defines the population regression line, which population
regression line
is the best linear approximation to the true relationship between X and Y .1 The least squares regression coefficient estimates (3.4) characterize the least squares line (3.2). The left-hand panel of Figure 3.3 displays these least squares
line
two lines in a simple simulated example. We created 100 random Xs, and generated 100 corresponding Y s from the model
Y = 2 + 3X + ε, (3.6)
where ε was generated from a normal distribution with mean zero. The red line in the left-hand panel of Figure 3.3 displays the true relationship, f (X) = 2 + 3X, while the blue line is the least squares estimate based on the observed data. The true relationship is generally not known for real data, but the least squares line can always be computed using the coefficient estimates given in (3.4). In other words, in real applications, we have access to a set of observations from which we can compute the least squares line; however, the population regression line is unobserved. In the right-hand panel of Figure 3.3 we have generated ten different data sets from the model given by (3.6) and plotted the corresponding ten least squares lines. Notice that different data sets generated from the same true model result in slightly different least squares lines, but the unobserved population regression line does not change. At first glance, the difference between the population regression line and the least squares line may seem subtle and confusing. We only have one data set, and so what does it mean that two different lines describe the relationship between the predictor and the response? Fundamentally, the concept of these two lines is a natural extension of the standard statistical approach of using information from a sample to estimate characteristics of a large population. For example, suppose that we are interested in knowing
1The assumption of linearity is often a useful working model. However, despite what many textbooks might tell us, we seldom believe that the true relationship is linear.
β0
β1
2.11
2.15
2.2
2.3 2.5
2.5
3
3
56789
0.03 0.04 0.05 0.06
RSS
β1
β0


74 3. Linear Regression
−2 −1 0 1 2
−10 −5 0 5 10
X
Y
−2 −1 0 1 2
−10 −5 0 5 10
X
Y
FIGURE 3.3. A simulated data set. Left: The red line represents the true relationship, f (X) = 2 + 3X, which is known as the population regression line. The blue line is the least squares line; it is the least squares estimate for f (X) based on the observed data, shown in black. Right: The population regression line is again shown in red, and the least squares line in dark blue. In light blue, ten least squares lines are shown, each computed on the basis of a separate random set of observations. Each least squares line is different, but on average, the least squares lines are quite close to the population regression line.
the population mean μ of some random variable Y . Unfortunately, μ is unknown, but we do have access to n observations from Y , y1, . . . , yn, which we can use to estimate μ. A reasonable estimate is μˆ = y ̄, where y ̄ = 1
n
∑n
i=1 yi is the sample mean. The sample mean and the population
mean are different, but in general the sample mean will provide a good estimate of the population mean. In the same way, the unknown coefficients β0 and β1 in linear regression define the population regression line. We seek
to estimate these unknown coefficients using βˆ0 and βˆ1 given in (3.4). These coefficient estimates define the least squares line. The analogy between linear regression and estimation of the mean of a random variable is an apt one based on the concept of bias. If we use the bias
sample mean μˆ to estimate μ, this estimate is unbiased, in the sense that unbiased
on average, we expect μˆ to equal μ. What exactly does this mean? It means that on the basis of one particular set of observations y1, . . . , yn, μˆ might overestimate μ, and on the basis of another set of observations, μˆ might underestimate μ. But if we could average a huge number of estimates of μ obtained from a huge number of sets of observations, then this average would exactly equal μ. Hence, an unbiased estimator does not systematically over- or under-estimate the true parameter. The property of unbiasedness holds for the least squares coefficient estimates given by (3.4) as well: if we estimate β0 and β1 on the basis of a particular data set, then our estimates won’t be exactly equal to β0 and β1. But if we could average the estimates obtained over a huge number of data sets, then the average of these estimates would be spot on! In fact, we can see from the righthand panel of Figure 3.3 that the average of many least squares lines, each


3.1 Simple Linear Regression 75
estimated from a separate data set, is pretty close to the true population regression line. We continue the analogy with the estimation of the population mean μ of a random variable Y . A natural question is as follows: how accurate is the sample mean μˆ as an estimate of μ? We have established that the average of μˆ’s over many data sets will be very close to μ, but that a single estimate μˆ may be a substantial underestimate or overestimate of μ. How far off will that single estimate of μˆ be? In general, we answer this question by computing the standard error of μˆ, written as SE(μˆ). We have standard
error
the well-known formula
Var(μˆ) = SE(μˆ)2 = σ2
n , (3.7)
where σ is the standard deviation of each of the realizations yi of Y .2 Roughly speaking, the standard error tells us the average amount that this estimate μˆ differs from the actual value of μ. Equation 3.7 also tells us how this deviation shrinks with n—the more observations we have, the smaller the standard error of μˆ. In a similar vein, we can wonder how close βˆ0
and βˆ1 are to the true values β0 and β1. To compute the standard errors
associated with βˆ0 and βˆ1, we use the following formulas:
SE(βˆ0)2 = σ2
[1
n + x ̄2
∑n
i=1(xi − x ̄)2
]
, SE(βˆ1)2 = σ2
∑n
i=1(xi − x ̄)2 , (3.8)
where σ2 = Var(ε). For these formulas to be strictly valid, we need to assume that the errors εi for each observation have common variance σ2 and are uncorrelated. This is clearly not true in Figure 3.1, but the formula still turns out to be a good approximation. Notice in the formula that SE(βˆ1) is smaller when the xi are more spread out; intuitively we have more leverage
to estimate a slope when this is the case. We also see that SE(βˆ0) would be the same as SE(μˆ) if x ̄ were zero (in which case βˆ0 would be equal to y ̄). In general, σ2 is not known, but can be estimated from the data. This estimate of σ is known as the residual standard error, and is given by the formula residual
standard error
RSE = √RSS/(n − 2). Strictly speaking, when σ2 is estimated from the
data we should write ̂SE(βˆ1) to indicate that an estimate has been made, but for simplicity of notation we will drop this extra “hat”. Standard errors can be used to compute confidence intervals. A 95 % confidence
interval
confidence interval is defined as a range of values such that with 95 % probability, the range will contain the true unknown value of the parameter. The range is defined in terms of lower and upper limits computed from the sample of data. A 95% confidence interval has the following property: if we take repeated samples and construct the confidence interval for each sample, 95% of the intervals will contain the true unknown value of the parameter. For linear regression, the 95 % confidence interval for β1 approximately takes the form
βˆ1 ± 2 · SE(βˆ1). (3.9)
2This formula holds provided that the n observations are uncorrelated.


76 3. Linear Regression
That is, there is approximately a 95 % chance that the interval
[βˆ1 − 2 · SE(βˆ1), βˆ1 + 2 · SE(βˆ1)
]
(3.10)
will contain the true value of β1.3 Similarly, a confidence interval for β0 approximately takes the form
βˆ0 ± 2 · SE(βˆ0). (3.11)
In the case of the advertising data, the 95 % confidence interval for β0 is [6.130, 7.935] and the 95 % confidence interval for β1 is [0.042, 0.053]. Therefore, we can conclude that in the absence of any advertising, sales will, on average, fall somewhere between 6,130 and 7,935 units. Furthermore, for each $1,000 increase in television advertising, there will be an average increase in sales of between 42 and 53 units. Standard errors can also be used to perform hypothesis tests on the hypothesis
test
coefficients. The most common hypothesis test involves testing the null
hypothesis of null
hypothesis
H0 : There is no relationship between X and Y (3.12)
versus the alternative hypothesis alternative
hypothesis
Ha : There is some relationship between X and Y . (3.13)
Mathematically, this corresponds to testing
H0 : β1 = 0
versus
Ha : β1 ̸= 0,
since if β1 = 0 then the model (3.5) reduces to Y = β0 + ε, and X is not associated with Y . To test the null hypothesis, we need to determine whether βˆ1, our estimate for β1, is sufficiently far from zero that we can be confident that β1 is non-zero. How far is far enough? This of course
depends on the accuracy of βˆ1—that is, it depends on SE(βˆ1). If SE(βˆ1) is small, then even relatively small values of βˆ1 may provide strong evidence that β1 ̸= 0, and hence that there is a relationship between X and Y . In
contrast, if SE(βˆ1) is large, then βˆ1 must be large in absolute value in order for us to reject the null hypothesis. In practice, we compute a t-statistic, t-statistic
given by
t=
βˆ1 − 0
SE(βˆ1) , (3.14)
3Approximately for several reasons. Equation 3.10 relies on the assumption that the errors are Gaussian. Also, the factor of 2 in front of the SE(βˆ1) term will vary slightly depending on the number of observations n in the linear regression. To be precise, rather than the number 2, (3.10) should contain the 97.5 % quantile of a t-distribution with n−2 degrees of freedom. Details of how to compute the 95 % confidence interval precisely in R will be provided later in this chapter.


3.1 Simple Linear Regression 77
Coefficient Std. error t-statistic p-value Intercept 7.0325 0.4578 15.36 < 0.0001 TV 0.0475 0.0027 17.67 < 0.0001
TABLE 3.1. For the Advertising data, coefficients of the least squares model for the regression of number of units sold on TV advertising budget. An increase of $1,000 in the TV advertising budget is associated with an increase in sales by around 50 units. (Recall that the sales variable is in thousands of units, and the TV variable is in thousands of dollars.)
which measures the number of standard deviations that βˆ1 is away from 0. If there really is no relationship between X and Y , then we expect that (3.14) will have a t-distribution with n − 2 degrees of freedom. The t-distribution has a bell shape and for values of n greater than approximately 30 it is quite similar to the standard normal distribution. Consequently, it is a simple matter to compute the probability of observing any number equal to |t| or larger in absolute value, assuming β1 = 0. We call this probability the p-value. Roughly speaking, we interpret the p-value as follows: a small p-value
p-value indicates that it is unlikely to observe such a substantial association between the predictor and the response due to chance, in the absence of any real association between the predictor and the response. Hence, if we see a small p-value, then we can infer that there is an association between the predictor and the response. We reject the null hypothesis—that is, we declare a relationship to exist between X and Y —if the p-value is small enough. Typical p-value cutoffs for rejecting the null hypothesis are 5% or 1%, although this topic will be explored in much greater detail in Chapter 13. When n = 30, these correspond to t-statistics (3.14) of around 2 and 2.75, respectively. Table 3.1 provides details of the least squares model for the regression of number of units sold on TV advertising budget for the Advertising data. Notice that the coefficients for βˆ0 and βˆ1 are very large relative to their standard errors, so the t-statistics are also large; the probabilities of seeing such values if H0 is true are virtually zero. Hence we can conclude that
β0 ̸= 0 and β1 ̸= 0.4
3.1.3 Assessing the Accuracy of the Model
Once we have rejected the null hypothesis (3.12) in favor of the alternative hypothesis (3.13), it is natural to want to quantify the extent to which the model fits the data. The quality of a linear regression fit is typically assessed
using two related quantities: the residual standard error (RSE) and the R2
R2
statistic.
4In Table 3.1, a small p-value for the intercept indicates that we can reject the null hypothesis that β0 = 0, and a small p-value for TV indicates that we can reject the null hypothesis that β1 = 0. Rejecting the latter null hypothesis allows us to conclude that there is a relationship between TV and sales. Rejecting the former allows us to conclude that in the absence of TV expenditure, sales are non-zero.


78 3. Linear Regression
Quantity Value Residual standard error 3.26 R2 0.612 F -statistic 312.1
TABLE 3.2. For the Advertising data, more information about the least squares model for the regression of number of units sold on TV advertising budget.
Table 3.2 displays the RSE, the R2 statistic, and the F -statistic (to be described in Section 3.2.2) for the linear regression of number of units sold on TV advertising budget.
Residual Standard Error
Recall from the model (3.5) that associated with each observation is an error term ε. Due to the presence of these error terms, even if we knew the true regression line (i.e. even if β0 and β1 were known), we would not be able to perfectly predict Y from X. The RSE is an estimate of the standard deviation of ε. Roughly speaking, it is the average amount that the response will deviate from the true regression line. It is computed using the formula
RSE =
√1
n − 2 RSS =
√ √ √ √ 1
n−2
∑n
i=1
(yi − yˆi)2. (3.15)
Note that RSS was defined in Section 3.1.1, and is given by the formula
RSS =
∑n
i=1
(yi − yˆi)2. (3.16)
In the case of the advertising data, we see from the linear regression output in Table 3.2 that the RSE is 3.26. In other words, actual sales in each market deviate from the true regression line by approximately 3,260 units, on average. Another way to think about this is that even if the model were correct and the true values of the unknown coefficients β0 and β1 were known exactly, any prediction of sales on the basis of TV advertising would still be off by about 3,260 units on average. Of course, whether or not 3,260 units is an acceptable prediction error depends on the problem context. In the advertising data set, the mean value of sales over all markets is approximately 14,000 units, and so the percentage error is 3,260/14,000 = 23 %.
The RSE is considered a measure of the lack of fit of the model (3.5) to the data. If the predictions obtained using the model are very close to the true outcome values—that is, if yˆi ≈ yi for i = 1, . . . , n—then (3.15) will be small, and we can conclude that the model fits the data very well. On the other hand, if yˆi is very far from yi for one or more observations, then the RSE may be quite large, indicating that the model doesn’t fit the data well.
R2 Statistic
The RSE provides an absolute measure of lack of fit of the model (3.5) to the data. But since it is measured in the units of Y , it is not always


3.1 Simple Linear Regression 79
clear what constitutes a good RSE. The R2 statistic provides an alternative measure of fit. It takes the form of a proportion—the proportion of variance explained—and so it always takes on a value between 0 and 1, and is independent of the scale of Y . To calculate R2, we use the formula
R2 = TSS − RSS
TSS = 1 − RSS
TSS (3.17)
where TSS = ∑(yi − y ̄)2 is the total sum of squares, and RSS is defined total sum of
squares
in (3.16). TSS measures the total variance in the response Y , and can be thought of as the amount of variability inherent in the response before the regression is performed. In contrast, RSS measures the amount of variability that is left unexplained after performing the regression. Hence, TSS − RSS measures the amount of variability in the response that is explained (or removed) by performing the regression, and R2 measures the proportion of variability in Y that can be explained using X. An R2 statistic that is close to 1 indicates that a large proportion of the variability in the response is explained by the regression. A number near 0 indicates that the regression does not explain much of the variability in the response; this might occur because the linear model is wrong, or the error variance σ2 is high, or both. In Table 3.2, the R2 was 0.61, and so just under two-thirds of the variability in sales is explained by a linear regression on TV. The R2 statistic (3.17) has an interpretational advantage over the RSE (3.15), since unlike the RSE, it always lies between 0 and 1. However, it can still be challenging to determine what is a good R2 value, and in general, this will depend on the application. For instance, in certain problems in physics, we may know that the data truly comes from a linear model with a small residual error. In this case, we would expect to see an R2 value that is extremely close to 1, and a substantially smaller R2 value might indicate a serious problem with the experiment in which the data were generated. On the other hand, in typical applications in biology, psychology, marketing, and other domains, the linear model (3.5) is at best an extremely rough approximation to the data, and residual errors due to other unmeasured factors are often very large. In this setting, we would expect only a very small proportion of the variance in the response to be explained by the predictor, and an R2 value well below 0.1 might be more realistic! The R2 statistic is a measure of the linear relationship between X and Y . Recall that correlation, defined as correlation
Cor(X, Y ) =
∑n
i=1(xi − x)(yi − y)
√∑n
i=1(xi − x)2√∑n
i=1(yi − y)2 , (3.18)
is also a measure of the linear relationship between X and Y .5 This suggests that we might be able to use r = Cor(X, Y ) instead of R2 in order to assess the fit of the linear model. In fact, it can be shown that in the simple
5We note that in fact, the right-hand side of (3.18) is the sample correlation; thus, it would be more correct to write Côr(X, Y ); however, we omit the “hat” for ease of notation.


80 3. Linear Regression
Simple regression of sales on radio Coefficient Std. error t-statistic p-value
Intercept 9.312 0.563 16.54 < 0.0001 radio 0.203 0.020 9.92 < 0.0001
Simple regression of sales on newspaper
Coefficient Std. error t-statistic p-value
Intercept 12.351 0.621 19.88 < 0.0001 newspaper 0.055 0.017 3.30 0.00115
TABLE 3.3. More simple linear regression models for the Advertising data. Coefficients of the simple linear regression model for number of units sold on Top: radio advertising budget and Bottom: newspaper advertising budget. A $1,000 increase in spending on radio advertising is associated with an average increase in sales by around 203 units, while the same increase in spending on newspaper advertising is associated with an average increase in sales by around 55 units. (Note that the sales variable is in thousands of units, and the radio and newspaper variables are in thousands of dollars.)
linear regression setting, R2 = r2. In other words, the squared correlation and the R2 statistic are identical. However, in the next section we will discuss the multiple linear regression problem, in which we use several predictors simultaneously to predict the response. The concept of correlation between the predictors and the response does not extend automatically to this setting, since correlation quantifies the association between a single pair of variables rather than between a larger number of variables. We will see that R2 fills this role.
3.2 Multiple Linear Regression
Simple linear regression is a useful approach for predicting a response on the basis of a single predictor variable. However, in practice we often have more than one predictor. For example, in the Advertising data, we have examined the relationship between sales and TV advertising. We also have data for the amount of money spent advertising on the radio and in newspapers, and we may want to know whether either of these two media is associated with sales. How can we extend our analysis of the advertising data in order to accommodate these two additional predictors? One option is to run three separate simple linear regressions, each of which uses a different advertising medium as a predictor. For instance, we can fit a simple linear regression to predict sales on the basis of the amount spent on radio advertisements. Results are shown in Table 3.3 (top table). We find that a $1,000 increase in spending on radio advertising is associated with an increase in sales of around 203 units. Table 3.3 (bottom table) contains the least squares coefficients for a simple linear regression of sales onto newspaper advertising budget. A $1,000 increase in newspaper advertising budget is associated with an increase in sales of approximately 55 units.


3.2 Multiple Linear Regression 81
However, the approach of fitting a separate simple linear regression model for each predictor is not entirely satisfactory. First of all, it is unclear how to make a single prediction of sales given the three advertising media budgets, since each of the budgets is associated with a separate regression equation. Second, each of the three regression equations ignores the other two media in forming estimates for the regression coefficients. We will see shortly that if the media budgets are correlated with each other in the 200 markets in our data set, then this can lead to very misleading estimates of the association between each media budget and sales. Instead of fitting a separate simple linear regression model for each predictor, a better approach is to extend the simple linear regression model (3.5) so that it can directly accommodate multiple predictors. We can do this by giving each predictor a separate slope coefficient in a single model. In general, suppose that we have p distinct predictors. Then the multiple linear regression model takes the form
Y = β0 + β1X1 + β2X2 + · · · + βpXp + ε, (3.19)
where Xj represents the jth predictor and βj quantifies the association between that variable and the response. We interpret βj as the average effect on Y of a one unit increase in Xj, holding all other predictors fixed. In the advertising example, (3.19) becomes
sales = β0 + β1 × TV + β2 × radio + β3 × newspaper + ε. (3.20)
3.2.1 Estimating the Regression Coefficients
As was the case in the simple linear regression setting, the regression coefficients β0, β1, . . . , βp in (3.19) are unknown, and must be estimated. Given estimates βˆ0, βˆ1, . . . , βˆp, we can make predictions using the formula
yˆ = βˆ0 + βˆ1x1 + βˆ2x2 + · · · + βˆpxp. (3.21)
The parameters are estimated using the same least squares approach that we saw in the context of simple linear regression. We choose β0, β1, . . . , βp to minimize the sum of squared residuals
RSS =
∑n
i=1
(yi − yˆi)2
=
∑n
i=1
(yi − βˆ0 − βˆ1xi1 − βˆ2xi2 − · · · − βˆpxip)2. (3.22)
The values βˆ0, βˆ1, . . . , βˆp that minimize (3.22) are the multiple least squares regression coefficient estimates. Unlike the simple linear regression estimates given in (3.4), the multiple regression coefficient estimates have somewhat complicated forms that are most easily represented using matrix algebra. For this reason, we do not provide them here. Any statistical software package can be used to compute these coefficient estimates, and later in this chapter we will show how this can be done in R. Figure 3.4


82 3. Linear Regression
X1
X2
Y
FIGURE 3.4. In a three-dimensional setting, with two predictors and one response, the least squares regression line becomes a plane. The plane is chosen to minimize the sum of the squared vertical distances between each observation (shown in red) and the plane.
illustrates an example of the least squares fit to a toy data set with p = 2 predictors. Table 3.4 displays the multiple regression coefficient estimates when TV, radio, and newspaper advertising budgets are used to predict product sales using the Advertising data. We interpret these results as follows: for a given amount of TV and newspaper advertising, spending an additional $1,000 on radio advertising is associated with approximately 189 units of additional sales. Comparing these coefficient estimates to those displayed in Tables 3.1 and 3.3, we notice that the multiple regression coefficient estimates for TV and radio are pretty similar to the simple linear regression coefficient estimates. However, while the newspaper regression coefficient estimate in Table 3.3 was significantly non-zero, the coefficient estimate for newspaper in the multiple regression model is close to zero, and the corresponding pvalue is no longer significant, with a value around 0.86. This illustrates that the simple and multiple regression coefficients can be quite different. This difference stems from the fact that in the simple regression case, the slope term represents the average increase in product sales associated with a $1,000 increase in newspaper advertising, ignoring other predictors such as TV and radio. By contrast, in the multiple regression setting, the coefficient for newspaper represents the average increase in product sales associated with increasing newspaper spending by $1,000 while holding TV and radio fixed. Does it make sense for the multiple regression to suggest no relationship between sales and newspaper while the simple linear regression implies the


3.2 Multiple Linear Regression 83
Coefficient Std. error t-statistic p-value Intercept 2.939 0.3119 9.42 < 0.0001 TV 0.046 0.0014 32.81 < 0.0001 radio 0.189 0.0086 21.89 < 0.0001 newspaper −0.001 0.0059 −0.18 0.8599
TABLE 3.4. For the Advertising data, least squares coefficient estimates of the multiple linear regression of number of units sold on TV, radio, and newspaper advertising budgets.
TV radio newspaper sales TV 1.0000 0.0548 0.0567 0.7822 radio 1.0000 0.3541 0.5762 newspaper 1.0000 0.2283 sales 1.0000
TABLE 3.5. Correlation matrix for TV, radio, newspaper, and sales for the Advertising data.
opposite? In fact it does. Consider the correlation matrix for the three predictor variables and response variable, displayed in Table 3.5. Notice that the correlation between radio and newspaper is 0.35. This indicates that markets with high newspaper advertising tend to also have high radio advertising. Now suppose that the multiple regression is correct and newspaper advertising is not associated with sales, but radio advertising is associated with sales. Then in markets where we spend more on radio our sales will tend to be higher, and as our correlation matrix shows, we also tend to spend more on newspaper advertising in those same markets. Hence, in a simple linear regression which only examines sales versus newspaper, we will observe that higher values of newspaper tend to be associated with higher values of sales, even though newspaper advertising is not directly associated with sales. So newspaper advertising is a surrogate for radio advertising; newspaper gets “credit” for the association between radio on sales.
This slightly counterintuitive result is very common in many real life situations. Consider an absurd example to illustrate the point. Running a regression of shark attacks versus ice cream sales for data collected at a given beach community over a period of time would show a positive relationship, similar to that seen between sales and newspaper. Of course no one has (yet) suggested that ice creams should be banned at beaches to reduce shark attacks. In reality, higher temperatures cause more people to visit the beach, which in turn results in more ice cream sales and more shark attacks. A multiple regression of shark attacks onto ice cream sales and temperature reveals that, as intuition implies, ice cream sales is no longer a significant predictor after adjusting for temperature.
3.2.2 Some Important Questions
When we perform multiple linear regression, we usually are interested in answering a few important questions.


84 3. Linear Regression
1. Is at least one of the predictors X1, X2, . . . , Xp useful in predicting the response?
2. Do all the predictors help to explain Y , or is only a subset of the predictors useful?
3. How well does the model fit the data?
4. Given a set of predictor values, what response value should we predict, and how accurate is our prediction?
We now address each of these questions in turn.
One: Is There a Relationship Between the Response and Predictors?
Recall that in the simple linear regression setting, in order to determine whether there is a relationship between the response and the predictor we can simply check whether β1 = 0. In the multiple regression setting with p predictors, we need to ask whether all of the regression coefficients are zero, i.e. whether β1 = β2 = · · · = βp = 0. As in the simple linear regression setting, we use a hypothesis test to answer this question. We test the null hypothesis,
H0 : β1 = β2 = · · · = βp = 0
versus the alternative
Ha : at least one βj is non-zero.
This hypothesis test is performed by computing the F -statistic, F -statistic
F = (TSS − RSS)/p
RSS/(n − p − 1) , (3.23)
where, as with simple linear regression, TSS = ∑(yi − y ̄)2 and RSS =
∑(yi − yˆi)2. If the linear model assumptions are correct, one can show that
E{RSS/(n − p − 1)} = σ2
and that, provided H0 is true,
E{(TSS − RSS)/p} = σ2.
Hence, when there is no relationship between the response and predictors, one would expect the F -statistic to take on a value close to 1. On the other hand, if Ha is true, then E{(TSS − RSS)/p} > σ2, so we expect F to be greater than 1. The F -statistic for the multiple linear regression model obtained by regressing sales onto radio, TV, and newspaper is shown in Table 3.6. In this example the F -statistic is 570. Since this is far larger than 1, it provides compelling evidence against the null hypothesis H0. In other words, the large F -statistic suggests that at least one of the advertising media must be related to sales. However, what if the F -statistic had been closer to 1? How large does the F -statistic need to be before we can reject H0 and


3.2 Multiple Linear Regression 85
Quantity Value Residual standard error 1.69 R2 0.897 F -statistic 570
TABLE 3.6. More information about the least squares model for the regression of number of units sold on TV, newspaper, and radio advertising budgets in the Advertising data. Other information about this model was displayed in Table 3.4.
conclude that there is a relationship? It turns out that the answer depends on the values of n and p. When n is large, an F -statistic that is just a little larger than 1 might still provide evidence against H0. In contrast, a larger F -statistic is needed to reject H0 if n is small. When H0 is true and the errors εi have a normal distribution, the F -statistic follows an
F -distribution.6 For any given value of n and p, any statistical software package can be used to compute the p-value associated with the F -statistic using this distribution. Based on this p-value, we can determine whether or not to reject H0. For the advertising data, the p-value associated with the F -statistic in Table 3.6 is essentially zero, so we have extremely strong evidence that at least one of the media is associated with increased sales. In (3.23) we are testing H0 that all the coefficients are zero. Sometimes we want to test that a particular subset of q of the coefficients are zero. This corresponds to a null hypothesis
H0 : βp−q+1 = βp−q+2 = · · · = βp = 0,
where for convenience we have put the variables chosen for omission at the end of the list. In this case we fit a second model that uses all the variables except those last q. Suppose that the residual sum of squares for that model is RSS0. Then the appropriate F -statistic is
F = (RSS0 − RSS)/q
RSS/(n − p − 1) . (3.24)
Notice that in Table 3.4, for each individual predictor a t-statistic and a p-value were reported. These provide information about whether each individual predictor is related to the response, after adjusting for the other predictors. It turns out that each of these is exactly equivalent7 to the F test that omits that single variable from the model, leaving all the others in—i.e. q=1 in (3.24). So it reports the partial effect of adding that variable to the model. For instance, as we discussed earlier, these p-values indicate that TV and radio are related to sales, but that there is no evidence that newspaper is associated with sales, when TV and radio are held fixed. Given these individual p-values for each variable, why do we need to look at the overall F -statistic? After all, it seems likely that if any one of the p-values for the individual variables is very small, then at least one of the predictors is related to the response. However, this logic is flawed, especially when the number of predictors p is large.
6Even if the errors are not normally-distributed, the F -statistic approximately follows an F -distribution provided that the sample size n is large. 7The square of each t-statistic is the corresponding F -statistic.


86 3. Linear Regression
For instance, consider an example in which p = 100 and H0 : β1 = β2 = · · · = βp = 0 is true, so no variable is truly associated with the response. In this situation, about 5 % of the p-values associated with each variable (of the type shown in Table 3.4) will be below 0.05 by chance. In other words, we expect to see approximately five small p-values even in the absence of any true association between the predictors and the response.8 In fact, it is likely that we will observe at least one p-value below 0.05 by chance! Hence, if we use the individual t-statistics and associated p-values in order to decide whether or not there is any association between the variables and the response, there is a very high chance that we will incorrectly conclude that there is a relationship. However, the F -statistic does not suffer from this problem because it adjusts for the number of predictors. Hence, if H0 is true, there is only a 5 % chance that the F -statistic will result in a pvalue below 0.05, regardless of the number of predictors or the number of observations. The approach of using an F -statistic to test for any association between the predictors and the response works when p is relatively small, and certainly small compared to n. However, sometimes we have a very large number of variables. If p > n then there are more coefficients βj to estimate than observations from which to estimate them. In this case we cannot even fit the multiple linear regression model using least squares, so the F statistic cannot be used, and neither can most of the other concepts that we have seen so far in this chapter. When p is large, some of the approaches discussed in the next section, such as forward selection, can be used. This high-dimensional setting is discussed in greater detail in Chapter 6. high
dimensional
Two: Deciding on Important Variables
As discussed in the previous section, the first step in a multiple regression analysis is to compute the F -statistic and to examine the associated pvalue. If we conclude on the basis of that p-value that at least one of the predictors is related to the response, then it is natural to wonder which are the guilty ones! We could look at the individual p-values as in Table 3.4, but as discussed (and as further explored in Chapter 13), if p is large we are likely to make some false discoveries. It is possible that all of the predictors are associated with the response, but it is more often the case that the response is only associated with a subset of the predictors. The task of determining which predictors are associated with the response, in order to fit a single model involving only those predictors, is referred to as variable selection. The variable selection variable
selection
problem is studied extensively in Chapter 6, and so here we will provide only a brief outline of some classical approaches. Ideally, we would like to perform variable selection by trying out a lot of different models, each containing a different subset of the predictors. For instance, if p = 2, then we can consider four models: (1) a model containing no variables, (2) a model containing X1 only, (3) a model containing
8This is related to the important concept of multiple testing, which is the focus of Chapter 13.


3.2 Multiple Linear Regression 87
X2 only, and (4) a model containing both X1 and X2. We can then select the best model out of all of the models that we have considered. How do we determine which model is best? Various statistics can be used to judge the quality of a model. These include Mallow’s Cp, Akaike informa- Mallow’s Cp
tion criterion (AIC), Bayesian information criterion (BIC), and adjusted Akaike
information criterion Bayesian information criterion
R2. These are discussed in more detail in Chapter 6. We can also deter
adjusted R2
mine which model is best by plotting various model outputs, such as the residuals, in order to search for patterns. Unfortunately, there are a total of 2p models that contain subsets of p variables. This means that even for moderate p, trying out every possible subset of the predictors is infeasible. For instance, we saw that if p = 2, then there are 22 = 4 models to consider. But if p = 30, then we must consider 230 = 1,073,741,824 models! This is not practical. Therefore, unless p is very small, we cannot consider all 2p models, and instead we need an automated and efficient approach to choose a smaller set of models to consider. There are three classical approaches for this task:
• Forward selection. We begin with the null model—a model that con- forward
selection null model
tains an intercept but no predictors. We then fit p simple linear regressions and add to the null model the variable that results in the lowest RSS. We then add to that model the variable that results in the lowest RSS for the new two-variable model. This approach is continued until some stopping rule is satisfied.
• Backward selection. We start with all variables in the model, and backward
selection
remove the variable with the largest p-value—that is, the variable that is the least statistically significant. The new (p − 1)-variable model is fit, and the variable with the largest p-value is removed. This procedure continues until a stopping rule is reached. For instance, we may stop when all remaining variables have a p-value below some threshold.
• Mixed selection. This is a combination of forward and backward se- mixed
selection
lection. We start with no variables in the model, and as with forward selection, we add the variable that provides the best fit. We continue to add variables one-by-one. Of course, as we noted with the Advertising example, the p-values for variables can become larger as new predictors are added to the model. Hence, if at any point the p-value for one of the variables in the model rises above a certain threshold, then we remove that variable from the model. We continue to perform these forward and backward steps until all variables in the model have a sufficiently low p-value, and all variables outside the model would have a large p-value if added to the model.
Backward selection cannot be used if p > n, while forward selection can always be used. Forward selection is a greedy approach, and might include variables early that later become redundant. Mixed selection can remedy this.