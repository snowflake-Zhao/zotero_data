信息 科 学 与技术丛书
VTK 图形图像开发进阶
张晓东 罗火灵编著
@
机械 工 业出版社


本书系统地介绍了 VTK 基础知识与开发技术,帮助 VTK 用 户从入门到
进阶,快速进入项目实战。本 书第 1 章是 VTK 概览,介绍 VTK 的 发展和编
译安装 : 第 2 章 以实例开题,分析 VTK 渲染引擎和 可视化管线 ; 第 3 章介
绍 VTK 的 基本数据结构,并在第 4 章 中以实例分析 VTK 中数据读写 功能:
第 5 ~6 章通过实例阐述 VTK 在图像和图形处理 中的应用 : 第 7 章分析 VTK
的体绘制技术:第 8 章讲述 VTK 交互技术 :第 9 章内容为 VTK 在 Qt 、 MFC
等环境下的开发技术 ; 第 10 章分析了 VTK 的基础架构和管线机制,并通过
实例讲解自定义 Filter 类;附录中列举了 VTK5 与 VTK6 的 区别 , 并给出了
VTK 中文的实现。
图书在版编目 (CIP ) 数据
VTK 图 形图像开发进阶/张晓东,罗火灵编著.一北京 :机 械工业出版
社, 2015.4 (信息科学与技术丛书)
ISBN 978-7-1 I1-49628- 1
I. (D Y ... II. @张 ... @罗 ... III. @图形处理-软件开发@图像
处理-软件开发 IV . (DTP39l.41
中国版本图书馆 CIP 数据核字 (20 1 S ) 第 049160 号
机械 工业出版社(北 京市百万庄大街 22 号 邮政编码 100037) 责任编辑:车忱 责任校 对:张艳 霞 责 任印制:李洋 三 河市宏达印刷有限公司印刷 2015 年 4 月第 1 版第 1 次印刷
184mm x260mm · 21. 25 印张· 527 千字 0001 -3000 册
标准书号: ISBN 978 - 7 - 111 - 49628 - I 定 价: 63.00 元
凡购本书,如有缺页 、 倒 页、脱页,由本社发行部调换 电话服务 网络服务
服务咨询热线: ( 010) 88361066 机 工官 网:吓w. cmpbook. com 读者购书热线: ( 010) 68326294 机 工官博 : weibo. com/crnpl952 ( 010 ) 88379203 教育服务网: www. cmpedu. com
封面无防伪标均为盗版 金书 网: www. golden-book. com


出版说明
随着信息科学与技术的迅速发展,人类每时每刻都会面对层出不穷的新技术和新概念。
毫无疑 问,在节奏越来越快的工作和生活中,人们需要通过阅读和学习大量信息丰富、具备
实践指导意义的图书来获取新知识和新技能,从而不断提高自身素质,紧跟信息化时代发展
的步伐 。
众所周知,在计算机硬件方面,高性价比的解决方案和新型技术的应用一直备受青眯 ;
在软件技术方面,随着计算 机软件的规模和复杂性与日俱增,软件技术不断地受到挑战,人
们 一 直在为寻求更先进的软件技术而奋斗不止。目前,计算机和互联网在社会生活中日益普
及,掌握计算机网络技术和理论已成为大众的文化需求。由于信息科学与技术在电工、电子、
通信、工业控制、智能建筑、工业产品设计与制造等专业领域中已经得到充分、广泛 的应用, 所以这些专业领域中的研究人员和工程技术人员越来越迫切需要汲取自身领域信息化所带来
的新理念和新方法 。
针对人们了解和掌握新知识、新技能的热切期待,以及由此促成的人们对语言简洁 、内 容充实、融合实践经验的图书迫切需要的现状,机械工 业出版社适时推出了“信息科学与技 术丛书”。这套丛书涉及计算机软件、硬件、网络和工程应用等内容 ,注重理论与实践的结合, 内容实用、层次分明、语 言流畅,是信息科学与技术领域专业人员不可或缺的参考书。
目前,信息科学与技术的发展可谓 一 日于里,机械工业出版社欢迎从事信息技术方面工 作的科研人员、工程技术人员积极参与 我们的工作,为推进我国的信息化建设作出贡献。
机械工业出版社
rn


序
接到作者电话要我为他们的新书作 序 ,颇为 惶恐 ,因为 五年前我是从作者录制的 VTK
(Visualization Toolkit) 入门视频开始学习可视化技术的,而且我的 VTK 技 术肯定掌握得不
如他们全面和深入。但是想到和作者结缘是因为 VTK, 如今 两位作者把他们多年的经验积
累成书出版,对千像我 当年那样需要 VTK 入门和 深入学习的人员无疑是个福音 。 作为这个
领域的从业者,加上这份信任更让我义不容辞,就借这个机会谈谈我对 VTK 应 用的体会和
想法 。
VTK ,它来了
这是个数据爆炸、互联互通、绚丽 多彩 的 信息时代 , 我们的每一次 呼吸伴随 着 无数信息
的 产生 、传递和展示 。视觉是 人类获取信息最重要的通道 , 在计算机学科的分类中,利用人
眼感知能力对数据进行交互的可视表达以增强认知的技术,称为可视化技术 。 数据可视化技
术构建了数据到视觉之间 的桥梁 ,让我们从不 同的视角和维度来观察这个世界,洞察那 些海
量数据背 后 的知识、内涵和规律 。
互联网推动这个时代发生了 一 场深刻的变革,而互联网发展倡导的共 享 、 开放 、 平
等的理念催生了软件领域的开源共享,而开源共享又极大程度地促进 了互联网和软件技
术的发展 。
本书介绍的 VTK 就是在这样一个 大背景下诞生并发展的开源软件。开放和平 等聚集了
众 多 的开发者社群 , 同时 也促进了其自身不断的进步和发展,开源共享 使得 VTK 在各种应
用和差异化平台下都得到了长足的发展,在这个基础 上发展出不同应用方向的分支工具包,
尤其是已经广泛应用千科学数据的 三 维可视化 ,如 建筑学 、 气象学 、 生物学 、 航天航空领域
等 , 其中在医学影像领域 的应用最为常见 。
VTK 是 一个很适合进入 3D 可 视化 技术领域的入口 , 因为经过 20 年左右的积累 ,这个
工具包在数据描述 、 存储管理 、 图像处理、 三 维重建、交互接 口 和可视化 等方面积累 了非常
多 的基础功能,通过对这些功能的 学习 , 结合 VTK 提供的实例进行学 习,那么 在 3 D 可视
化领域的技术入门就站在 一 个相对较高 的 起点上,尤其这本书是用中文书 写 的,并 且经过实 战检验,能更快地帮助入门者进阶到可以实战做项目的阶段 。另外, VTK 支持 Linux 、 Windows 、 Mac OS 等操作系统 , 支持和不同语 言 的 UI 开发库 的 结合,且不断 出现和 VTK
相关的 一些扩展开源库 ,可以为 未来 3D 可视化应用提供支撑和无限可 能。
VTK ,我们来了 图像和图形处理技术随着近年 CPU 和 GPU 的计算能力不断增长,在处理能力和速度方 面的进步使得一些三维可视化的潜在需求得到激发,从而走入我们的 生活。 3D 电影给我们 更真实 的沉浸感, 3D 地 图让我们更易千 识别地理标识,虚拟现 实可 以 给我们 展示一个 虚拟 现实场景。 2014 年 4 月, Facebook 用 20 亿美元收购沉浸式虚拟现实技术厂商 Oculus VR,
IV


这让人感觉有点疯狂,但是我们应该看到隐藏在这背后的信息一一这些新的图像和图形技术
正在给我们的生活带来巨大的变化,而且我相信这种改变以后会无处不在,因为我们生活在
一 个立体维度的世界,而 3D 可视化能更真实地表达这个世界。 在医学影像领域,经过多年的发展, CT 和 M阳图像的技术是常见的诊断方法,但是为
了进行更加精准的治疗和手术 , 医生需要三维医学影像的信息来评估病情和确定治疗方案。
例如,通过 3D 图形缩放、旋转、透明化,既可立体化、多视角、全方位地观察肿瘤的部
位、大小、形态,又可有针对性地重点观察肿瘤与血管的关系,据此进行术前精细的仿真
规划,实现虚拟手术切除后残留体积的计算,科学评估肿瘤的 可切除性。此外,在手术方
案、治疗评估、手术规划、手术导航、 3D 打印等方面都有广阔的应用前景,技术的进步
给出直接感官刺激之后,会激发更多的可能。
回到五年前那个炎热的下午 ,在 华南师范大学一间典型的科研办公室中,简易 木质办公
桌上那台图形工作站显得十分扎眼 ,当屏幕上出现的 3D 医学影像可视化模型开始旋转
时,那种视觉上的震撼和冲击让人至今难忘。而当我更深入地了解到,就是利用这种技
术曾经帮助一个在医学上被判死刑的人重获新生时 ,我马上认定就是它了。此后的几年
我 一直关注 这个项目 。
千是有了在第 一 段描述的内容,也是因此结识了火灵和晓东两位作者以及在这个
领域内的几位先行者。那个时候的圈子很小,资料很难找,好在有火灵手 把手教的视
频以及他热心和真诚的帮助,我们最终选择 VTK 作为核心基础库来开发我们的应用和
产品 。
使用了 VTK 这么久,说说我们团队的心得吧。身处开放的时代,做任何事情我们都需
要站在前人的肩膀上,因此在 3D 可视化技术领域, VTK 作为起点几乎是不 二的选择。至今
我们还在庆 幸当 初的选择,我们团队在这个核心的基础上利用 MFC 开发的架构,差不多用
半年时间就实现了在医学影像领域的产品级架构 , 一年左右 的时间推出第 一 个产品原型,这
些都得益千这个选择。
本书对基本概念、数据结构、图像处理、图形处理、可视化、交互界面以及 VTK 的发
展和扩展都做了详尽的介绍,是目前我看到的介绍 VTK 的中文书籍中最好的 一 本。在此,
结合我们的工作和应用的经验,对 VTK 和本书的学习给出如下建议: 基本概念和数据结 构
是最重要的基础,是必须重点掌握的,这对千理解 3D 可视化和 VTK 本身尤为关键;图像
和图形处理可以重点把握实现的方法,具体的算法可以根据需要来进行选择性的学习;可视
化管线 (Pipeline) 是实现从数据到显示结果的组织形式,是 VTK 中的核心概念,需要很好
地理解和掌握;涉及 GUI 和交互就需要根据不同的应用和平台进行,考虑的核心因素是数
据结构和交互命令的接口,这个部分也可以根据已有的经验去选择,比如 MFC 还是 Qt 基本
都不是问题,熟悉哪个就选哪个吧。
当然 ,要学好和用好 VTK, 我觉得必要的基础不仅是 CIC++ ,还要学好 一 些基础的计
算机课程,例如操作系统、编译原理、数据结构和计算机图形学,这几门计算机课程对于学
好、用好这个 工具包是必备的基础。因为我们不仅需要关心 VTK 提供怎样的开发接口,而
V


且还需要理解 VTK 的代码组织、数据管理、代码重用、关键算法等相关内容,这些内容对
于深入学习都大有裨益。不过大家于万别被我吓倒,我说的这几门功课是计算机学科最基本
的课程。重要的是基本概念有了,需要什么知识再去深入研究是最好的学习和工作方法,在
这项技术上也不例外。
该你们了,一起来学习 VTK
我想说,在这个浮躁、物质化的时代,能编写专业的技术书籍并不容易 。 尤其在了解两
位作者是在繁忙的工作之余去编写本书后,对千他们所做的工作和坚持的态度,我感到由衷
的敬佩和感动。我和他们 一 样,相信在这个世界上,美好的事情终究会发生,但是需要从日
常的点滴和不懈的坚持开始。对千 3D 可视化来说,就从这本书开始!
是为序。
VI
VTK 老兵叶建平,深圳市旭东数字医学影像技术有限公司总经理
2014 年 l0 月 12 日


前I
口
视觉是人类获取外部信息的最重要方式,研究表明,人类通过视觉通道获取的信息占总
获取信息的 80%以上。正所谓“百闻不如一见“,视觉信息比文字、数字等信息更加直观,
信息量更为丰富。因此,通过图形图像等方式将数据进行可视化,有助于人们理解数据。
早在 20 世纪初,人们已经将图表和统计等低级的可视化技术应用千数据分析中。在
现代社会中,随着科学技术的迅猛发展,借助超级计算机、航空航天、 CT (计算机断层
扫描)、核磁共振以及地质勘探等手段,人们可以获得海量的科学数据。而人们进行科
学研究的目的不仅仅是为了获取数据,更重要的是分析数据以探索自然规律,这成为人
们面临的巨大挑战 。 而传统的可视化技术已不能满足需要,科学计算可视化得到了广泛
的关注与发展。
科学计算可视化
科学计算可视化的概念早在 20 世纪 80 年代就已经提出。 1987 年 2 月, 美国国家科
学基金会召开的一个专题研讨会上正式提出了“可视化” 一 词,并在会后发表的正式报
告中给出了科学计算可视 化的定义、 覆盖领域以及近期与长期研究方 向。这标志 着科学
计算可视化作为 一 个学科在国际范围内已经成熟 。
科学计算可视化的含义是运用计算机图形学的原理和方法,将科学与工程中产生的
大规模数据转换为图形、图像,以直观的方式显示出来。它涉及计算机图形学、图像处
理、计算机视觉、人机交互等多个研究领域,是当前计算机图形学的重要研究方向。随
着计算机硬件配置不断提高 ,计 算能力极大增强,许多重要的图形图像处理算法可 以快
速地通过硬件实现 。 因此,基于科学计算可视化技术来直观地展示数据计算过程与结
果,并进行交互处理,已经成为可能。
可视化函数库
随着科学数据可视化技术的发展,出现了大量 的新的软硬件可视化技术和手段。广大从
事可视化工作的科研与工程人员迫切需要 一 种功能强大的可视化开发工具。相信许多人已经
接触或者听说过 OpenGL 。 OpenGL 是行业领域中最为广泛接纳的 2D/3D 图形 API 。它采用
C 语 言风格,提供大 量 的函数来实现从简单到复杂图形的渲染。另外 一个与 OpenGL 类似的
函数库是微软的 Direct3D 。 然而,无论是 OpenGL 还是 Direct3D, 都仅提供底层的 API 接口
供用户使用,因此学习和使用这两个工具都有 一 定的难度,通常需要用户深入理解计算机图
形学的基础知识 。 另外,它们并未封装当前流行的可视化算法,例如体绘制算法。对于工程
人员来说,使用底层 API 开发这些算法,既制约了工程开发效率,也不利千代码复用。因
此,工程开发与科研人员更需要 一 种功能强大、方便易用的可视化开发库,而 VTK
(Visualization Toolkit, 可视化工 具包)即是这样一种 工 具。
VTK 是一 个用于可视化应用程序构造与运行的支撑环境,它是在 OpenGL 的基础上采
VII


用面向对象的设计方法发展起来的。 VTK 将可视化开发过程中经常遇到的细节屏蔽起 来,
并将常用的可视化算法(例如 Marching Cubes 方法)以类的方式进行封装,为从事可视化应
用程序开发 工作的研究 人员提供了 一个强大的开发 工具 , 因此 VTK 发布后得到了广泛的关
注与应用。
写作初衷
VTK 是 一种开源的、跨平台的、可自由获取的可视化函数库,来自世界各地的开 发人
员可以修改以及贡献个人的代码。同时, VTK 很早就组建有用 户及开发者社区 ,方便世界
各地的 VTK 使用人员及开发人员的技术交流 。 截至当前,系统介绍 VTK 的书 籍主要有
Kitware (http://www.kitware.com) 公司出版的 VTK 教科书及配套的 《 VTK User's Guide》两
本书(详见本书参考文献) 。
国内的 VTK 用户和开发人员在学习与使用 V兀`时,通常 参考 VTK 的 官方文档以及上
述两本英文书籍。此外,网络上介绍 VTK 的文章虽多如 牛 毛,但大都比较零碎,缺乏系统
性。截至本书出版,国内还未出现系统介绍 VTK 的中文书 籍。
本书的两位作者相识千 2010 年,在此之前,双 方都学习与使用过 VTK, 2010 年起
共同就职千深圳先进技术研究院,在共 事期间 , 曾使用 VTK 、 ITK ( Insight
Segmentation and Registration Toolkit) 、 IGSTK ( Image-Guided Surgery Toolkit ) 、
CMake 等工具开发过多个科研项目, 一 路走来,深知各种开源框 架 、 算法的学习门槛是
多么让人望而生畏,深刻体会过 VTK 学习和使用过程中的艰 辛。 从 2010 年起 ,本书的
两位作者共同制作了《 一 起学习 VTK 》 和《 一 起 学习 ITK 》等系列视频教程 , 承蒙各位
初学者的 厚爱 ,从视频 发布起 , 得到了不少初学者的支持 。 这也给了作者编著 一 本 系统
介绍 VTK 中文书籍的信心 。
2011 年起,本书作者陆续在 网络上发表多篇与 VTK 、 ITK 等相关的文章 , 并于 2013 年
初开通了 CSDN 专栏。本书 即是在该专栏 的 基础上,对内容 重新整理与 补充, 在 工 作之余前
后 历时两年编 写了 本书,旨在为 VTK 用 户提供 VTK 入门 与提高的参考资料,为 VTK 用户
提供一 定的指导。
在 写 作本书时,作者得到 了来自不 少同行的帮助, 其中特别要感谢的是来自深圳市旭东
数字医学影像技术有限公司的张磊 ,他在繁 忙的工作 之余给本书部分章节作了校对并提出了
很多 宝贵意见,使本 书 的内 容更加 完善。
本书面向的读者 本书从 VTK 最基础的部分开始讲起,并一 步步深 入地探讨 VTK 底 层 的 架构 ,比如智能 指针、可视化管线等内容,最后介绍如何基 千 VTK 的框架实现自己的算法 。 因此 ,本书既 适用于 VTK 零基础的用户,也适用 于对 VTK 有一定的了解,想进一步提 高 的 开发人员。 本书通过大量的 实例来阐 释 VTK 的 学 习和使用方法,在选择 实例时 , 结合作者开发经 历,以实用性实例为 主。 书中实例全部采用 C廿实现,在 Window 7 、 Visual Studio 2008 环境下
均测试通过, 示例 程序和运行结果截图可在机械工 业出 版社网站 ( http://www.cmpbook.com )
免费下载。
VIII


本书章节安排
本书主要内容如下:第 1 章为 VTK 概览, 主要介绍了 VTK 的发展历程, 并详细 分析了
VTK 的编译安装过程第 2 章以实例开题, 着 重分析了 VTK 渲染引擎和可视化管线;第 3
章详细分析了 VTK 的 基本数据结构,并在第 4 章中 以 实例介绍 VTK 常用数据的读写功能;
第 5 章内容为 V吓: 图像处理,主要涉及图像基础操作、边缘检测、图像平滑以及图像频域
处理;第 6 章分析 VTK 图形处理技术,包括网格平滑、封闭性检测、连通分析、多分辨率
处理、表面重建、点云配准和纹理映射等内容;第 7 章介绍 VTK 体绘制技术,通过实例分
析了不同的体绘制算法;第 8 章为 VTK 交互技术 ,是 实现 VTK 应用程序中 用户交互 的 主 要
手段;第 9 章为 VTK tE Qt, MFC 等环境 下的开发技术 ; 第 10 章分 析了 VTK 的基础架构和
管线机制,并通过实例讲解自定义 Filter 类;附录中列举了 VTK5 与 VTK6 的区别,并给出
了几个实用 VTK 工程。
由千受到学识和时间的限制,本书中难免有不足之处 ,敬请广大同行和读者批评指正。
张晓东 罗火灵
2014.11.5
IX


目录
出版说明
序
前言
第 1 章 VTK 概览·········· · ················ ·· ····· · ·· ··· 1
1.1 V双概述······································· 1
I.I.I VTK 是什么 ··· · · · ·············· · ········ 1
1.1.2 VTK 能做什么·············· · ······· · ·· 1
1. 1.3 如何获取 VTK 源码...·...... ...... ·· 2
1.1.4 VTK 学习资源 .............. . ........ ··5
1.2 VTK 的编译安装.........·........... ... · · ·5
1.2.1 编译 VTK 的准备工作... ............ 6
1.2.2 编译 VTK 的详细步骤... ............ 7
1.3 创建一个简单的 VTK 程序......... 12
1.3.1 什么是 CMake····· .... . ....·..... ... · 12
1.3.2 CMakeLists.txt 脚本文件......· ··· 13
1.3.3 CMake 的几个常用命令·......... 16
1.3.4 一个简单的 VTK 工程... ......... · 19
1.4 本章 小结 ············· ·· · ····· · ·· ·· ············20
第 2 章 VTK 的基本概念...... ..................... 21
2.1 一个稍微复杂的 VTK 程序......... 21
2.2 三维场 景 的基本要素.................. ·26
X
2.2.1 灯光 ··········· ·· ·················· · ······26
2.2.2 相机 · · · ·· ·················· · ····· ·· ···· · · ·27
2.2.3 颜色 · ·········· · ··· ·· ··· · · ···· ···· ·· ··· ·· ·29
2.2.4 纹理映射 · · ······················· ·· ··· ·30
2.3 坐标系统及空间变换 ...... ............ ·31
2.3.1 坐标系统 · · ············· ··· · · ··········· 31
2.3.2 空 间变换.. .. . . ..... . ............. . ..... 34
2.4 VTK 管线.. .......... . ... . . ................... 35
2.4.1 VTK 渲染弓 I 擎 .............. . .. . ..... 35
2.4.2 VTK 可视化 管 线... ............. ····37
2.5 V欢 智能指针 · ···· ··· · ····················41
2.5.1 弓 I 用计数. ............. ............... ··4 1
2.5.2 智能指针 ······ ·· ···· ···················42
2.5.3 运行 时类型识别.........·........... 45
2.6 本章小结 ·············· · ·· ····· ···· · · ······ · ···46
第 3 章 VTK 基本数据结构 ..................... ··47
3.1 可视化数据的基本特点... · ......... ··47
3.2 数据对象和数据集...... ....... ......... · 48
3.2.1 vtkDataObject ······ ··· ················ 48
3.2.2 vtkDataSet· ······· ······················ 48
3.3 单元类型...... . ... . .... . . ... . . ... . ............ 53
3.3 . 1 线性单元 ·························· ·····56
3.3.2 非线性单元. .. ......... .... . .. . . ....... 57
3.4 属性数据. .. ..... . .. . ............ .. ............ 59
3.4.1 标 诫 数据 .. ...... ... . . . ..... . ......... ··60
3.4.2 矢批 数据 .. . ... . .... ·· · ····· · ·········· · 61
3.4.3 纹理坐标 ····· · ····· ·· ········· · ········61
3.4.4 张 扯 数据........... .. ................·· 61
3 .5 不同类型的数据集 ..................... ··62
3.5. l vtk.lmageData· ·····--·················· 62
3.5.2 vtkPolyData ······ ······················ 63
3.5.3 vtkRectilinearGrid···· ··· ...··········63
3.5.4 vtkStructuredGrid ········ ············ 63
3.5.5 vtkUnstructuredGrid ················· 63
3.5.6 vtkUnstructuredPoints··...·........·64
3.6 数据的存储与表达............·...... ... ·64
3.6. 1 vtkDataArray ···· ······ ··· ········· ···· 64
3.6.2 数据对象的表达 .. ............ ...... ·66
3.7 本章 小 结 · · ······ ·· ··· · ··· ···· · ···· ········· · · ·67
第 4 章 VTK 数据的 读写······ · ··· · .............. ··68
4.1 Reader 与 Writer 类 ...................... 68
4.1. 1 vtk.lmageData 类型 ............... · ·· 68
4. 1.2 vtkPolyData 类型 ··········· · ··· · ···· 73
4.1.3 vtkRectilinearGrid 类型 ... ···· · ····74
4.1.4 vtkStructuredGrid 类型 ...· · ····...· 74
4.1.5 vtkUnstructuredGrid 类型 ·... .. ... 74


4.2 场景的导入与导出 ....................... 74
4.3 本章小结... .. . .. ............................. . 76
第 5 章 VTK 图像处理........... . .... ..... ......... 77
5.1 VTK 图像创建.... .. ....... . ............... 77
5.1.1 VTK 图像数据结构 ............ ..... 77
5.1.2 VTK 图像创建....................... 78
5.2 VTK 图像显示............................. 80
5.2. 1 vtklmageViewer2..................... 80
5.2.2 vtklmageActor.... .................... 82
5.2.3 图像融合 .. ............ .. ....... . ....... 84
5.3 VTK 图像基本操作...... ............... 85
5.3 .1 图像信息的访问与修改........... 85
5.3.2 图像像素值的访问与修改........ 88
5.3 .3 图像类型转换.... ..... . ... . ...... .. ... 91
5.3.4 图像颜色映射....... .......... ..... ... 92
5.3.5 区域提取. ..................... . ........ 96
5.3 .6 直方图统 计... ................... .... 102
5.3.7 图像重采样............. .. ..... .. .... 107
5.3.8 图像运算 .... .... ................ .. ... 109
5.3.9 图像 二 值化 .... .. .... . ............ ... 112
5.4 边缘检测 .................................... 114
5.4. 1 梯度算子. ..... ..... . .. ..... . ......... 114
5.4.2 Canny 算子......... ................. 117
5.4.3 拉普拉斯算子.... .......... ....·... ·120
5.5 图像平滑...... .... . ........... . . . . .......... 121
5.5.1 均值滤波 ............................. 122
5.5.2 高斯平滑 ............................. 123
5.5.3 中值滤波. .... ..... ... ... ..... ..... ... 124
5.5.4 各向异性滤波.. ... . ... · ..... ....... 124
5.6 频域处理............ ........................ 125
5.6.1 快速傅里叶变换 ..................· 126
5.6.2 低通滤波.................. ...... ..... 128
5.6.3 高通滤波 .... .. .. .. .. . . .. .. .. .. . ...... 130
5.7 本章 小 结 .................................... 132
第 6 章 VTK 图形处理............................. 133
6. 1 vtkPolyData 数据生成与
显示 ...... .... .......... . ........................ 133
6.1.1 vtkPolyData 数据源·.............. 134
6.1.2 vtkPolyData 数据的创建 ... ..... 135
6.1.3 vtkPolyData 属性数据...... ...... 137
6.2 基 本的图形操作........................ ·141
6.2.1 法向量计算 .................... ...... 143
6.2.2 符号化 Glyphing ·.................. 146
6.2.3 曲 率 计算............................. 147
6.3 网格平滑...................... .............. 149
6.4 封闭性检测............. ................... 151
6.5 连通区域分析......... .................. · 152
6.6 多分辨率处理........................ ..... 155
6.6.1 网格抽取................ ............. 155
6.6.2 网格细化............................. 156
6.7 表面重建....... .. ........ . .................. 158
6.7.1 三角剖分.. ........ ................... 158
6.7.2 等值面提取 ......·................... 160
6.7.3 点云重建 .................... . .... .... 162
6.8 点云配准 .................................... 163
6.9 纹理映射.... ................................ 167
6.10 本章 小结.... .... .. ..... .. ....... .. .. .. .... 168
第 7 章体绘制.. ............ .... .. ..................... 170
7.1 体绘制管线 .. . ............................. 170
7.2 vtkVolumeMapper....................... 173
7.2.1 vtkVolwneRayCastMapper ...... 173
7.2.2 vtkFixedPointVolumeRay
CastMapper.......................... 176
7.2.3 vtkGPUVolumeRay
CastMapper ·....·.................... I 77
7.2.4 纹理 映射体绘制..................· 178
7.2.5 裁剪 ................. .... ............... 181
7.2.6 法向编码 ............................. 182
7.3 vtkVolume................................... 183
7.3.1 不透明度传输函数 ............·... 183
7.3.2 梯度不透明度函数...............· 185
7.3 .3 颜色传输函数.. ........ ...... ...... ·185
7.3 .4 光照与阴影..........·..... ...·...... 187
7.3.5 vtk.LODProp3D..................... 188
7.4 不规则网格数据体绘制
技术·············· · ·· · ···· · ·· · ··· ······ ······ ·· 189
7.4.1 vtkUnstructuredGridVolume
RayCastMapper ..................... 190
XI


7.4.2 vtkUnstructuredGridVolume
ZSweepMapper ..................... 190
7.4.3 vtkProjectedTetrahedra
Mapper............... ................. 190
7.4.4 vtkHAVSVolumeMapper·...·...·191
7.5 本章小结. ... .. ...... ........... .. ...... ..... 192
第 8 章 VTK 交互与 Widget ......... ·......... 194
8.1 观察者/命令模式.........·............· 194
8.1.1 事件回调函数................. . ..... 194
8.1.2 vtkCommand 子类................. 196
8.2 交互器样式...·......................·... .. 198
8.2.1 vtkRenderWmdowlnteractor...... 198
8.2.2 vtklnteractorStyle·······..····...... 206
8.3 VTK Widget··.. ··.......................... 212
8.3. ] 创建 Widget 交互.................. 216
8.3.2 测量类 Widget ............. ... ..... ·219
8.3.3 标注类 Widget ... ...... ...·......... 220
8.3.4 分割/配准类 Widget ............ .. 222
8.3.5 其他 Widget......................... 223
8.4 拾取 .... .. ................................. ..... 223
8.4.1 点拾取 ... .... .......................... 224
8.4.2 单元拾取 ............................. 226
8.4.3 Prop 拾取. . . ................... ... .... 228
8.5 本章小结 ... . ... ..... ...... ... ........... ... . 230
第 9 章基千 VTK 的 GUI 应用程序...... · 23 1
9.1 基千 Qt 的 VTK 应用程序... · ..... 231
9.1. ] 用 CMake 管理 Qt 工程 ...·..... 231
9.1.2 用 CMake 管理 Qt 与
VTK 工程 ....... . .......... .. ........ 233
9.1.3 环境变量的加载.................. ·234
XII
9.1.4 用 QVTKWidget 整合
Qt 和 VTK........... . .... .. .. . ... . .. 236
9.2 基千 MFC 的 VTK 应用程序 ...... 240
9.2.1 基千单文档的 VTK 应用
程序. ................................... 240
9.2.2 基千 VTK 的图像重采样
程序. ................................... 247
9.2.3 基千对话框的 VTK 应用
程序. . .. .... ........................ . .. . 253
9.3 本章 IJ \结 ..... ......... ...... . .... .. .. . ... .. . 264
第 10 章自定义 VTK 类........................ ·265
10.1 VTK 开发基础......................... 265
IO.I.I 弓 1 用计数与智能指针·......... · 265
I0.1.2 vtkObject 类分析·............... · 269
10.1.3 VTK 类的实现.............. . ..... 273
10.2 VTK 管线机制 ......................... 279
10.2.l 信息对象类
vtklnformation.......·............ · 281
10.2.2 管线执行模型..................... 286
10.3 自定义 Filter · . . ......... ...... . . ........ · 290
10.3.1 自定义 Fi lter 基本步骤...... ... 290
10.3.2 Filter 实例...... . . .. .... . .. . ........ 296
10.4 本章小结. ........ . . . .... . ............ . . ... 302
附录. .............. ..... ........ ... .............. . . ..... . .. ...... 303
附录 A 从 VTK.5.0 到 VTK.6.0 ...... ·303
附录 B 体绘制传输函数控件... · ...... 323
附录 C VTK 中文的 实现 ............... · ·325
附录 D VTK 在商业软件中
的应用.. .............. ...... . ....... ... . 326
参考文献 ... .. .. ........ .... ....... . ..... . ............. . .. . .. . 328


第 1 章 VTK 概览
1.1 V"`概述
数据可视化主要是通过计算机图形学的方法,以图形、图像等形式清晰有效地传递、表
达信息。随着数据获取手段的多样化以及数据规模的不断增长,数据可视化日益彰显其重要 地位 。 从 20 世纪 90 年代起,针对数据可视化编程的工具包应运而生, VTK 是其中最具代表
性的工具包之 一 。 也许读者尚未使用过 VTK, 或者在这之前已经接触过 VTK, 想进一 步提高 VTK 编程技 术,那么本书将会是最佳选择。学习 VTK 之前,读者要有 一定的 CIC丑口编程知识以及基本的
计算机图形学的理论知识 。 本书将会从 VTK 最基础的部分讲起,循序渐进,借助一系列的示 例程序帮助读者学习并进一 步提高 VTK 的开发技术 。
1.1.1 VTK 是什么
VTK 的 全称是 Visualization Toolkit, 即可视化工具包,它是一个开源、跨平台、可自由
获取 、 支持并行 处理的图形应用函数库。
V叹 最早是作为 Prentice HalJ 在 1993 年出版的《 The Visualization Toolkit: An
Object-Oriented Approach to 3D Graphics》 一 书的附件出现的。该书及相应的 VTK 软件由美国
GE 公 司的 三位研究人员 Ken Martin 、 Will Schroeder 和 Bill Lorensen 用闲暇时间合作编著与开
发的,因此该软件的授权完全由 他们决定 。 由千其开放源码式的授权,该书上市后,很快就 建立起 VTK 的 使用者及开发者社区交流平台 ,同时 GE (特别是 GE 医疗系 统)与其他数家
公司也开始提供对 VTK 的支持。
1998 年 , Will Schroeder 和 Ken Martin 离开 GE 后创立了 Kitware 公司 Chttp://www.
kitware.com) 。 有了 Kitware 的 资金支持 , VTK 社区成长迅速,而 且在学 术研究及商业应
用领域都受到了重用,例如 Slicer 生 物医学计算软件使用 VTK 作为 其核 心、许多有关 VTK
的 IEEE 论文出现。 VTK 也是许多大型研究机构,如美国的 Sandia 、 Los Alamos 及 Livermore 国家实验室与 Kitware 的合作 基础 ,这些研 究机构使用 VTK 作为数据可视化处
理工具 。 VTK 同时也是 美国国立卫生 研究院 (National Institutes of Health, NIH) 创立的
美国国家医学影像计算合作联盟 ( National Alliance for Medical Image Computing, NA-MIC) 的关键计算工具。
1.1.2 VTK 能做什么
三 维计算机图形、图像处理及可视化是 VTK 主要的应用方向。通过 VTK 可以根据 许多学科(如建筑学、气象学、医学、生物学或者航空航天学)中的实验数据,进行逼
l


VTK 图形图像开发进阶
真的体、面、光源等渲染,从而帮助人们理解那些采取错综复杂的、规模庞大的数 字呈
现形式的科学概念或结果。 VTK 包含 一个 C丑类库,众多的编程语言接口层,包括 Tcl/fk 、 Java 、 Python 。 VTK 是
在三维函数库 OpenGL 的基础上采用面向对象的设计方法发展起来的,它将可视化开发过程
中会经常遇到的细节屏蔽起来,并封装了 一些常用算法 ,比如, VTK 将表面重建中比较常见
的 Marching Cubes 算法封装起来,以类的形式供用户使用,这样在对三维规则点阵数据进行
表面重建时就不必重复编写 Marching Cubes 算法的代码,只需直接使用 VTK 中已经提供的
vtkMarchingCubes 类即可。 VTK 为从事可视化应用 程序开发工作的研究人员提供技术支待,是一个强大的可视化开
发工具。它具有如下特点。 1) VTK 具有强大的 三 维图形功能。 VTK 既支持基千体素的体绘制 ( Voxel-Based Volume
Rendering ) ,又保留了传统的面绘制 (Surface Rendering ) ,从而在极大地改善可视化效果的同
时又可以充分利用现有的图形 库和图形硬件。 2) VTK 的体系结构使其 具有非常好的流 ( Streaming ) 和高速缓存 (Caching ) 的能力,
在处理大量的数据时不必考虑内存资源的限制 。 3) VTK 能够更好地支待基千网络的工具,比如 Java 和 VRML 。随着 Web 和 Internet 技
术的发展, VTK 有着很好的发展前景。
4) VTK 能够支待多种着色语言,如 OpenGL 等。 5) VTK 具有设备无关性,这使得其代码具有良好的可移植性。 6) VTK 中 定义了许多宏,这些宏极大地简化了编程工作并且加强了一致的对象行为。 7 ) V双 具有丰富的数据类型,支持对多种数据类型进行处理。
8) VTK 的跨平台特性方便了各类用户。
1.1.3 如何获取 VTK 源码
VTK 是开放源码的,可以 自由地从 VTK 网站 ( http://www.vtk.org ) 上免费获取源码, VTK 源码的下载页面地址为 http://www.vtk.org/VTK/resources/software. html 。 截至 20 14 年 7 月 , VTK 官方发布的 最新版本为 6.1.0 (本书开始写作的时间是 2013 年初,当时 VTK 6.0.0 版本 尚未正式发布,因此本书内容以 VTK 5.10.1 为标准 。 VTK 5 . 10.1 之后 VTK 官方发布了 VTK 6.0.0 版本,本书虽然没有使用 最新的 VTK 版本,但是读者可以使用最新的 VTK 6.1.0 版本来 学习本书。本书的附录详细介绍了 VTK 6.0.0 及后续版本的改动和最新特征,有兴趣的读者
可以参考)。 本书所有示例程序和内容均以 VTK 5.10.1 版本为准。在 Windows 下,编译安装 VTK 需
要下载的文件如下。
• vtk-5.10.1.zip (或 vtk-5. 10. 1.tar.gz) —包含了 VTK 所有核心源代码以及相关的示例程序,
下载地址 http://www.vtk.org/files/release/5. IO/vtk-5.10. l.zip, 该文件必须下载。
• vtkdata-5.10.1.zip (或 vtkdata-5. 10.1 .tar.gz) -—包含了 VTK 自带的示例或测试程序运
行时需要用到的数据,可选择下载,地址 http://www.vtk. org/files/release/5. l 0/
vtkdata-5 .1 0.1.zip 。
2


笫 1 章 VTK 概览
• vtkDocHtml-5 . 10.1 .tar.gz-VTK 的文档文 件 , 在 Windows 下解压后,打开 index.html 文件即可查看 VTK 各个类以及程序接口详细的使用介绍。下载地址
http://www.vtk.org/files/release/5 . l O/vtkDocHtml-5.10 . 1.tar.gz, 对 VTK 初学者来说,建
议下载该文件。这些 HTML 文档都是由 Doxygen 工具 ( http ://www.doxygen.org/ ) 根
据各个类的头文件自动生成的。
• vtk-5.10.0-win32-x86.exe 在 Windows 下安装完这个程序后,可以运行文件后缀
为tel 的 Tel 脚本程序, VTK 自带的许多示例和测试程序都是用 Tel 脚本写的,在第 2
章中会介绍如 何运行 VTK 的 Tel 脚本程序,因此建议安装这个程序 。 下载地址
http://www.vtk.org/files/release/5.1O/vtk-5.10.0-win32-x86.exe 。
除了可以下载 VTK 官方发布的稳定版本,还可以下载到最新的开发版本。 VTK 的代码 管理是采用分布式版本控制工具 Git , 所以如果要下载最新的 VTK 源码(注意:最新的开发 版本的 VTK 源码是 VTK6.X 版 本的,与本书采用的 VTK 5.10.1 的 版本有所不同),需要先安 装 Git, 要求 Git 的版本 至 少为 1 . 6 .6 。
Windows 下可以下载文件 Git-I.7 .9-preview2012020 l.exe (下载地址 http://code.google.com/ p/msysgit/downloads/list ) 。安装完这个应用程序后,如果想使用用户图形界面的 Git, 需要下 载安装 TortoiseGit 工具,下载地址 http://code.google .com/p/tortoisegit/downloads/list 。 这些准备 工 作完成以后,就可以使用 TortoiseGit 从 VTK 代码仓库 ( http://vtk.org/VTK.git ) 中获取最新 的开发版本的 VTK 源代码, 具 体步骤如下 。
1) 以 D: 盘为例 , 在 D: 盘新建文件夹 VTK-git-src , 右击该文件夹 , 从弹出的快捷菜单 中选择 Git Clone 选项,如图 l-1 所 示。
Computer ► software (D:) ► VTK ►
·.-, .
Tools Help
Include in library • Share y八th • New folder
Name Date mod1f1ed Type Size
VTK -g i t - sr c
ces ,tos
Vi ew Sort by Group by Refresh
Customize this folder_,
Paste Paste shortcut Undo Rename Ctrl+Z
Share with
图 1 - 1 新建 VTK-git-src 文件夹界面
2) 在 9it clone 对话框的 Uri 选项框里输入 VTK 的 Git 仓库地址 C http://vtk.org/VTK.git ), Directory 一栏表示本 地下载目 录 , 输入上 一 步新建 的文件 夹 路径,即 D :\VTK\VTK-git-src\, 然后单击 OK 按钮 , 即开始从 VTK 的 Git 仓库复制代码,如图 ] -2 所 示。
3


VTK 图形图像开发进阶
OoneO这Ing Repository
Urt: h叩:/I心 org/VTX.g ,t
Olreclory: 0:\\/TK\VTK寸压-srd
了 巳三三]
口
fr_”J depth 0
团 Lood Putty Key
r·、,.~
己 比心』~ve 己 Oone Into Bore 知po
~口
From SVll Repository
巴 From SVN 知po或ory
____.___飞
' Trunk 四IlK . ,
.. Ta9s 四S 8中nch br.nches
:,,.:, From '.o
L...- ` - - ; I
二 亡亡
U 父rflame
图 1 -2 Git clone 对话框
3) 下载完 VTK 后的目录结构如图 1 -3 所示。
丐 1 令, [}如c/, VTK.9,『 sre P '
file Edit Vi~ Tools Help
Organize • fnclude in hbrary "' Share with 零 New folder
乌]毗•I. ." • r.,下·千尸 o vo”
今 Accelerate" 今 Imaging 今 Web
~ C h a r t s . , lnfOVIS '!> Wrapping 今 (Make ~ lnteract,on i, .91tanr1butes !!)_Common t). 10 9.gitignore G ~ Deprocated ~ Parallel o.hoo比-conf19bash
今 Domains f,1_Rendering ,CMakebst“1X1 t) E,amples t) Te只ing O CONTRIBUTING.md 边 O 础e6 I.) Thi 『dPa rty t) Copyrightuct
j - t) Geovis 少 Utilit ies (ljCTes1Config.cma 灶
34 items
,',
, 廷 . . ~j f)
- .J "J REAOME.html 昂啤anner.gif 吹 vt比ogo.,co II!, vtlclogo.J P9
图 I -3 开发版本的 VTK 源码目录结构
同样的步骤也可以下载 VTKData, 其 Git 地址为 http://vtk. org/VTKData.git, 此处 不
再赘述。 除了采用用户图形界面的 TortoiseGit 下载 VTK, 也可以使用 Git 命令下载, 具体步骤 为: 打开 CMD 窗口,同样以 D: 盘为例,依次输入如下命令:
>D: >mkdirVTK >cdVTK >mkdir VTK-git-src >cd 呕-git-src
>git clone http://vtk.org/VTK.git. (注意:最后有一个点,表示当前目录)
Git 开始从 VTKGit 代码仓库里复制代码,如图 1 -4 所 示 。 4


1-Ill“'.II,I |,一 ·IIII
1血1履“”“衄1
,情匾从1111!11冒III,'11!11圈
It'· Ul 1 l1 1 1 ·` ' l . , L'.l, ' , I”`'r 1,l,',.,.', k. D, `,'.', I ' , '
,: l n,'`',.,''`' ',.. ..
,. c ~` l, - I.“”“'` `',,',,J r, ` 2 : l”`, ·!.m. ',”“``
,.`. nn 1 ,合 ,” “'',.,. ·二'“', o l , j r 正'. I“', ... RI几':,八”w., ; . 'I,' “ '.
凡..,心'".'“'“', l · , , l 9 ., v., lM· ?7, 、. 1. ,·,门, k ; J4H I, ',,.,
~4 巴 己产
图 1 -4 用 Git 命令从 VTKG it 代码仓库里复制 VTK 源码
1.1.4 VTK 学习资源
笫 1 章 VTK 概览
对千 VTK 初学者而 言 ,可能 一 开始都会抱怨 VTK 的 参考资料太少 ,特别 是 中文方面的 资料 。 本书整理了 一 些与 VTK 相关的学习资源 。
• <VTK User's Guide 》这本书的最新版本(第 11 版)是以 VTK 5.4 为基础,主要介绍 VTK 类库的应用 , 由 Kitware 公司出版 。
• <The Visualization Toolkit: An Object-Oriented Approach To 3D Graphics 》是与《VTK User's Guide》配套的教科书,深入讲解了许多可视化算法 、数据结构 等 。
• 《 Source 》是 Kitware 公 司按季度发行的刊物,里面涵盖 了 Kitware 公 司的所有开源项 目 。 一 旦 VfK 有 新功能或新版本发布 , 便会有相关的文 章发表在《 Source 》 上。与 VTK 相 关的其他有用的资源、入 门 文 章 也会在该刊上发表。《 Source 》的在线访问地 址为 http ://www.kitware.com/media/thesource.html 。 • VTK 在线帮助文档 ( http://www.vtk.org/doc/nightly/html/index.html) 或离线帮助文档(即 1 . 1.3 节 里 下载的 vtkDocHtml-5. l 0. 1 .tar.gz 文件) 。 VTK 每个类都提供不同的接口以实 现不同的功能 ,通过文档 查询能了解到这些类的功能及其方法的使用。除在线帮助文 档 之外, VTK 主 页上还有 Wiki 、 常见问题解答等页面的入口 ,都是学习 VTK 不可多 得的资料 。
• VTK users 邮件列表 。 VTK users 邮件列表可以让用户和开发者提问题以及接收别人的 解答、发布更新以及提出改进系统的建议等 。 VTK users 邮 件列表的注册地址是
http://public.kitware.co1n/mailman/listinfo/vtkusers 。
• Insight Journal ( http ://insight-joumal.org/) 同样也 是学 习 VTK 非常有 参考 价值的网站 。
用户可以通过这个网站向 VTK 社区 贡献自 己 的代码,也能下载别人上传的代码,用 千学 习、研究 等。
1.2 VTK 的编译安装
学习 VTK 最 好是从下载 VTK 源码并编译安装开始 。 编译 VTK 是一个很简单的过程,最
5


VTK 图 形图像开发进阶
重要 的 是 把准备工 作做好 。 本节将会详细 演示如何编译安装 VTK 。
它; 本书所用的 VTK 开发环境为 Windows 7 旗舰版 64 位操作系统 ; Visual
Studio 2008 SPl 集成开发环境; CMak.e 2.8.10.2; Qt 4. 8.4 以 及 VTK 5.10.1 Release 版本 。 本书的所有示例程序都是基于这个环境 测 试并 通 过的 。
1.2.1 编译 VTK 的准备工作
首先 , 本 地计 算机 需 要安装 Microsoft Visual Studio 2008 及 Service Pack 1 , 如 果 采用其他
集成开发环境 ( IDE) ,也必须 先 安 装对应 的 IDE 工具。如果 需要编译 64 位版本的 VTK , 在
安装 Microsoft Visual Studio 2008 时 ,必 须安装相应的 64 位组件 。
其 次 , 安装 CMake 。 CMake 下载地址是 http://www.cmake.org/cmake/resources/software. html 。 在 Windows 平台下, 只 要 下载文件 cmake-xx.x.x-win32-x86.exe 即 可 ( xx.x.x 为对应的
CMake 版本号 ) 。 安 装 完 毕打 开 CMake, 其运行界 面 如 图 1 -5 所 示。
如 果在 阅 读本 书 之 前没有使用过 CMake , 也 无需着 急 , 1.3 节将介 绍 关 于 CMake 的 一 些
基础知识 。
A ( Make 2.8.10.2 
I , 干 _ _- -一i
印e Jools Q ptions H elp
Where Is the source code: . 色竺竺 ~ 芒竺丿
. .一一一·············-······•·- 一·一一.. . 一...- ...一.. . ••••• • ••·•· .• •• • ..一· 1
Where to build the binaries: · ··-·•············-······•·- •·••·· · •···· ·· ·•••· ····• · ·• ··· ·· •• • · ~ · ~~J
·---- -J
• • • • ···-·······一....···········-.....
Search: ;另 Grouped ['{J Advanced ~二] .义 8的I扒e En砃
飞a-m;____ _ _ ___ _ _ _ _ _ VaIue - - - - ]
_J
Press Configure to update and display n研 values In red, then press Genen,te to generate selected build files.
L竺三1 口竺竺_丿 current Genen,tor: 即ne -- ··-.. •• --今一,
__ _ _ ___-----__.____J
图 1 -5 CMake 运行界面
另 外,如 果 用 户 希 望自己编译 VTK 类库 的帮助 文档 , 需要安装 Doxygen 工具 。 这一 步
不是必 需 的 ,因为 已经有现成的 可以下载 , 无需 浪费时 间。 此外 ,如 果想使用 Tel、 Python 或者 Java 等语言开发 , 也必须先安装相应 的工具。相 关
的文件可以 在 以 下页 面下载 。
• Tcl/Tk 下 载 地址 http://www.tcl.tk/software/tcltk/ 。
• Python 下 载 地址 http://www.python.org/ 。
6


笫 1 章 VTK 概 览
• Java 下载地址 http://www.java.com/ 。
换言之,如果仅需要使用 C开作为开发语 言,不想编译 VTK 的帮助文档,那么 在编译
VTK 之前,只要安装 Visual Studio 2008 以及 CMake 即可 。
1.2.2 编译 VTK 的详细步骤
将下载的 VTK 源码文件 vtk-5.10.1.zip 解压到某个目录下,比如解压到 D:\VTK\VTK
5.10-src 。 然后,在同级目录下建立一个空的文件夹(注意 :文件夹名字中不要含中文字符)。
为了让文件名看起来规整统 一 ,新建的文件夹命名为 VTK-5.10-bin, 完整的路径为
D:\VTK\VTK-5.10-bin 。
同样将 vtkdata-5 . 10.1.zip 解压到 一个同级目录中,比如 D:\VTK\VTKData, 如果没有下载
vtkdata-5.10.1.zip 文件,这一 步可以跳过。
打开 CMake ,在 CMake 界面上 的 Where is the source code 文本框里输入 VTK 源码的所在路 径,即 VTK 源码目录里最外层的 CMakeLists.txt 文件的所在路径。 在 Where to build the binaries 文本框里输入前一步新建的空文件夹的路径 D:\VTK\ VTK-5.10-bin 。这个文本框所输的路径可 以与 “Where is the source code" 的 一样,但是建议使 用不同的目录。使用不同路径的好处是后续编译过程生成的文件不会与 VTK 的源码混在一 起,可避免对源码目录的"污染”。本书所有示例程序都是将源码与编译生成的文件放在不同 的目录下 。
以 上两 个文本框输入完成以 后 ,单击 Configure 按钮,会弹出如图 I-6 所示的对话框,根 据自己的需要以及计算机上已经安装的 IDE 、编译器等选择适 当的选项即可, 比如, 若使用 Visual Studio 2008, 准备编译 64 位的 VTK, 则可以选择 “Visual Studio 9 2008 Win64" 选项 。 如 果选择错 误 , 需要重新选择 IDE 选项,则应先停止 CMake 的配置或者生成过程,选择 CMake 的 Fi le 菜单下 的 Delete Cache 选项,再用 CMake 重新配置 VTK, 这时就会重新弹出如图 1-6 所示 的对话框,然后单击 Finish 按钮, CMake 即开始根据具体的平台环境配置 VTK 工程 ,配 置 时间随硬件配置 的不同而不同, 一般需要几分钟左右。
(,.) .&
、
Speafy the generator for this project
三产二 —- .I
~ Use default native compilers
S仅ofy native compilers
S伈ofy toolchain file for cross-comp1hng
Speofy opbOns for cross-compiling
,t'
~
l,d I F响 l 厂-厂-1
图 1 -6 CMake 选择编译环境的对话框
配置完成后, CMake 界面如图 ] -7 所 示。
7


VTK 图形图 像开发进阶
A CMake2.8.10.2 • 0-/VTK/呕5.10-bln 飞了心 心一-已· ? '·门· 一....一.
E,le I00l5 如tions t!elp
• --.. -- - r ____-,
Wher .比 lhe source code: 0 :/VTK/VTK-5.10-src : Browse 沁urce , -- }
Where to buIId the bIn.r1es; 0 :/VTK/VTK-5.10-btn • :广 Brow父 au,Jd...
• __
, --.----- -- 1 1
Sea心: ;·: cmu阳d LJ Adv•n<fd : ~ (ldd En叮 ;,.,1 .丘'r,
I
-- - --- -- --- - - -- ---- - - - - - - -- - -- - __了一)一 一. ..
Name Value ^ : 芒,
;I
Pr运 On的ure to update .nd d,",.y new 叫归S,n red, then press Gener.te l0 9enerote selected bu,Id tl.s. : i,
ltl~l芯- no仁 tound ^1
巨]「 云心勹I OrrentCenemtor:V吵 Studio 9 2008 1Nln6'
荨尸:二 ____一 一一』
图 1 -7 首次配置完 VTK 后的 CMake 界 面
1. 部分 CMake 配置选项的说明
默认是关闭的, 若选 中这个选项 ,则 会编译 VTK 示例,同时
BUILD EXAMPLES-m
VTK 编译所需的时间也较长,占用的磁盘空间也较大 。 对 千 初学者来说,建议选中此选项。
BUILD SHARED LIBS-WA默-k次是关闭的 , 意味着 VTK 是静态编译 ; 若选中此选项,
则 是动态编译。 “静态编译“与“动态编译"的区别: 静态编译就是在编译时把所有模块都编译进可执行 文件里去 , 当启动 这个可执行文件时,所 有模块都已被 加载进来。动态编译则是将应用 程序 需要 的模块都编译成动态链接库 DLL, 启动程序(初始化)时这些模块不会被加载 , 运行时
用到哪个模块就调用哪个 DLL 文件 。静态链接库编译相当千带着 一个工具包 到处 跑 , 遇到 有
需要 的地方不需要周围 环境提供相应的 工具 ,用自己 工具 包的工 具就行了 ,不 受环境影响。 动态链接库编译相当于不带任何工具,因此 会受环境影 响 。 这两 者 的 区 别 显然就是前者”重
量 ”增加了,即程序的体积 会 比 后者 的 大。 所以,究竟是 用“静态编译”还 是 “动态编译“, 关键看自己的需要 。 对 于 VTK 初 学者 而 言 ,涉及的 工程可 能都比较小 ,不妨考虑采用“静态编译“,也 方便把 VTK 程序移植到其 他没有安装 VTK 的计 算机上运行。 为了便于与 Qt Designer 的 集 成,本 书的 VTK 类库采用动
态编译。 BUILD_TESTING 默认是打开的, 表示会编译 VTK 的测试程序。 VTK 里每个类都 有 对应 的 程序文件对 该类进行测试 , 为节 省编译 时间 , 可以先 关 闭这个选项, 后续如有衙要 ,
再 打 开此选项 重新编译 。 VTK DATA ROOT 指向 VTK.Data 所 在 的 路径,即 1. 1.3 节里 下载的文件 vtkdata-5 . 10. 1 .zip 解压后 的路径。 一般情况下, CMake 能够自动搜索到,如果没有搜索 到, 可
以 手动输入 , 在运行 VTK 的 示例时 需要 用到这些数据 。 CMAKE INSTALL PREFIX—这个选项的值表示 VTK 的 安装路径 , 默认 的路径是 C:/Program FilesNTK 。该选项的值可不作 更改 , 按默认值即可 。在配置完 VTK 后生成的工 程 中 会有一个 INSTALL 项目 ,编译该项目后即 会在 CM心汪_INSTALL_PREFIX 所指定的路径
8


笫 1 章 VTK 概览
中生成 VTK 相 应的头文件 、 lib 文件和动态链接库 dll 文件。 VTK_USE_QT 是否使用 Qt 。本书使用 Qt 作为 GUI 开发工具,所以选中该选项。 VTK_WRAP_JAVA 、 VTK_WRAP_PYTHON、 VTK_WRAP_TCL 这三个选项是供 准备使用 Java 、 Python 或者 Tel 语言开发 VTK 应用程序的用户选择的。 VTK 由两个子系统组 成,分别是 C廿类库和提供给 Java 、 Tel 和 Python 等语言 来操作该类库的解释器工具,如果
选中其中某 个选项,即 会编译 对应的解释器工具。 选中图 1-7 中的 Advance 复选框,可以在 CMake 界面上看到更多的选项。用户可以把鼠 标在各选项 的名字上停留片刻,即会显示关 千该选项的提示信息。另外, Advance 视图下的
几个选项需要说明 一 下 。 BUILD DOCUMENTATION—.,.默认是关闭的。 若选中此选项,则会编译 VTK 帮助文
档,由于这 个文档 V欢已提供下载,因此可以不选。 VTK USE GUISUPPORT-VTK 是否 支持 GUI 。 Windows 下如果需要使用 MFC 开发的 ,必 须选中 此选项 。本 书 示例会用到 MFC, 因此选中此选项。如果确定不使用 MFC,
可以不选中此选项。 定制完每个选项的值以后,单击 Configure 按钮,继续配置, CMake 界面如图 1-8 所示。
A CMake 2.8.10.2 - D:/VTK/VTK-5.10-bin
.
| tde IooIs 二旦elp
Where isthe source code: D:/VTK/VTK-5.10-src __....一·-....______ 1erowse Sour笠··1 ----__ ____ _ - ---- ---.... --· ------ --- -- -- - 一.·..··· - --
Whereto buildthe binaries: D·:/VT如k5.10.bin... I B(owse I!ulld... I
.....•...
Search: 口 Grouped 0 Advanced ~ [其 阳m咄 Entry |
1 __ _
' Name Value
s
Press Configure to update and display new 四lues Inred, then press Generate to generate selected build files.
I Configure II I -4``一·嘈
如nerate I Current Generator: Visual Studio9 2008 Win64
..一恤_ _ _ _.一· - 1.... - . - . - • - -__- -__ _ _ 上 编全~
Loolc"ino for Q WS Xll
LookinO to工 Q WS Xl.l. - noc found
Look江111 for Q ws WIN
Loolc"丘o for Q WS WIN - found
Lookino for Q二ws二优S
日
Ill
图 I -8 再次 Configure 后的 CMake 界面
由千在前 一 步里选中了 VTK_USE_GUISUPPORT, Configure 以后会有新的红色选项
VTK_USE_MFC 出现,如 果确 定要 使用 MFC, 需要勾 选此选项 。
继续单击 Configure 按钮,直到没有红色的选项出现,然后单击 Generate 按钮,开始 生成 VTK 工程文件 。 这 一步完成以后, VTK 编 译文件所在的路径下可以看到如图 1 -9 所 示 的目录
结构。
9


VTK 图形图像开发进阶
面函函
i 竹 $Ohware(O.) 售 VIK • VIK·
晌鹹斤` 士 'i --二+- 勹句l .在丘 介峰- . , ·.,.今,,., r矗 ·1 ,.. __ _. `如 Tools H<lp
eI
IL-L.,-55:二- - [
图 )-9 用 CMake 配置 VTK 后自动生成的目 录结 构
接着双击图 1-9 目录下的 VTK.sln 文件,打开 VTK 工程, 如图 1 - 10 所 示 。 Visual Studio
2008 默认的编译版本是 Debug, 对于初学者来说, 最好选择该版本进行编译 ,以便调试后 续
的程序。由于在 CMake 中选择编译环境时选择的是 Visual Studio 9 2008 Win64, 所以 Visual Studio 2008 上显示的就是 x64 版本,即 64 位的 。选择 Visual Studio 2008 中的 Build一 Build Solution 选项(或者按 (F7 〉快捷键),开始编译 VTK 。根据计算机配置情况的不同 ,所 需的 编译时间也不一 样,如果计算机配置良好,图 1-10 所示的 129 个工程所需编译的时间约为半
小时 。
10
气 YTK - Microsoft Visual Studio
I ·编 · - ,4 三一-于七
印e Edit Vi= V沁sistX Project Build
3 ~J 叮吝 出 0 丛 心 ..:'.',;"'l • C" • ..J • -:+; ► Deb
...一·.
气 合甘().正
叩心`·[识爪6 ...
心玄
. .咖· ~
习 Solution VTK' (129 projects) 扣· 芯 AdjacencyMatrix
壬 忑曰匣卫正}
ri4; 芯 AmbientSpheres
]
i ' ,'Sl ArrayBasics :f:. 芯 Arraylteration
芘 忑 Arrays
它. ,歹 BalloonWidgel
:J北 芯 BandedContours
lll ·i' 芯 Cone
:;; 芯 Cone2 .一二 .C-..、3、····· --
4 :; ~`"今已...血-一-..,
郔守(·马cIh六v 0v
. 午` .一 会 ···~···········'··-··
·-··---年 , - --- ·...-.--贮` - - - - - - -·一·
OUtput
Ml S沁w output from:
=工工立=士 ” ...~、“=#__.一·-·
lt:'lCode DefinrtionWindow1习 Output
二-··., . . ..二二二二..二二"·.c·. 贮 ... .....
Updating lntelliSense,_ (2148)
. ·· ` - 
图 1-10 打开 VTK.sln 后的 Visual Studio 2008 界面
... ···
了n x


笫 1 章 VTK 概览
如果选中 BUILD_EXAMPLES 和 VTK_USE_MFC 选项,完成这 129 个工程的编译后, 会有 四个与 MFC 相关的工程出错,分别是 vtkMDI 、 vtkSDI 、 vtkDLG 和 Win32SampleMFC
四个工 程。如图 1-1 l 所示,错误的提示大致如下。
error LNK2019: unresolved external symbol "_declspec(dllimport) public: static class vtkDataSetReader • _cdecl vtkDataSetReader::New(void)"·.....
这些错误与类库的加载有关,其解决方法是:找到这四个工程所在的目录里的 CMakeLists.txt 文件(位千 VTK\Examples\GUI\Win32) ,然后在每个 CMakeLists.txt 文件里的
"TARGET_LINK_LIBRARIES(.. . )" 的最后添加 “vtkIO", 即
TARGET_LINK_LIBRARIES(vtkMDI vtkMFC vtkIO) TARGET_LINK_LIBRARIES(vtkSDI vtkMFC vtkIO) TARGET_LINK_LIBRARIES(vtkDLG vtkMFC vtkIO) TARGET_LINK_LIBRARJES(Win32SampleMFC vtkRendering vtkIO)
重 新用 CMake 配置、生成工程,再编译 VTK.sln 即可解决这几个错误。至于这么解决的
原因 , 请参考 1.3 节内容 。
名 VTK - Microsoft Visual Studio

··之- ·-_.; `...,, 午·干· ^ - ~
I 印e Edit V1ew VAsstStX Project 8ulld Debug TooIs Test Wmdow Help 3 ~ ...J 叮吝 品 tj I I, 心 心!? 了 P 了 千 了 斗 i ► Debug • x64
I -=- -- .::.. -- - - . - ' . C......匕- - ~ _.,-~夕
0 3 为 先 5,它 o . lb< .j ;
一~一,~
Sol叩on Explorer · ALL_BUILD - I>- X ,
_
凶 ___ 令一· ----___i
习 Solution VTK' (129projects) • !
,r .1l AdjacencyMatrix 电
:';·?.:::~ 上1歹
也 歹 ALL_BUILD
平还户罗9-:气Y_匕`~y.阻玩勹
..上
Ovtput Showoutput from: Build • I j i 拉 亡
. ~喊
2)- Build st江ted: Project : Un32SaaplelJfC, Configuration: Debug r64
2)L1nk1ng. . .
了 ;3 自
2>LINK :曾arn1屯 1.JK4199: /DELAYLOAD:vtkIO. dll ignored; no 1aports found froa vtkIO.dll
2)SaapleDoc. obj : error LJll(2019; unresolved external syabol •_declspec(dll1aport) public: st乍
.一
2)Sa覃pl eDoc. obj : error LffK2019: `吓esolved external syabol •_declspec(dll1aport) public: clt1--'
2)0: \VTK\VTK-5. 10-bln\bln\Debug\'1n32Saaple吓C. exe : fatal error LJll(1120: 2 叩esolved extern,
靡 ··, - - I IJ - `'”“`”千“-«,n
ation: Debug xU - - 
3?-以北扛巳 ...~-· ··-一一·一
• i____---·-------__________.一一一一·=-=二:..-==;=二二
Symbol Re幻Its
.-- --~ -·_ __.一 ··一.一一·- · ·.一
札 ~~~ -.....itJ Ln 36 Col 1 Ch 1 INS
、, ~`上玉立=土 -+__ _+-- J". 上- . 二主己
图 J - 1 I 选中 BUILD_EXAMPLES 和 VTK_USE_MFC 选项编译 VTK 的错误输出
编译完成后,对应的 Debug 目录会生成如图 1-12 所示的文件。
如果还想把 VTK 相关的头文件、动态链接库文件等提取出来,以便用 于 其他项目的 开发,可以编译 Solution 下的 “INSTALL" 工程,右击该 工 程,在弹出的快捷菜单中选
择 Project Only- Build Only INSTALL 选项, V欢i 里的所有头文件以及相关的库文件等,即会被
提取到 CM凡年_INSTALL_PREFIX 选项所指定的目录里,默认路径为 C:/Program Files/VTK。
11


VTK 图形图像开发进阶
,
勹p
1
eeaa
pp
1 t
ssS
5
』:
心心11
b
xe
.
I. l K
19
二尸
TiJ9,心.•.
T
凸 r 心 j
?
.心
J,
`
03
二
mps
mpsde:desde
三pe
88
2 1
p
b
b
eu 寸仁 了
11 x
k
.'
二
gneldb
:pd
e m。 凡`

三三
t
eletp
e e p
g

三言
ndgddnd}
Da
巨
-心
g
QVTQVTQVIQVTQVTQvtRGrrgrRGrgsGrsgr
SgSG
nrv
. bm
lo
:a;;
;响
厂
.
G, 厂
尸
图 1 - 12 VTK Debug 版本编译生成的文件
它;
由于 Windows 7 有 管 理员权限的问 题 ,如果直接双击 VTK.sln , 然 后 编 译 INSTALL 工程 , 会提示不能在 C: \Program Files\ 下创建目录等错误 , 此 时可以先关掉 VTK 工程,在桌面上单击“开始”按钮 , 在“搜索 程 序 及 文 件”文本框中输入 Visual Studio 2008, 然 后右击该程序 , 在弹出的快捷 菜 单中选择 “ 管理员权限运行”选项 , 运行 Visual Studio 2008 , 接 着 在 Visual Stud10 2008 下通过菜单打开 VTK.sln 文件,再重新 编 译 INSTALL 工程 。
至 此 , 就成功地编译 并安装好 了 VTK 。 如 果在编译 安 装 VTK 的过程中出现 什 么问题 ,
可以 在 VTK users 邮件列 表上提 问 。
1.3 创建一个简单的 VTK 程序
1.2 节中详细 演示 了如何编译安装 VTK, 那 么 如何测 试 VTK 到 底有没有正确 地 安 装?或
者 说怎么使用前面编 译 出 来 的 VTK 开发库 呢?这 就需要编 写 一 个 CMakeLists.txt 文件来配 置 新的 VTK 工程。 前面已 经使用 CMake 配置 过 VTK 工程 , 接下来先看看 CMake 的 介绍 。
1.3.1 什么是 CMake
对千使用 VTK 的开发人 员 而言 , CMake 是一个必 须了解的工具 , CMake 的产 生与发展 也与 VTK 息息相 关。 以下 一段 内 容摘 自维基 百科 , 主要是关千 CMake 的 历史 : “CMake 是为了解决美国国家医学图书馆 出 资 的 Visible Human Project 项目 下的 Insight
Segmentation and Registration Toolkit CITK) 软件的跨平台构建 的 需求而创 造 出 来 的, 其设计
受 到了 Ken Martin 开发 的 pcmaker 的影 响 。 pcmaker 当初 则 是为了 支 待 Visualization Toolkit ( VTK) 这个开源的三维 图形和视觉系统才 出 现 的 ,现在 VTK 也 采用了 CMake 。 ”
12


笫 1 章 VTK 概览
从以上关千 CMake 的介绍可以知道, CMake 其实就是 一个跨平台的工程构建工具,可以 根据不同的平台 生成与平台相关的工程配置文件,比如,若 Wmdows 平台采用 Visual Studio,
则可以生成*.dsw 、*.sln 等项目文件。利用 CMake 可以管理大型的项目, VTK 就是使用了
CMake 作为项目管理工具。同时, CMake 也简化了工程构建过程,只要给工程里的每个目录
都写 一 个 CMakeLists.txt 脚本文件,就可以通过 CMake 生成该工程的编译文件。 CMake 支持
in-place 构建(也就是生成的二进制文件与源文件在同 一个目录)和 out-of-place 构建(编译
链接生成的二进制文件和源文件分别在不同的 目录,前面介绍 VTK 编译过程时就是采用这种
构建方式)两种工程构建方式。
CMake 有自己的语言和语法,用 CMake 对工程进行管理的过程,就是编写
CMakeLists.txt 脚本文件的过程,原则上要求工程里的每一个目录都包含一个同名的文件,
而且这个脚本文件的名字只能是 CMakeLists.txt 。假如写 成 cmakelists.txt, 由于 Windows
平台不区别文件名大小写 , 因此可以通过 CMake 的配置与生成过程;但如果在别的 平台 ,
如 Linux, 用 CMake 构 建工程时就会提示找 不到 CMakeLists.txt 。所以,建议不管 在哪个
平台下 ,都使用 CMakeLists. txt 这个文件名,并注意大小写 。
它; 本书所有示例程序都是使用 CMake 进行工程的构建与管理。
1.3.2 CMakeLists.txt 脚本文件
建立 VTK 应用程序之前,需要先写 一个 CMakeLists.txt 脚本文件。 先新建 一 个文件夹。为便千本书示例程序文件的管理,在 “VTK/Examples" 目录里新建 一 个名为 “ChapOl" 的文件夹, Examples 文件夹里存放本书里提到的所有示例程序(详见随 书代码) 。 接下来的内容可 以先 一 步 一步跟着做,后面的内容会逐行代码地解释,所以暂时先 “ 知其然”,后续的内容再“知其所以然” 。
接着在新建的示例程序目录下创建一个名为 “CMakeLists.txt" 的记事本文件,输入内 容为 :
CM碑-MINIMUM_REQUlRED(VERSJON 2.8) PROJECT(ChapOI) FIND_pACKAGE(VTK REQUlRED) INCLUDE(${VTK_USE_FILE}) ADD_EXECUTABLE(1 .3_TestVTKlnstall 1.3_TestVTKinstall.cpp) TARGET_LINK_LIBRARIES(1.3_TestVTKinstall vtkRendering vtkCommon)
然后在 CMakeLists.txt 同级目录下新建一个 cpp 文件,名为 “1.3_TestVTK.Install.cpp ", 输入内容为 :
#include <vtkRenderWmdow.h> #include <vtkSmartPointer.h> int mainO {
vtkSmartPointer<vtkRenderWirulo吵renWrn= vtkSmartPointer<vtkRenderWindow>::NewQ; renWrn->RenderQ;
13


VTK 图 形图像开发进阶
std::cin.getO; return O;
打开 CMake 程序,在 CMake 的 Where is the source code 文本框中输入 CMakeLists.txt 文
件所在的路径;在 Where to build the binaries 文本框中输入编译目录的路径,如 D :\VTK\
Examples\ChapO 1\bin, 接着单击 Configure 按钮, CMake 会弹出如图 1 -13 所示的对话框 。
A Create Directory
图 J -13 CMake 询问是否创建不存在路径的对话框
单击 Yes 按钮,然后再选择准备使用的编译环境 “Visual Studio 2008 Win64 ", CMake 开
始配置工程。这个工程非常小,很快就可以配置完成 。 此时, 在 CMake 界面上会出现一些红
色的选项,如果没有选中 Advanced 视图,默认显 示出来的选项只有两项 , 即 CM心汪_
INSTALL_PREFIX 以 及 VTK_DIR, VTK_DIR 这个选项就是指向 VTK 的编译目录,准确地
说,这个路径就是 VTKConfig.cmake 文件所在的完整路径。对千 CM心汪_INSTALL_PREFIX
这个选项默认的值都是 C :\Program Files\ X X X (X X X 指的就是在 CMakeLists.txt 里的
project( X X X )命令里所指定的 工程名字)。 一般情况下,编译 完 VTK 以 后,用 CMake 配 置 VTK 的 工程时, VTK_DIR 选项的值都会自 动填充,如果 CMake 找不到,或者找 到的不是想
要的 VTK 版本(假如计算机上编译有多个版本的 VTK 时),可以通过单击 Browse Build 按钮
选择需要 的 VTK 编译路径 , 或者直接输入该路径。 设置 完 CMake 选项的 值后 , 再次单击 Configure 按钮 , 直 到没有红色的选项出现, 最后 单击 Generate 按钮 。完成以 后 打 开在 Where to build the binaries 文本框中指定的路 径 , 生成的
文件如图 I - 14 所示。
Organize • Include in library • Share with •,, 终 ·
__ _ -- ·一· - - - - -千··---·--------·- ···--.
4
Favori引 ~ ( Makefiles : CMakeCache.txt
,一
圈 Desi°~ 2d ALL_BUILD.vcproj ,~ TestVTKJnstall.vcproj
悼 Dov. ~ ChapOLsln ';] ZERO_CHECK.vcpro丿
,
扛 Rec, 了 :~1 cmake_in只all.cmake
I
,'_ J
F
图 1 - 14 用 CMake 构 建 ] .3_TestVTKinstall 工程所生成的 文件
注
它意 本书中所有程序示例都是按照以上的操作 步骤建立 工 程的, 以 后不再
赘述。
14


笫 1 章 VTK 概览
打开*. sin 文件, 再按 (F7 〉 快捷键开始编译 工程 , 完成以 后按 ( F5 〉快捷键运行,如 果
没有其他意外,会弹出如图 1 - 15 所 示的对话框。
Executable For Debug Session
Please specify the name of the executable fileto be
used for the debug session.
Executable file name:
亡厂
丐,
URL where the project can be accessed (ATL Server only):
图 J - 15 Executable For Debug Session 对话框
对于不熟悉 Visual Studio 2008 的初 学者而言 , 会 以为这是一种错误。其实这只是项目默 认的启动工程没有生成可执行文件而已。右击 Solution Explorer 里的 TestVTKinstall 工程 , 然 后选择 Set as StartUp project, 再按 ( F5 〉快捷键, 此时可能会出现如图 1 - 16 所示的错误提示 对话框 。
TestVTKinstaltexe -System Error
O) Theprogram can.tstart becausevtkRenderin9.dII ismissin9 from
..- your computer.Try rein只ailing the program to fix this problem.
二三丿
图 1 - 16 运行 1 .3_TestYTKinstall 程序出现的错误提示对话框
类似的错误对于初学者来说可能摸不着 头脑 。 其实从对话框的提示信息中可知是缺少文 件导致运行错误 。 找到提 示 中缺少的文件,然后复制到工程所在的目录下, 再运行程序就可 以了 。 也有人采用 把 VTK 的 DLL 文件复制到系统的目 录 ( C:\Windows\System32) 下的方案, 不过万- VTK 的版本变了 , 又得重新复制,而且若没有管理员权限,则不能复制 ,所以不建 议采取这种方法 。
这里介绍另 一种方法 : 右击项目 “1.3_TestVTKlnstall”, 在弹出的快捷菜单中选择 Properties 一 Configuration Properties一 Debugging 选项,找到 “ Working Directory" , 再把 D :\VTK-5.10-bin\ bin\Debug 路径放在这里 , 单击 “确 定”按钮 以后再运行程序就可以解决图 1 - 16 所示的错误。 或者在 Properties 一 Configuration Properties 一 Debugging 一 Envirorunent 里输 入 “PATH=%
PATH3⁄4;D:\VTK-5 .10-bin\bin\Debug ” (要注意把 D:\VTK-5.10-bin\bin\Debug 替换成本地计算机 上所对应 的 VTK 路径) 也 是 一样的效果。 示例 1.3_TestVTKinstall 的运行界面如图 1 - 17 所示 。靠前的是 VTK 窗口,靠后的是控制 台窗口 , 用 CMake 构建的 工程 ,默认都是带控制台窗口的 , 以便输出调试信息。 如果到 这里程序运行结果 也 与图 1 - 1 7 类似,说明 已经成功编 译了 VTK。
15


VTK 图形图像开发进阶
图 1 - 17 示例 1.3_TestVTKJnstall 的运行界面
1.3.3 CMake 的儿个常用命令
为便千描述,下面把 1.3.2 节 里 的 CMakeLists.txt 脚本代码再列出来,并标上行号:
1: CMAKE_M闪MUM_REQUlRED(VERSION 2.8)
2: PROJECT(ChapO1) 3: FIND_pACKAGE(VTK REQUJRED) 4: INCLUDE(${VTK_USE_FILE}) 5: ADD_EXECUTABLE(1.3_TestVTK.Install l.3_TestVTKlnstall.cpp) 6: TARGET_LINK_LIBRARIES(lJ_TestVTKinstaU vtk.Rendering vtkCommon)
第 1 行用到 CMake 命令 CM凡汪_M爪八们M_REQUIRED, 该命令的完整语法格式为 :
CMAKE_M时MUM_REQUlRED(VERSION
major[.minor[.patch[.tweak]]] [FATAL_ERROR])
该命令用于指定构建工程时所需的 CMake 版本要求 。第 一 个 参 数 VERSION 是必曲的关 键字 ,且为 大写(注意 : CMake 的命 令名是不区分大 小 写 的,为 了统一 描述 , 本书所有 CMake 命令都以大 写 书 写 ) 。第 二 个 参数 为指 定 CMake 的 版本号 , CMake 最新 的版本 是 3.0 .0 。第三 个参数为可选 参数,且为内 置 的 关键字 “ FATAL_ERROR” 。 如果构建工程所用 的 CMake 版 本 没有达到 要求 ,配 置过程就会 出图 1 - 18 所示 的 错误提示信息 , 终止 工 程构 建 过程 。
A. Error
{13) Error in configuration process, project fil es may be invalid
O fake Erroz at Cl,iakeLi3CS. cxc ; 1 (~ake_mni.mm_ze平凸red):
口亿Ice 2 . e. e or higher 1• required . YD,.l 83e :,nmng ver,:on -、 · 3 . 6
Confiqurino inco叩leee, errou occurred'
图 1 - 1 8 CMake 构建工程时的错误捉 不信 息
16


第 2 行 PROJECT 命 令 的 完整语法格式为:
PROJECT(projectName [CXX] [C] [Java])
笫 1 章 VTK 概览
用该命令 指定工程名称,可指定工程支持的语 言 , 支持语 言 的参数为可选。默认支持
C\C++ 。该 命令还隐含两个 CMake 变量 : < projectName>_BINARY_DIR 以及<projectName>_
SOURCE_DIR, 在这个示例中就是 ChapOI_BINARY_DIR 以及 ChapO I_SOURCE_DIR 。同时
CMake 也预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR 变量,它们的值分
别与 <projectName>_BINARY_DIR 与 <projectName>_SOURCE_DIR 一致。
为了统 一 起见,以后 直接 用 PROJECT BINARY DIR 和 PROJECT SOURCE DIR
_分 别表示工程的编译路径和源码路径 ,即 该示例里的 “D:\VTK\Examples\ChapO 1\bin "和
" D:\VTK\Examples\ChapO 1",这样即使修改了工程名称,这两个变量 的值也会相应变化 。
PROJECT 命令的第 一 个参数同样也隐含了 一 个变 量 : PROJECT_NAME, 可以通过
"${ PROJECT_NAME}" 这种 方式来引用变量 的值 。注意 : CMake 使用“${变量}”的形式来
获取变 萤 的值,换 言之,这个示例中, $ { PROJECT_NAME} 相当于工程名 “ChapOl”。
笫 3 行 FIND_PACKAGE 命令 的 完整语法格式 为:
FIND_PACKAGE(<package> [version] [EXACT] [QUIET] [[REQUIREDICOMPONENTS] [components...]] [N0_POLICY_SCOPE])
FIND_PACKAGE 命令用千搜索并加载外部工程 , 其隐含的变撮 为 <package>_FOUND, 用千标示足否搜索到所需的主程 。 参数 [REQUIRED] 表示 所要搜索的外部工程对本工程来说是 必 袖 的,如 果没有搜索到 , CMake 会终止整 个 工程构 建过程。 以 VTK 为例, FIND_PACKAGE 命令搜索的就是 VTK 的 配置文件 VTK.Config.cmake 。在 VTK 自带的示例目录里的 CMakeLists.txt 中 有以下的 CMake 脚本语句 ( 摘自 VTK-5.1 O\Examples\Tutorial\Step l\Cxx\
CMakeListx.txt ) :
FfND_PACKAGE(VTK REQUIRED) IF(NOT VTK_USE_RENDERING) MESSAGE(FATAL_ERROR "Example ${PROJECT_NAME} requires VTK_USE_RENDERING") ENDfF(NOT VTI<_USE_RENDERlNG)
以上四行脚本的作用 与第 3 行 实现 的功能 是一 样的 。关千 FIND_PACKAGE 命令中其他 参数 的 意 义可以 参考 CMake 帮助文件 ( CMake 安 装目录下的 doc 文 件夹下有相关的文档 文件) 。
第 4 行 INCLUDE 命 令 的 亢整语法为 :
INCLUDE (<fLlelmodule> (OPTIONAL] [RESULT_VARIABLE <VAR>J
17


VTK 图 形图像开发进 阶
[NO_POLICY_SCOPE])
指定载入一 个文件或者模块,如果指定的是模块,那么将在 CM凡(E_MODULE_PATH 中搜索这个模块并载入,本例中指定的是 VTK 模块 , 则会在 CM凡年_MODULE_PATH 中搜 索 VTK 模块并载入 , 变量 CM凡年_MODULE_PATH 指的是搜索 CMake 模块的目录,安装 完 CMake 以 后,在 CMake 的安装目录下( 一般是 C :\Program Files (x86)\CMake 2 .8\ ) 可以找
到 CMake 已经定 义的模块,路径为 C:\Program Files (x86)\CMake 2.8\share\cmake-2.8\ Modules, 在该目录下存在 FindVTK.cmake 文件, 其中解释了变量 VTK_USE_FILE 的 意义。
在 VTK 编 译目录 C D:NTK/VTK-5.10-bin/ ) 下的 VTKConfig .cmake 文件里可以看到变量
VTK_USE_FILE 定义为 :
# The location of the UseVTK.cm吐e ftle. SET(VTK'--USE_FILE "D:NTKNTK-5.10-bin/UseVTK.cmake")
换言之, INCLUDE (${VTK_USE_FILE} )命令就是包含 UseVTK.cmake 文件 。
第 5 行 ADD_EXECUTABLE 命 令的完整语法格式为 :
ADD-'EXECUTABLE(<name> [WlN32) [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source! source2... sourceN)
定义这个工程会生成 一 个文件名为 <name> 的可执行文件,相关的源文件通过 sourcel
source2 、 . . .、 sourceN 列出(如果工程里有多个源文件,源文件之间用 空格隔 开 ) ,如果有 多
个源文件,也可以先用 SET 命令 定义一个变量,然后再用取变量值的操作符${}获取源文件列
表 ,比如, 某工程有 source 1 .cpp 、 source2 .cpp 和 source3.cpp 三 个文件,可以写成:
SET(projectname_src source Lepp source2.cpp source3.cpp) ADD_EXECUTABLE(projectname $ {projectname_src})
与下行是等价的 :
ADD_EXECUTABLE(projectname sourcel.cpp source2.cpp source3.cpp)
第 6 行 TARGET_LINK_LIBRARIES 命令的完整语法格式为 :
TARGET_LINK_LIBRARIES(<target> [iteml [item2 [...]]] ([debugjoptimizedjgeneral] <item>]...)
指定生成可执行文件时 需要链接哪些文件 。参 数<target> 的名称必 须与第 5 行指定的 <name>一致 。 本例指定需要链接的函数库为 vtkRendering, 在写这些链接的函数库时不需要
带 ”.lib" 的 后缀。 读者可能会 问:为什么 要链接 vtkRendering.lib 这个文件呢?
18


笫 1 章 VTK 概览
1.3_TestVTK.lnstall.cpp 文件中使用了 vtk:RenderWindow 和 vtkSmartPointer 这两个类 , 查
找这两个类的头文 件所在的路径,分别为 VTK-5.10-src\Rendering 和 D:\VTK-5.10-src\
Common 。 于是可 以猜到:因为 VTK 里的所有类都是以 “vtk" 开头,所以 VTK 生成的函数
库应该 也以 “vtk" 开头,而要使用的 类 vtkRenderWindow 和 vtkSmartPointer 的头文件
vtkRenderWmdow.h 和 vtkSmartPointer.h 又分别在文件夹 Rendering 和 Common 里 ,刚好在 VTK
编译的目录里能 找到 vtkRendering.lib 和 vtkCommon.lib 这两个文件,所以是否可以断定类
vtkRenderWindow 和 vtkSmartPointer 的 接口就是分 别 定 义在 vtkRendering.lib 和 vtkCommon.lib
中的呢?最后,在 CMakeLists.txt 的 TARGET_LINK_LIBRARIES 里,要链接的函数库就是
vtkRendering 和 vtkCommon 。图 1 - 11 的错误就是通 过这种 方式解决 的 。
下面再查看 VTKConfig.cmake 文件(用记事本 打开),可以找到以下 语句 :
S E T ( V T K_ L I B R A R I E S
"vtkCommon;vtkFiltering;vtkimaging;vtkGraphics;vtkGenericFiltering;vtkIO;vtkRendering;vtkVolumeRendering;vt kHybrid;vtkWidgets;vtklnfovis;vtkGeovis;vtkViews;vtkCharts")
SET 命令是用来定义某个变 量 的,而取变 量 的值可以用符号${},那么是不是可以在
TARGET_LINK_LIBRARIES 的 最后 , 不用 一一列出所要链接的函数库,而直接引用变量值 :
${VTK_LIBRARIES} 来代替列出的 "vtkRendering vtkCommon" 呢? 答案 也是可行的 。
到此为止,读者应该掌握了 CMake 常用的 6 个命令 CM心也_M爪八叩M_REQUIRED 、
PROJECT 、 FIND_PACKAGE 、 INCLUDE 、 ADD_EXECUTABLE 和 TARGET_LINK_
LIBRARIES 的 基本用法了。这 几个命令是最常使用 的 CMake 命令 ,所以有必要 掌握。
1.3.4 一个简单的 VTK 工程
再回顾 TestVTKInstall.cpp 中的代码 ,同 样标上行号 :
I: #include <vtkRenderWindow.h> 2: #include <vtkSmartPointer.h> 3: int mainO 4: { 5: vtkSmartPointer<vtk.RenderWindow> renWin = 6: vtkSmartPointer<vtkRenderWindow>::NewO; 7: renWin->RenderO;
8:
9: std::cin.get(); 10: return O; 11 : }
第 1 、 2 行包 含头文 件,因为要用到 VTK 里 的 vtkRenderWindow 和 vtkSmartPointer 两个 类 ,所以 包含相应的头文件 。 VTK 对类的命名都是 以小 写 的 vtk 开头,每个类 的关键字首字 母大写 。
第 5 、 6 行用智 能指针定义了 一 个类型 为 vtkRenderWindow 的对 象,这是 VTK 的类实例 化对象的基本用法 。 因为 VTK 里每个类 的构造函数都 定义为保护成员 ,所以不能用以 下 的语 句来定义 一个 VTK 对象 :
19


VTK 图形图像开发进阶
vtkClassExample instance; //vtkClassExample 这个类不存在,只是说明问题而已
否则会提示如下的错误:
error C2248: vtkClassExample:: vtkC!assExample: cannot access protected member declared in class vtkCJassExample
所以,要构造 VTK 的对象可以用第 5 、 6 行的方法,或者用以下的方法:
vtkRenderWindow• rei:iWin= vtkRenderWindow::NewO;
它注 使用 New()定义变量时,要在其生命周期结束前使用 Delete() 函数释 意放内存。
第 7 行调用 vtkRenderWindow 里的方法显示并渲染 VTK 窗口。 第 9 行没 有其他特别的意义,只不过是让程序暂停下来,等待接受用户的输入,目的是
显示 VTK 窗口。如果把它注释掉, VTK 窗口会一闪而过。 这个程序非常简单,只有 一 个 VTK 窗口,别无其他 。 但它确实是一个 VTK 工程 ,至少
使用了两个 VTK 类,调用了 一个 VTK 的方法 。
1.4 本章小结
本章主要介绍了什么是 VTK; VTK 能做些什么事情;如何获取 VTK 的源码, 同时列举
了除本书以外的其他 VTK 的学习资源。 此外,为安装 VTK 做了非常充分的准备工作,了解了在编译安装 VTK 之前需要先安装哪 些软件。然后一步 一步地演示如何编译 VTK, 这个过程还是比较简单的。编译完 VTK 后,通过 一个非常简单的 VTK 小程序~来测试 VTK 是否成功安装。读者通过这 个小程序学习了 CMakeLists.txt 脚本的写法,并掌握了 6 个 CMake 命令 ,分别 是 CM心CE_ MINIMUM_REQUIRED 、 PROJECT 、 FIND_PACKAGE 、 INCLUDE 、 ADD—EXECUTABLE 和
TARGET_LINK_LIBRARIES 。
20


第 2 章 VTK 的基本概念
第 1 章 通过 一 个简单的 VTK 工程 ,详述了使用 CMake 来构建 VTK 工程的步骤。本 章继续在第 1 章 1.3_ TestVTKinstall 示 例的基础上进行扩展,实现 一 个能够交互的 VTK 应
用程序 。
2.1 一个稍微复杂的 VTK 程序
首先是写 一个 CMakeLi sts.txt 文件 。 新建一个目录,如 D:\VTK\Examples\ ,并在该目录 下新建 一 个名为 “ Chap02" 的 文件夹 , 用千存放本章中的示例程序 。 然后在该目录下新建
CMakeLists.txt 和 2 . l_RenderCylinder.cpp 文件(详见 随书代码 Examples\Chap02\2.l_Render
Cylinder.cpp) 。
示例 2.1 _ RenderCylinder 的 CMakeLists .txt 文件代码 :
CMA邸-MINIMUM_REQUIRED(VERSION 2.8) PROJECT(Chap02) FrND_PACKAGE(VTK REQUIRED) JNCLUDE($ {VTK_USE_FILE}) ADD_EXECUTABLE(2.1_RenderCyl inder 2.1_RenderCylinder.cpp) TARGET_LfNK_LIBRARIES(2. I_RenderCylinder ${VTK_LIBRARIES})
示例 2. l_RenderCy linder 的 2 . I_RenderCylinder.cpp 文件代码 :
#include <vtkSmartPointer.h> #include <vtkRenderWindow.h> #include <vtk.Renderer.h> #include <vtkRenderWmdowlnteractor.h> #include <vtklnteractorStyleTrackballCamera.h> #include <vtkCylinderSource.h> #include <vtkPolyDataMapper.h> #include <vtkActor.h>
int mainO
vtkSm江tPointer<vtkCylinderSource> cylinder=
vtkSmartPointer<vtkCylinderSource>::NewO; cylinder-> S e t H e i g h t ( 3 . 0 ) ; cylinder->SetRadius( 1.0); cylinder->SetResolution( IO );
vtkSmartPointer<vtkPolyDataMapper> cylinderMapper = vtkSmartPoin比r<vtk.Po lyDataMapper> :: NewQ;
21


VTK 图形图像开发进阶
cylinderMapper->SetlnputConnection(cylinder->GetOutputPortQ);
vtkSmartPointer<vtkActor> cylinderActor = vtkSmartPointer<vtkActor>::NewO; cylinderActor->SetMapper(cylinderMapper);
vtkSmartPointer<vtkRenderer> renderer= vtkSmartPointer<vtkRenderer>: :NewO; renderer->AddActor(cylinderActor); renderer->SetBackground(0.1, 0.2, 0.4);
vtkSmartPointer<vtkRenderWmdow> renWin = vtkSmartPointer<vtkRenderWindow>::NewQ; renWin->AddRenderer(renderer); renWin->SetSize(300, 300);
vtkSmartPointer<vtkRenderWindowlnteractor> iren = vtkSmartPointer<vtkRenderWindowlnteractor>::NewQ; iren->SetRenderWmdow(renWm);
vtkSmartPointer<vtklnteractorStyleTrackbaJICarnera> style = vtkSmartPointer<vtklnteractorStyleTrackballCamera>::NewQ;
iren->SetlnteractorStyle(style);
iren->InitializeO; iren->StartO;
return O;
与第 1 章 的步骤 一样,运行 CMake 一 Configure一 Generate 。 接着 打开 生 成的 Chap02.sln 文件,按 (F7 〉快捷键编译,按 (F5 〉快捷键调试运行(这些快捷键在 不同版本的 Visual Studio
中可能不太一样,或者通过菜单操作),程序运行结果如图 2-1 所示 。
,.“ _,....“'七...
._______飞宝飞- 7 .....~....一.............. ,
烂:二:.:==::之二::::####二:二二::::::::::::::::二::二二::::一:::~
图 2- 1 示例 2.1 的运行结 果
22


笫 2 章 VTK 的基本概念
在图 2- 1 所示的窗口中,可以使用鼠标与柱体进行交互,比如用鼠标滚轮可以对柱体放
大、缩 小;按下鼠标左键不放,然后移动鼠标,可以转动柱体;按下鼠标左键,同时按下 (Shift 〉
键,移动鼠标 ,可以 移动整个柱体等。读者 也可以 尝试一下其他的功能,比如按下 ( Ctrl 〉键
时再按鼠标左键;鼠标停留在柱体上,然后按下 (P 〉键;试着按一 下 ( E 〉 键呢?
关于交互的内容,在本书第 8 章中会进行介绍。
接下来详细解释一下示例 2 . 1 里每行代码的 含义以及所用到的 VTK 类。从包含的头文件
可以看出 , 除了 vtkSmartPointer 和 vtkRenderWindow 在第 1 章中 已 经讲过 , 其余 6 个类都是
新 加 入的。
( 1) vtkCylinderSource
该类派生自 vtkPolyDataAlgorithm 。顾名 思义, vtkCylinderSource 生成的数据类型就是
vtkPolyData , 它主要是生成 一 个中 心 在渲染场景原点的柱体 ,柱 体的长轴沿着 Y 轴,柱体的 高度 、截面半径等 都可以任意指定。
vtkCylinderSource:: SetHeight(): 设置柱体的高。
vtkCylinderSource: :SetRadius(): 设置柱体横截面的半径。
vtkCylinderSource:: SetResolution():设 置柱体横截面的等边多边形的边数。转动 一 下柱体,
然后数 一 数柱体横截面有多少条边,应该就能明白这个参数所表示的意思。
( 2) vtkPolyDataMapper
该类用于渲染多边形几何数据 ( vtkPolyData) ,派生自类 vtkMapper, 将输入的数据转换 为几何图 元(点 、线、 多边形) 进行 渲染。
vtkPolyDataMapper: :SetlnputConnection(): VTK 可视化 管线 的输入数据接口,对应的可视 化 管线 的输出数据接 口为 GetOutputPort(); VTK 5.0 之前的版本使用 Setlnput()和 GetOutput() 作为输入输出接口, VTK 5.X 版本保留了对这两个接口的支持。
(3) vtkActor
该类派生自 vtkProp 类,渲染场景中数据 的可视化表达通过 vtkProp 的 子类负责。 比如 该 示 例要 渲染 一 个柱体,柱体的数据类型是 vtkPolyData, 数据要在场 景 中渲染时,不是直接把 数据加入渲染场 景 ,而是以 vtkProp 的形式存在于渲染场景中。 三维空间中渲染对象最常用的 vtkProp 子类有 vtkActor (表达场景中的几何数据)和 vtkVolume (表达场景中的体数据) ; 二 维 空 间中的数据则 是用 vtkActor2D 表达 : vtkProp 子类负责确定渲染场景中对象的位置 、 大 小和方向 等信息 ; Prop 依赖于两个对象: 一个是 Mapper ( vtkMapper) 对象 , 负责存放数据 和 渲染信息 ; 另 一 个是 属性 ( vtkProperty ) 对象 , 负 责控 制颜色、不透明度等 参 数 。另 外, vtk.Actor 中还可以设 置纹理 ( vtkTexture) 对象 , 用于纹理贴图。
VTK 定义了大量 的 Prop 类 ,如 vtklmageActor ( 负责图像显示)和 vtkPieChartActor (用 于创建数组数据的饼图可视化表达形式)。其中有些 Prop 内 部直接包括了控制显示的 参数和 待渲染数据的索引 ,因此 并不需要额外的 Property 和 Mapper 对象,例如 vtk.AxisActor 。 vtkActor 的 子类 vtkFollower 可以 自动更新方向信息使其始终面向 一个特定的相机,这样无论 怎样旋转该对象 都 是可 见的,例如 三 维场景中的广告板或者文本。 vtkActor 的 子类 vtkLODActor 可以自动改变 自身 的几何表达形式来实现所 需 的交互帧率。 vtkAssembly 建立了 各个 Actor 的层次结 构以便在整个 结构平移、旋转或缩放等变换时能够更合理地进行控制 。 vtkActor: :SetMapper() : 该方法用千设置生成几何图元的 Mapper, 即连接一个 Actor 到可视
23


VTK 图形图像开发进阶
化管线的末端 (Mapper 是可视化管线的末端)。关千可视化管线的内容可参考 2.4.2 节的内 容 。
(4) vtkRenderWindow
将操作系统与 VTK 渲染引擎连接到 一起。不同平台下的 vtkRenderWindow 子类负 责管理
本地计算机系统中窗口创建和渲染过程。当使用 VTK 开发应用程序时,只 需要使用平台无关
的 vtkRendererWindow 类,运行时,系统会自动替换为平台相关的 vtkRendererWindow 子类 。
比如, Windows 下运行上述的 VTK 程序, 实际创建的是 vtkWin320penGLRenderWindow
(vtkRenderWindow 的子类)对象。 vtkRenderWindow 中包含了 vtkRenderer 集合、渲染参数,
如立体显示 (Stereo) 、反走样、运动模糊 (Motion Blur) 和 焦点深度 ( Focal Depth ) 等。
vtkRenderWindow: :Adc!Renderer():该方法用千加入 vtkRenderer 对象。 vtkRenderWindow:: SetSize():该方法是从 vtkRenderWindow 的 父类 vtkWindow 继承过来 的,用于设置窗口的大小,以像素为单位。
( 5) vtkRenderer
负责管理场景的渲染过程。组成场景的对象包括 Prop, 照相机 (vtkCamera) 和光照
( vtk.Light ) 都被整合到一个 vtkRenderer 对 象中 。一 个 vtkRenderWindow 中可以有多个
vtkRenderer 对象,而这些 vtkRenderer 可以 渲染在窗口不同的矩形区域中(即视口)或者覆盖
整个窗口区域。 vtkRenderer: :AddActor():该方法用千将 vtkProp 类型的对象添加到渲染场景中 。
vtkRenderer::SetBackground():该方法是从 vtkRenderer 的父类 vtkViewport 继承的 , 用于
设置渲染场景的背景颜色,用 R、 G、 B 的格式设置,三个分量的取值为 0.0 ~ 1.0 。 ( 0.0, 0.0,
0.0) 为 黑色 ,( 1.0, 1.0, 1.0) 为白色 。除了可以设置单一的背景颜色之外,还可以设置渐变的 背景颜色, vtkViewport:: SetBackground2()用 千设置渐变的另外一种颜色,但是要使背景颜色 渐变生效或者关闭,必须调用以下的方法 。 vtkViewport: :SetGradientBackground(bool) :参数为 0 时,关闭,反之,打开 。 vtkViewport: :GradientBackgroundOn():该方法用于打开背景颜色渐变效果,相 当于调用
方法 SetGradientBackground(1) 。 vtkViewport: :GradientBackgroundOffi():该方法用千关闭背景颜色渐变效果 。相当于调用
方法 SetGradientBackground(O) 。
C6) vtkRenderWindowlnteractor
提供平台独立的响应鼠标、键盘和时钟事件的交互机制,通过 VTK 的观察者/命令模式 (请参考本书第 8 章内容)将监听到的特定平台的鼠标、键盘和时钟事件交由 vtklnteractorObserver 或 其子类 ,如 vtklnteractorStyle 进行处理 。 vtklnteractorStyle 等监听这些
消息并进行处理以完成旋转、拉伸和缩放等运动控制。 vtkRenderWindowInteractor 会自动建立 一 个默认的 3D 场 景交互器样式 ( Interactor Style ) : vtklnteractorStyleSwitch, 当然也可以选择其他交互器样式或者创建自己的交互器样式,如本
例中使用的 vtklnteractorStyleTrackballCamera 。 vtkRenderWindowInteractor:: SetRenderWindow(): 该方法用千设置渲染窗口,消息是通过 渲染窗口捕获到的 ,所以必 须给交互器对象设置渲染窗口。
vtkRenderWindowInteractor::SetlnteractorStyle(): 该方法用千定义交互器样式,默认的交
互器样式为 vtk:InteractorStyleSwitch 。
24


笫 2 章 VTK 的基本概念
vtkRenderWindowInteractor::Initialize():该方法表示为 处理窗口事件做准备,交互器工作
之前必须先调用 这个方法进行初始化 。
vtkRenderWindowInteractor: :Start(): 该方法表示 开始进入事件响应循环,交互器处千等待
状态,等待用户交互事件的发生。进入事件 响应循环之前必 须先调用 Initialize()方法 。
( 7 ) vtk.InteractorStyleTrackballCamera
交互器样式的 一 种。该样式下,用户通过控制相机对物体作旋转 、 放大 、 缩小等操作。
打个比方,在照相时如果要想物体拍起来显得大 一 些 , 可以采取两种做法:第 一种做法是相
机不动,让要拍的物体靠近相机 ; 第二种做法是物体不动 ,让相机靠近物体。第二种做法就
是 vtk.InteractorStyIeTrackballCamera 的风格。其父类为 vtk.InteractorStyle, 除了 vtk.Interactor
StyleTrackball Camera 之外, VTK 还定义了其他多种交互器样式,如 vtk.InteractorStylelmage ,
主要用于显示 二 维图像时的交互 。
以上内容针对示例 2 .1 所用的类逐个进行解释,并稍微做了扩展,可能显得比较凌乱,
不够系统、全面。下面通过一 个类比,从宏观角度重新审视该示例,它对理解示例 2.1 的代码
将会有所帮助。
可以将以上示例看作 一 个舞台剧演出。观看舞台剧时 ,观众坐在台下 ,展现在观众面前 的是 一 个舞台,舞台上有各式的灯光和各样的演员。演员出场时肯定是会先化妆,观众有时 还会与台上的演员有 一 定的互动。
整个剧院就好 比 VTK 程序的 渲染窗口 ( vtkRenderWindow ) ; 舞台就相当于渲染场景
( vtkRenderer ) ; 而那些演员就是程序中的 Actor, 台上演员与台下观众的互动可以看作与应 用程序的交互 C vtkRenderWindowlnteractor) ; 演员与观众的互动方式有很多种,现场的观众 可以 直接上台跟演员 们 握手拥 抱, 电视机前的可以发 短信 , 计算机前的可以微博关注等,这 就好比程序中 的交互器样式 ( vtk.InteractorSty le ) ; 对于舞台上的演员,观众都可以 一一分辨 出来,不会弄混,是因为他们穿着打扮 、 容貌都不一样 , 这就相当千程序中 vtk.Actor 的不同 属性 C vtkProperty ) ; 台下观众的眼睛可以看作 vtkCamera, 前排的观众 因为离得近 , 在观看 台上演员时会觉得他 们比 较高大,而后排的观众因 为离得远 ,所以那 些演员看起来就会显得 小 些 ,每位观众 看到的东西在 他/她的世界里都是唯 一 的,所以渲染场景 Renderer 里的 vtkCamera 对象也是只有一 个;舞台上的灯光可以有多个,所以渲染场 景里的 vtkLight 也存在
多个 。 可以参考图 2-2 以加 深理解。
.
,! 盲 , 广户~ 一..一—.
"...已
/
vtkRenderer 实例
- vtkRenderWi ndow 实例
vtkProperty 定义了该Actor的 属性 ,如 颜色
t
vtkActor实例 A
vtkMapper定义了 Actor的几何特征
每个 vtkRender巴 定义有一个vtkCamera 每个渲染场景定义有 一 个或多个光源vtkLight
图 2-2 VTK 渲染场景以及各主要对象
25


VTK 图 形图像开发进阶
2.2 三维场景的基本要素
2.2.1 灯光
剧场 里有各式各样的灯光, 三 维渲染场景中也 一样 ,可以 有多个灯光存在 。 灯光和相机
是三 维渲染场 景 必备的要素,如 果没有 指 定(像示例 2.1 _RenderCylinder 没有给 Renderer 指
定相机和光照) , vtkRenderer 会自动创建默认的灯光和相机 。 VTK 里用类 vtkLight 来表示渲
染场景中的灯光。与现实 中的灯光类似, VTK 中的 vtkLight 实例也可以打开、关闭 , 设置灯
光的 颜色 ,照射位置(焦点),灯光所在的位置、强度等 。
vtkLight 可以分为位 置 灯光 ( Positional Light , 也叫聚光灯 ) 和方向灯光 ( D订ection Light ) 。
位置 灯光 是 光源位置在渲染 场 景 中的 某个位置 ,可 以 指定灯光的 衰减值、锥角等 ; 方向灯光
即光源位置在无穷远 , 可以认为光线是平行的,比如自然界中的太阳光 。 光源的位置和焦点
的连线 定 义光线的 方向 ,默认的 vtkLight 为 方向 灯光 。
vtkLight 的常用方法如下。
SetColor(): 设置灯光的颜色,以 RGB 的形式指定 颜色 。
SetPosition(): 设灯光照位置。 SetFocalPointO: 设 置灯光焦点。
Setlntensity():设 置灯光的强度 。
SetSwitch()/SwitchOn()/SwitchOffl(): 打开或关闭对应的灯光 。 vtkLight 里的方法 SetSwitch() / GetSwitch() / SwitchOn() / SwitchOffi()控制灯光的开或者
关。不难发现,在 VTK 中属性的设 置 都 是采取 这 一类方法 , 以 vtkLight 为例 , SwitchOn()与
SetSwitch(l)实现的效果是一样的 , 而 SwitchOffi()则 与 SetSwitch(O) 一样 , GetSwitch()则是用千 获取 vtkLight 对象关闭或打开这个属性的值。如果某个 类有提供 Set X XX ()方法 , 一般会提
供相应的 Get X XX ()方法来 获取该属性值。再 如, vtkLight 还提供 SetPositional() / Get
Positional() / PositionalOn() / Positiona10ff1()这一类方法用来控制位置灯光的开关 。 下述代码(详见随书代码 Examples\Chap02\2.2_RenderCylinder-Lights.cpp ) 说明了灯光
vtkLight 的使用 方法 ,程序执行结 果如图 2-3 所 示。
26
vtk:SmartPointer<vtk:Light> myLight = vtk:SmartPointer<vtk:Light>::NewQ; myLight->SetColor(O,1,0); myLight->SetPosition(O,O,I); myLight->SetFocalPoint(renderer->GetActiveCameraQ->GetFocalPointQ); renderer->AddLight(myLight);
vtk:SmartPointer<vtk:Light> myLight2 = vtk:SmartPointer<vtk:Light>::NewQ; myLight2- >SetColor(O,O,I); myLight2- >SetPosition(O,O,- l); myLight2- >SetFocalPoint(renderer->GetActiveCameraQ->GetFocalPointQ); renderer->AddLight(myLight2);


笫 2 章 VTK 的基本概念
该示例定 义了两个 vtk.Light 对象, 一个为绿色光,位置在(0,0,1) ,焦点对着相机的焦点 ;
另 一个为蓝色光 ,位置在 (0,0,-1) ,焦点也是对着相机的焦点,最后调用 vtkRenderer 的 方法
AddLight()将两个灯光对象加入到渲染场景中。因为 Renderer 里可以有多个灯光,所以 VTK
提供的接口是 AddLight()而不是 SetLight() 。 -


一
. .
$
·
I
.
吟
i
nd"

仆 l

-
生 R.竺 “
一
lf..•
甘
likH
书卜
E
廿打书
khk
.i ...,',';;','
-,_~- I
I
图 2-3 示例 2. I _RenderCylinder 中加入绿色和蓝色光照的效果
2.2.2 相机
观众的眼睛好 比 三维渲染场 景 中的相机,在 VTK 中用 vtkCamera 类来表示。 vtkCamera 负 责 把三 维场 景投影到二维平面,如屏幕。相机投影示意图如图 2-4 所示。从图 2-4 可以看 出与相机投影相关的要素主要有如下几个。 l ) 相机位狸 。 相机所处的位置,用 vtkCamera:: SetPosition()方法设 置。 2) 相机焦点 。 用 vtkCamera::SetFocusPoint()方法设置,默认的焦点位置在世界坐标系的 原点 。
3) 朝上方向 。 朝上方向即哪个方向为相机朝上的方向。就好比直立看东西,方向为头朝 上 ,看到的东西也是直立的 ,如果倒 立看某个东西 ,这时方向为头朝下, 看到的东西就是倒 立 的 。 相机位詈、相机焦点和朝上方向 三个因素确定了相机的实际方向,即确 定相机的视图 。 4 ) 投影方向 。 相机位置到相机焦点的向撮方向即为投影方向。 5 ) 投影方法 。 该要素用于确定 Actor 是如何映射到像平面的。 vtkCamera 定义了两种投 影方法: 一种是正交投影 (Orthographic Projection) ,也叫 平行投影 ( Parallel Projection ) , 即 进入相机的光线与投影方向是平行的 : 另 一种是透视投影 (Perspective Projection ) ,即所有光 线相交于 一 点。该投影方法最符合人类眼 睛对千景物所产生的近大远小的视觉习惯 。 6 ) 视角。透视投影时需要指定相机的视角 (View Angle) ,默认的视角大小 为 3 0 ° , 可 以用 vtkCamera::SetViewAngle()方法设置。 7) 前后裁剪平面。裁剪平面与 投影方向相交, 一般与投影方向也是垂直的。裁剪平面主 要用 千评估 Actor 与相机距离的远近,只 有在前后裁剪平面之间的 Actor 才是可见的。裁剪平 面的位置可以用 vtkCamera::SetClippingRangeQ方法设置。
27


VTK 图形图像开发进阶
前裁剪乎面 朝上方向
三
. 佳. ... 占、、
相机位茬
图 2-4 相机 vtkCamera 投影示意图
下述代码演示了如何生成和设置相机:
vtkSmartPointer<vtkCamera> myCamera = vtk.SmartPointer<vtkCamera>: :NewO; myCamera->SetClippingRange(0.0475, 2.3786); myCamera->SetFocalPoint(0.0573, -0.2134, -0.0523); myCamera->SetPosition(0.3245, -0. 1139, -0.2932); myCamera->SetViewUp(-0.2234, 0.9983, 0.0345); renderer->SetActiveCamera(myCamera);
后栽诃平面
投影方 向
SetClippingRange() / SetFoca!Point() / SetPosition()分 别 用千设置相机的前后裁剪平面、焦
点 和 位置。 ComputeViewPlaneNormal()方法是根据设置的相机位置、焦点等信息,重新计算 视平面 ( View Plane) 的法向 量。 一 般该法向 晕与 视平面 是垂直 的,如 果不垂直, Actor 等看 起来会有 一 些特殊 的 效果, 如 错切 。 SetViewUp() 方法用于设置相机朝上方向。最后用 vtkRenderer::SetActiveCamera()方法把相机设 置 到 渲染场景中 。 vtkCamera 除了提供设置与相机投影因素 相 关 的 方法之外,还提供了 大豐的控制相 机运动的 方法, 如 DollyO 、 Roll() 、 Azimuth() 、 Yaw() 、 Elevation() 、 Pitch() 和 Zoom() 。 这些方法具体是怎 么运动以及相对哪个位置或者方向运动,请参考图 2-5 或者关千类 vtkCamera 的文档说明 。
图 2-5 相机运动方 向 示意 图
28


笫 2 章 VTK 的基本概念
图 2-5 是脚本文件 camera.tel (即 VTK 源码目录 VTK\Hybrid\Testing\Tcl\camera.tel ) 和
camera2.tcl (见随书代码 Examples\Chap02\camera2.tcl ) 的执行结果。第 1 章中曾提过 Tel 脚
本文件,当时建议读者安装 vtk-5.1 O.O-win32-x86.exe 这个程序。如果已经安装了这个程序,
现在就可以执行 camera.tel 和 camera2.tcl, 生成如图 2-5 所示的效果。
有两种方法可以运行 Tel 脚本。第 一 种是安装完 vtk-5.10.0-win32-x86 .exe (或其他版本)
应用程序后,从 Windows 的开始菜单里打开 VTK 程序,会出现如图 2-6 所示的界面 。
图 2-6 vtk-5 . 10.0-win32-x86 程序运行界面
接着 ,在"%”后面输入 “source X X X X.tel", 然后按 <Enter 〉键 ,即可执行对应的 Tel 脚 本文件 。 XX XX .tel 如果输入的是绝对路径 , 要注意路径里的斜杠是 “I", 而不是“\", 如果路径带有空格,需要用英文的双引号把整个路径括起来,比如 ,
source "D:/Program FilesNTK/camera.tcl" (按( Enter〉键 ,即 可运行 tel 脚本)
第二 种方法是安装完 vtk-5. IO.O-win32-x86.exe 程序后,把 vtk.exe 所在的路径加入到 Path 环境变蜇 , 然后打开 CMD 窗口,在 CMD 窗口里 直接输入 “ vtk X X X X.tel " , 按( Enter 〉 键,同样可以执行 Te l 脚本文件 。
2.2.3 颜色
颜色是 Actor 重要的属性之一 。 VTK 采用 RGB 和 HSV 两种颜色系统来描述颜色。 RGB 颜色系统由 三 个颜色分 昼 : 红色 ( R ) 、 绿色 ( G ) 和蓝色 ( B ) 的组合表示,在 VTK 里,这 三 个分量的取值范围都是 0~ 1, (0, 0, 0) 表示黑色 ,( 1, 1, 1) 表示白色。
vtk.Property::SetColor(r, g, b)采用的就是 RGB 颜色系统设置颜色属性值。
HSV 颜色系统同样也是由 三个分蓝来决定颜色 , 它们分别是 : 色相 ( Hue ) , 表示颜色 的基本属性,就是通常所说的颜色名称 , 如红色、黄色等;饱和度 ( Saturation ) ,是指颜色 的纯度,其值越高则越纯 ; 值 ( Value , 也就是强度 Intensity 或者亮度 Bright) , 值为 0 通常 表示的是黑色,值为 1 表示的是最亮的颜色。这 三 个分量的取值范围 0 ~1 。类 vtkLookupTable 提供了 HS V 颜色系统设置的方法 。
29


VTK 图形图像开发进阶
表 2- 1 列出了常用颜色 RGB 和 HSV 值的对照。
表 2-1 常用颜色 RGB 和 HSV 值的对照
颜 色 RGB HSY
黑 色(Black) 0,0,0 * ' * , 。
白色(White) I, I, I • , 0, I
红 色(Red) I , 0, 0 0, I, I
绿色(Green) 0, I, 0 1/3, I, I
蓝色(Blue) 0, 0, I 2/3, I, I
黄色(Yellow) I,! , 0 1/6, I. I
蓝绿色(Cyan) 0, I , I 1/2, I, I
品红色(Magenta) I , 0, I 516, I, I
天蓝色(Sky blue) 1/2, 1/2, 1 2/3, 1/2, I
与颜色设置相关的 VfK 类除了 vtkProperty 和 vtkLookupTable 之外 , 还有 vtkColorTransfer
Function, vtkLookupTable 和 vtkColorTransferFunctio.n 都派生自 vtk.ScalarsT oColors 。
它;
VTK 中并不以 类 vtkColor 未负责颜色的 一些 实现 工作,不要想当然地以 为颜色就是用 vtkColor 实现相关的细节 。 vtkColor 在 VTK 里只是存储颜 色的 一个模板类,派生于 vtkTuple 。颜 色 是物体的 一种属性,所以是 由 类 vtkProperty 未控制 。
2.2.4 纹理映射
纹理映射是创建逼真效果的强大的图形工具,其原理是渲染时把二 维的图像“贴”到物
体的表面上,根据 二 维图像渲染出丰富多彩的效果,所以也叫纹理贴图 。 纹理映射需要 三 个 要素 : 待贴图的表面、纹理映射以及纹理坐标。其中纹理映射在 VTK 中就是 vtklmageData
的数据集,而纹理坐标则用千控制纹理图在表面的位置。 下面通过 一 个简单的示例学习在 VTK 里如何进行纹理贴图(详见随书代码 Examples\
Chap02\2.2_ TextureExample.cpp ) 。
30
vtkSmartPointer< vtkJPEGReader > reader = vtkSmartPointer< vtkJPEGReader >: :NewO; reader->SetFileName("..\\texture.jpg");
vtkSmartPointer< vtkTexture > texture= vtkSmartPointer< vtkTexture >::NewO; texture->SetlnputConnection(reader->GetOutputPortO); texture->InterpolateOnO;
vtk:SmartPointer< vtk:PlaneSource > plane= vtk:SmartPointer< vtk:PlaneSource >::NewO; vtk:SmartPointer< vtkPolyDataMapper > mapper=


笫 2 章 VTK 的基本概念
vtkSmartPointer< vtkPolyDataMapper >::NewO; mapper->SetlnputConnection(plane->GetOutputPortO );
vtkSmartPointer< vtkActor > actor = vtkSmartPointer< vtkActor >::NewO; actor->SetMapper(mapper); actor->SetTexture(texture );
这个示例 先读入一 幅 JPEG 的二维纹理图 ; 然后定义一个 纹理类 vtkTexture 对象,接着把 读入的 JPEG 图像输入到 vtkTexture 里 , 作为它即将“贴”到平面上的一个纹理图;再定义 一 个 vtkPlaneSource 对象 , 类 vtkPlaneSource 可以生成一个平面,也就是纹理图要“贴“图的地 方。简而言之 , 在做纹理贴 图 时,先 要有 东 西 可以“ 贴 ” , 也 就是要准备 一 幅二维的纹理图 ;
然后再确定 这幅纹理 图要“贴 ” 到哪里。本书第 7 章会再深入阐述有关纹理映射的内容。程 序运行结果如图 2-7 所示。 a

图 2-7 纹理贴图示例
2.3
2.3.1
坐标系统及空间变换
坐标系统
计算机图形学里常用 的坐标系统主要有 4 种 , 分别是 Model 坐标系统、 World 坐标系统 、 View 坐标系统和 Display 坐标系统(这些名词在不同的书里的中文表述均有所差 别,所以本 书将直接使用英 文名词表示),此外还有两种表示坐标点的方式 : 以屏幕像素值为单位和归 一 化坐标值( 各坐标轴取值 范围 为 [- l,l] )。它们之间的关系 如 图 2-8 所示 。 Model 坐标 系统是定义模型时所采用的坐标系统 , 通常是局部的笛卡儿坐标系 。 World 坐标系统是放置 Actor 的三维空间坐标系 , Actor ( vtkActor 类) 其 中的 一个功能就 是负责将模型 从 Model 坐标系统变换到 World 坐标系统 。 每一个模型可以定义自己的 Model 坐标系统 , 但 World 坐标系只有一个 , 每一个 Actor 必须通过放缩、旋转、平移等操作将 Model
31


VTK 图形图像开发进阶
坐标系变换到 World 坐标系。 World 坐标系同时也是相机和灯光所 在的坐标系统 。
模型 A Model 坐标系统
勹 Mode~::系统
Display坐标系统
m
/帣
、$`
World 坐标系统 光照定位 相机定位 Actor定位
相机的变换
View 坐标系统
三
Wew 到 DlS play 的变换 与视口、窗口大小及窗口位狸等因素有关
图 2-8 Model 、 World 、 View 和 Display 坐标系统
View 坐标系统表示 的 是相 机所 看见的坐标系统 。 X 、 Y 、 Z 轴 取值为 [- I, I], X 、 Y 值表 示像平面上 的位 置 , Z 值表示到相 机的距离。相机负 责将 World 坐标系变换到 View 坐标系 。
Display 坐标系统与 View 坐标系统类似,但 是各坐标轴的取值不是 [- 1, I] , 而是使用屏幕 像素值。屏幕上显示的不同窗口的大小会影响 View 坐标系的坐标值 [-1, 1] 到 Display 坐标系 的映射 。 可以把不同的 渲染场景放在同一个窗口进行显示,例如,在 一 个窗口里,分为左右
两个渲染场景,这左右的渲染场景(vtkRenderer)就是不同的视口 (Viewport) 。 示例 2.3_ Viewport
实现将一 个 窗口分为 4 个视口,用 vtkRenderer: :SetViewport()来设置视口的范围(取值为 [O, l]):
renderer1->SetViewport(O.O,O.0,0.5,0. S); renderer2- >SetViewport(O.S,0.0, 1.0,0.5); renderer3->SetViewport(0.0,0.5,0.S, 1.0); renderer4->SetViewport(0.5,0.S, 1.0,1.0);
示例 程序 2.3_Viewport 的执行 结果如图 2-9 所示。 在 VTK 里, Model 坐标系统用 得 比较少 , 其他三 种坐标系统经常使用 。它 们 之 间的 变换 则是由 类 vtkCoordinate 进行 管理的。根据坐标值的单位、取值范围等不同 ,可 以将坐标系统
细分为如下几类。
32
• DISPLAY - X 、 Y 轴的坐标取值为 渲染窗口的像素值。坐标原点位于渲染窗口的 左下角 ,这个对 于 VTK 里的所有二维坐标系统都是 一样的,且 VTK 里的坐标系统都
是采用右手坐标系。 • NORMALIZED DISPLAY - X 、 Y 轴坐标取值范围为 [O, l] ,跟 DISPLAY 一样,
也 是定 义在渲染窗口里的。


笫 2 章 VTK 的基本概念
..一. .. 一
石七r; 扯玉兰
---------------------· - ------·一勹
I
诊
图 2-9 2.3_Viewport 执行结果
• VIEWPORT - X 、 Y 的 坐标值定 义在视口或者渲染器 ( Renderer) 里。
• NORMALIZED VIEWPORT-X 、 Y 坐标值定义在视口 或渲染器里 ,取值范围为 [O, 1] 。
• VIEW - X 、 Y 、 Z 坐标值定义在 相机所在的坐标系统里 ,取值范围 为 [-1, l], Z
值 表 示深度 信 息 。
• WORLD - X 、 Y 、 Z 坐标值定义在世界坐标系统 ,参见图 2-8 。
• USERDEFINED 用 户 自定义坐标系统。
vtkCoordinate 可以用来表示坐标系统,其内部提供了函数接口来定义坐标系统:
SetCoordinateSystemToDisplay O SetCoordinateSystemToNormalizedDisplay O SetCoordinateSystemToViewport O
SetCoordinateSystemToNonnalizedViewport O SetCoordinateSystemToView O SetCoordinateSystemToWorld O
另外,该类还 实 现这些坐标系统之间的转换 ,例如 下述代码实现了归 一 化窗口坐标与窗 口坐标之间的转换 :
vtkSmartPointer<vtkCoordinate> coordinate = vtkSmartPointer<vtkCoordinate>: :NewQ; coordinate->SetCoordinateSystemToNonnalizedDisplayQ; coordinate->SetValue(.5,.5,0);
int• val;
val =coordinate->GetComputedDisplayValue(renderer);
这 里 先调用了 SetCoordinateSystemToNormalizedDisplayO设置坐标 系统为 归 一化 窗口坐 标 , 并设宵坐标值为 ( 0 . 5, 0.5, 0) ,即 屏幕 的中心;然后通过函数 GetComputedDisplayValueO 实 现衙口坐标的转换 。 该类中坐标系统转换函数如下 :
GetComputedWorldValueO
GetComputedViewportValueO
33


VTK 图 形图像开发进阶
GetCornputedDisplayValueO GetCornputedLocalDisplayValueO GetComputedDoubleViewportValue() GetComputedDoubleDisplayValueO
GetComputedUserDefmedValueO
2.3.2 空间变换
在 三 维空间里定义的 三 维模型 , 最后显示时都是投影到二维平面 ,比如 在屏幕上显示 。
三 维到 二 维的投影包括透视投影 ( Perspective Projection ) 和正交投影 ( Orthogonal Projection ) 。
正交投影也叫平行投影 。 不管是透视投影还是正交投影 , 变换的基本元素都是三 维坐标点,在计算机图形学里,
三 维坐标点通常用齐次坐标来表示 , 例如, 三 维 空 间里有一个坐标点 (x, y, z) ,用齐次坐标表
示 为 (xh, Yh, Zh, Wh) , 其中
xi
x= — !.... y= Yh _ zh
—- z =2.. (2-1) wh wil wh
若 wh =O , 则表示无穷远的点 。 利用齐次坐标 , 可以将空间变换用 4 X 4 的 矩阵来表示 。 例如,平移、旋转、缩放等仿射
变换都可以用矩阵相乘的形式表示:
34
· 平移 。 设笛卡儿坐标系下的点 (x,y,z) ,求经平移向董(tx, ty占)变换后的结果 (x',y',z' ) 。
首先,构造平移矩阵 TT
TT =|
得平移结果为
1 0 0 !x
0 1 0 ty
0 0 1 t,
000 1
,I
X 1 0 0 fx \ (X
y
I 。 1 0 ty z,
w,
如果用笛卡儿坐标系表达为
00I
000
x '=x+tx
y '= y +tx
z'=z +t,
w'=l
· 缩放。同理,也可以构造出缩放矩阵 Ts
Sr O O 0 0 s O0
Ts =| y
0 0 s, 0
0 0 0I
tz
I
YI
z
l
( 2-2 )
(2-3)
(2-4 )
(2-5)


笫 2 章 VTK 的基本概念
其 中 , Sx 、 Sy、义 分别 为 X 、 Y 、 Z 轴的缩放 因子。
· 旋转。设绕 X 、 Y 、 Z 轴旋转角度分别为 a.,/J , y , 则旋转矩阵分别 为
。 。。
。 cos a -sma 。
互= 1 。 sma cos a 。
。。 。
cos/J 。 sin/3 。
。 1。 。
TR~==I-sin/3 。 cos/J 。
。 。。
cosy - smy 。 。
| sm y cos y 。 。 I
TR: = 。 ( 2-6 )
。 1。
。 。 。1
VTK 里与空 间变换相关的类有 vtkTransforrn2D, vtkTransfonn , vtk.PerspectiveTransfonn ,
vtkGenera!Transfonn, vtkTransformFilter, vtkMatrix4 X 4 等。例如下面代码实现了 vtkActor 对象 的 空 间变换 :
vtkSmartPointer<vtkTransform> transform = vtkSmartPointer<vtk:Transform>::NewO; transform->PostMultiplyO; transform->RotateZ(40); transform- >Translate( I0,0,0) ; cylinderActor->SetUserTransform(transfonn);
先 定 义了 vtkTransform 对象,并设置使用右乘计算变换矩阵 。 RotateZ()设置绕 Z 轴旋转 40 ° ' 并使用 Translate()设 置平移 大 小 为 C 10,0,0 ) , 最后 通过 vtkActor: :SetUserTransfonn() 方法设置用户定 义的 变换矩阵 , 实现模型 的 空 间 变换 。
2.4 VTK 管线
2.4.1 VTK 渲染引党
回顾 2.1 节 的示例 2. 1 _RenderCylinder, 在该示例及后续 的 扩展 内 容中 , 可 以 找到 以 下的 类:
vtkProp; vtkAbstractMapper; vtkProperty; vtkCamera;
.
35


VTK 图形图像开发进阶
vtkLight;
vtkRenderer; vtkRenderWmdow; vtkRenderWmdowinteractor;
vtkTransform;
vtkLookupTable;
可以发现这些类都是与数据显 示 或 渲染相关的。用计算 机 图形学的专业词汇来说,就是
它们构成了 VTK 的 渲染引擎 ( Rendering Engine ) 。渲染引擎主要负责数据的可视化表达,是
VTK 里的两个 重要概念之 一 ,而 另一个 重要概念就是可视化管线 ( Visualization Pipeline ) 。
可视化管线是指用千获取或创建数据、处理 数据以及把数据写入文件或者把数据传递给
渲染引擎进行显示,这样的 一 种 结构在 VTK 里 就称为可视化 管线。数据对象 ( Data Object ) 、
处理对象 ( Process Object ) 和数据流方向 ( Direction of Data Flow ) 是可视化管线的 三 个基本
要素。每个 VTK 程序都会有 可视化管 线存在,比如示例 2. 1 _ RenderCylinder, 其可视化管线
可以简单地表示成如图 2- 10 所 示 的连接关系。
vtk C'ylinclerSourcc
讥k Pol>Data~ lapper
vtk Actor
vtk Renderer
vlkRenderWindow
渲染引茅
图 2- 10 示例 2. 1 _RenderCylinder 的可视化 管 线
示例 2 . 1 _ RenderCylinder 的 可视化管线非常简单 , 先是 创 建 一个柱体数据,接着经 Mapper
后生 成的图 元直接送入渲染引擎渲染 ,创 建的数据没有经过任何处理 。 再看 一个稍微复杂的可视化 管线。在该示例中 , 先读入 一 个后 缀为 vtk 的文 件 ( head.vtk ), 然后用移动立方体法 (vtkMarchingCubes) 提取 等值面 , 最 后 把等值面数据 经 Mapper 送 往渲 染引擎进行显 示(运行结果如图 2- 11 所示,右边是其可视化管线),示例代码如下(代码详
见随书代码 Exmaples/Chap02/2.4_ vtkPipelineDemo):
#include <vtkSmartPointer.h> #include <vtkStructuredPointsReader.h>
#include <vtkRenderer.h> #include <vtkRenderWmdow.h> #include <vtkRenderWmdowlnteractor.h> #include <vtkMarchingCubes.h> #include <vtkPolyDataMapper.h> #inelude <vtlcActor.h>
.
36


int main(int argc, char *argv□)
{
//读入 Structured_points 类型 的 vtk 文件。
vtkSmartPointer<vtkStructuredPointsReader> reader= vtkSmartPointer<vtkStructuredPointsReader>::NewQ; reader->SetFileName("../head.vtk");
//用移 动 立方 体 法提取 等 值面
vtkSmartPointer<vtkMarchingCubes> marchingCubes = vtkSmartPointer<vtkMarchingCubes>::NewO;
marchingCubes->SetlnputConnection(reader->GetOutputPortO); marchingCubes-> SetValue(0,500);
II将生成的等值面数据进行 Mapper
vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::NewQ; mapper-> SetlnputConnection(marchingCubes->GetOutputPortQ);
II把 Mapper 的输出 作为 渲染引紫的输入
vtkSmartPointer<vtk.Actor> actor= vtkSmartPointer<vtk.Actor> ::NewQ; actor-> SetMapper(mapper);
vtkSmartPointer<vtkRenderWindow> renWm = vtkSmartPointe r<vtkRenderWindow>: :NewQ; vtkSmartPointer<vtkRenderer> renderer =
vtkSmartPointer<vtkRenderer>::NewO;
vtkSmartPointer<vtkRenderWindowlnteractor> interactor =
vtkSmartPointer<vtkRenderWindowlnteractor> ::NewO;
ren Win-> AddRenderer(renderer) ; interactor-> SetRenderWindow(renWin); renderer->AddActor(actor);
renderer->RenderO; .
interactor-> InitializeQ;
interactor-> StartQ;
return O;
2.4.2 VTK 可视化管线
笫 2 章 VTK 的基本概念
比较图 2- 10 和 图 2- 11 的可视化 管线 结 构,可以看 出 图 2- 11 多 了 一个 vtk.MarchingCubes 用千 处理读入的数据。 VTK 中 把与类似 vtkMarchingCubes 对数据做处理的类称为 Filter。综
37


VTK 图形图 像 开发进阶
合图 2- 10 和 图 2-11, 可以抽 象出更 一 般的 VTK 可视化管线结构,如图 2- 12 所 示。
厂'----------—-___
1 • •, I
vtk S1ruc1 ured Po ints Readc r
咄 M archingC ubes
vtk Po lyDataMap pe r
vtkActo r
vtk Renderer
渲
染引笠
vtkRenderW,ndow
' ==二====二二=~立了二==二===========二二-~
图 2- 1 I 示例 2.4_vtkPipelineDemo 运行结果及其可视化 管线
厂--- ,
I
Data Object I
`— - - - - - . . . J
多个徐人 的 Fi lter
/
厂一一----一~ 厂----
j Data Object I j Data Object I
&—- - - .J "—- - -.J
厂----- ,
I
Data Object I
·一_____ J
厂三三三- (',如 I'祚
图 2-12 VTK 可视化管线
Source 是指用千创建数据(如 vtkCylinderSource ) 或者读取数据(如 vtkBMPReader 、 vtkStructuredPointsReader 等)类的统称, 即 VTK 的 数据源。 Source 输出的数据作为 Filter 的 输入,经 Filter 处理以后(可以经多个 Filter 处理),生成新的数据。 Filter 的输出可以直接写 入文件,或者经 Mapper 变换后传入渲染引擎进行渲染、显示,结束可视化管线 。 图 2-12 所 示的箭头方向即为 V兀且彗女据流流动的方 向 。可视化管线的 三 要素分别是数据对象、处理对 象和数据流方向, Source 、 Filter 和 Mapper 一起构成了处理对象,它们的区别是 基 于数据流 的初始化、维持和终止。根据数据的生成方式, Source 可以分为程序源对象 (Procedural, 如
vtkCylinderSource, 通过程序代码生成相关的数据)和读取源对象 ( Reader, 如 vtkBMPReader,
从外 部文件中导入数据)。 关千 Source 、 Filter 和 Mapper 的 区 别,可以简 单地通过图 2- 13 所示的示意图进行表示。 Source 没有输入 ,但至少有 一 个输出; Filter 可以有一个或多个输入,产生 一 个或多个输出; Mapper 接受一 个或多个输入,但没有输出,写文件的 Writer (如 vtkBMPWriter) 可以 看作 Mapper , 负责把数据写入文件或者流 ( Stream) 中, 因此 , Mapper 是可视化 管线的终点,同 时也是可视化管线和渲染引擎(有时也称之为图形管线)的桥梁。
38


笫 2 章 VTK 的基本概念
无输入 > l 输入 > 1 输入
三二二
;;;, 1 输出 ;;,c l 输出 无输出
图 2- 13 Source 、 Filter 和 Mapper 的区别
l. 可视化管线的连接
由示例 2.4_vtkPipelineDemo 可知,可视化 管线里 各个模块的连接是通过接口
SetlnputConnection()和 GetOutputPort()来完成 的 。 VTK 5.0 版本之前,可视化管线之间的连接
使用 Setlnput()和 GetOutput(), VTK 5.0 版本的可视化管线使用 SetlnputConnection() 和
GetOutputPort()连接 , 同时也保留了对旧版本的支持。本书的示例使用 VTK 5 . 10.1 官方 Release 版本,可视化管线采用新的结构连接,即 :
marchingCubes->SetlnputConnection(reader->GetOutputPortQ);
上行代码将 reader 的输出端口与 marchingCubes 的输入端口建立连接。 vtkMarchingCubes 作为 Filter 只接受 一 个输入, Filter 概括起来有以下三种类型(见图 2- 14 ) : 单个输入 , 产生 单个输出 ; 多个输入, 产 生单个输出,但输出的数据可有多种用途 , 比如 , 读 入数据 后,可 以对其作等值面提取,另外还可以针对读入的数据生成轮廓线 ( Outline ) ; 单个输入 , 产生 多 个输出 。
单输入 多 愉人 单输入
勹二,三]勹:f三三}
图 2- 14 不同的 Filter 类型
使用 SetlnputConnection()和 GetOutputPort()连接可视化 管 线时 , 还要求连接的两部分 之间的数据类型必须 一致 。 由于管线是运行 时才执行的,如 果连接 的两 部分类型不匹配 , 程 序运行 时就会报错。比如 , vtkMarchingCubes 要求输入的是 vtklmageData 类型的数据 ,如 果 给它输入的是 vtkPolyData 类型 的, 程序运行 时就会报如下的错误 :
ERROR: In ..\..\VTK-5.10\Filtering\vtkDemandDrivenPipeline.cxx, line 827 · vtkStreamingDemandDrivenPipeline (OOOOOOOOOOBAAB90): Input for connection index Oon input port index O for algorithm vtkMarchingCubes(OOOOOOOOOOBA9590) is of type vtkPolyData, but a vtklmageData is required.
2 .可 视化 管线 的执行
可视化 管线连接完成后 ,必须有一种机制来控制 管 线的执行 。 有时 ,对某一部分数据做 了改变 , 只希望 改变的这部分数据在可视化 管线里做更 新 , 而不要影响其他没做改变的数据 。
39


VTK 图形图像开发进阶
如图 2-15 所示,假如 Filter D 的输入发生了变化, E 和 F 是依赖 于 D 的输入的,所 以虚线框
内的部分是 需要重新 执行的 管线,而 C 和 G 是另外 一 个分支, D 输入的改变不影响 C 和 G,
所以,为了节省运行时间, C 和 G 是不需要重新执行的。毕竟对千三 维的应用程序来说,处
理的数据量 一 般都是比较大的,如果真能这样做,有利于提高程序的运行效 率。
D做了改变
I
! ""[勹!
L - - - - - - - - -- l
图 2 - 15 可视化管线部分执行示 意 图
VTK 采用 一 种叫作“惰性赋值” (Lazy Evaluation) 的 方案来控 制 管线的执行,惰性赋
值是指根据每个对象的内部修改时间来决定什么时候执行管线,只有当用户或者程序发出“请 求数据“时,管线才会被执行。 vtkObject 类里有一 个重要的成员变量 MTirne, 管线里的每个 从 vtkObject 派 生 的类的对象都会跟踪自己的内部修改时间, 当遇到 “ 请求数据 “时, 该对象
会比较这个修改时间,如果发现修改时间发生了改变,对象就会执行 。 换 言之, VTK 是采用
命令驱动 (Demand Driven) 的方法来控制 管线的 执行,这种方法 的好处 是 , 当对数据对象作
了更改时,不必 立 即做计 算,只有当发出请求 时才开始处理,这样能 最 小化计 算所需的时间,
以便更流畅地与数据进行 交互。
比如(详见随书代码 Examples/Chap02/2.4_vtk.PipelineExecute.cpp ) :
vtkSmartPointer<vtkBMPReader> reader= vtkSmartPointer<vtkBMPReader>::NewO; reader->SetFileName(argv[l ]);
vtkimageData* imageData = reader->GetOutputO;
int extent[6); imageData->GetWholeExtent(extent); std::cout<<"Extent of image: "<<extent[O]<<"" <<extent[l)<<" "<<extent[2]<<" "<<extent[3]<<"" <<extent[4]<<" "<<extent[5]<<" "<<std::endl;
该例先读入 一 幅 BMP 图像,然后把 reader 的输出值赋给 imageData, 接着需要获取读入
图像的大小,调用 vtklmageData: :GetWholeExtent()方法后,输出为 “Extent of image: 0 -1 0 -1 0 -1" 。该 结果显然是错误的,所读图像实际大小为 300 X 246 像素,这就是因为没有“请求数 据“ (RequestData())。只有在 reader->GetOutput()之前,调用 reader->Update(),才会迫使管 线的执行,即 reader 从磁盘中读取数据,然后才可获得 imageData 的正确信息。 通常,程序不用显式地调用 UpdateO 函数,因为 在渲染引擎的最后,当调用 RenderO 函 数 时, Actor 就会 收到 渲染请求 ,接着 Actor 会请求 Mapper 给它发送数据 ,而 Mapper 又会请求
40


笫 2 章 VTK 的基本概念
上一 层的 Filter 的数据, Filter 最后请求 Source 给它数据,于是,整条 管线就被执行。除非像
以上代码所列 , 读入数据以后 ,中间 需要输出某些信息 , 在得到这些信息之前,就应该显式
地调用 Update() 函数。 管 线的执行过程大致如图 2-16 所示 。
Update( )执行的方向 (Upstream)
可视化管线的数据流方向
图 2- 16 可视化管线数据流及其执行方向示意图
2.5 VTK 智能指针
2.5.1 引用计数
如果很 多对象有相同的值, 在程序里 没有必要将这个值存储多次 。更好的办法是让所有 的对象共 享这 个值 。这 么做不但节省内存,而且可以使程序运行得更快,因为不需要构造和 析构这个值的副本 。 引用计数就是这样 一个技巧,它允许多个有相同值的对象共享这个值。 引用计数是个简单的垃圾回收体系 , 只要其他对象引用某对象(记为对象 O) , 对象 0 就会 增 加 一个引用计数, 当最后 引用对象 0 的对象移除, O 对象就会自动析构。 VTK 里使用引用 计数的好处是,可以实现数据之间的共享而不用复制,从而达到节省内存的目的。
读者可以参考 一 个简单的示例 2. 5 ReferenceCounting (详 见 随书 代 码 Examples/
Chap02/2.5_ ReferenceCounting.cpp):
int main(int argc, char *argv□) {
vtkSmartPointer<vtkBMPReader> reader = vtkSmartPointer<vtkBMPReader>::NewQ; reader->SetFileName("../vtk-logo.bmp"); reader->UpdateQ;
std::cout<<"Reference Count ofreader->GetOutput(Before Assignment) = " <<reader->GetOutputQ->GetReferenceCountQ<<std::endI;
vtkSmartPointer<vtklmageData> image] = reader->GetOutputQ; std::cout<<"Reference Count ofreader->GetOutput (Assign to image!) = " <<reader->GetOutput(}->GetReferenceCountQ<<std::end1; std::cout<<"Reference Count of 血agel = " <<image1->GetReferenceCount(}<<std::endl;
vtkSmartPointer<vtkimageData> image2 = reader->GetOutputO; std::cout<<"Reference Count ofreader->GetOutput (Assign to image2) =" <<reader->GetOutputQ->GetReferenceCountQ<<std::endI;
41


VTK 图形图像开发进阶
}
std::cout<<"Reference Count ofimage2 =" <<image2- >GetReferenceCountO<<std::endl;
return O;
程序运行结果如图 2- 17 所 示 。
面 C:如心叩\system32\crnd,0
二:efo: ::9a:::
图 2- 17 2.5_ReferenceCount 运行结 果
该例先用 vtkBMPReader 读入一 幅 BMP 图像,在赋值之前输出了 reader->GetOutput()的
引用计数值,其值为 1 (使用方法 New()创建对象以后,初始的引用计数值就 等千 1) ;然后
创建了 一个 vtklmageData 类型的对象 imagel, 并把 reader 的输出赋给了 imagel, 这时 imagel
就指向了 reader 的输出,即 reader 的输出多了 一 个引用,这时输出的 reader->GetOutput()和
imagel 的引用计数都为 2; 接 着 又创建一 个类型同样为 vtklmageData 的对象 image2, 同样把
reader 的输出赋值给 image2, 这时, image2 也指向 reader 的输出,亦即 reader 的输出 又多 了
一 个引用,所以输出的 reader->GetOutput()和 image2 的引用计数值 变 成了 3 。 imagel 和
image2 的数据结构可以简单地描述为如图 2-18 所示的关系 。
ReferenceCount
(3 ) reader->GetOutput()
图 2-18 image I, image2, reader->GetOutputO及引用计数之间的 结 构 关 系
一 旦某个对象的引用计数等千 O, 就表明没有别的对象再引用它,它的使命也就 宣告 完 成了,程序就会自动析构这个对象 。 在 2.5_ReferenceCounting 示例中看不到引用计数减少的
相关代码,这是因为使用了智能指针 vtkSmartPointer 。
2.5.2 智能指针
智能指针会自动管理引用计数的增加与减少,若检测到某对 象 的引用计数值减少为 O,
则会自动释放该对象的资源,从而达到自动 管 理内存的目的 。 前述内容已经介绍过, VTK 中创建一 个对象可以用两种 方法 : 一 种 是使用 vtkObjectBase 里的静态成员变 量 New(),用 Delete()方法析构;另 一 种就 是示 例中使用 多 次的 智 能指针
vtkSmartPointer<T> 。
42


笫 2 章 VTK 的基本概念
对于第 一种方法,用 NewO创建的对象,程序最后必须调用 Delete()方法使引用计数减 l,
而且由千 vtkObjectBase 及其子类的构造函数都是声明为受保护的,这意味着它们不能在栈区
(栈和堆的区别 :栈 区上的内存是由编译器自 动分配与释放的,堆区 上的 内存则是由程序员分
配和手动释放的。)上分配内存,比如 :
vtkBMPReader* reader= vtkBMPReader::NewQ; //创建 vtkBMPReader 对象
reader->DeleteO; /程序最后要调用 DeleteO, 这里并没有直接析构对象,而是使引用计数值减 l
使用 NewO创建的对象,如果没有用 DeleteQ方法删除,程序有可能会出现内存泄漏,即 用户负责对象内存的管理。
若使用智能指针创建对象,则无需手动调用 Delete()方法减少引用计数,因为引用计数的
增加与减少都是由智能指针自动完成的。使用智能指针时,首先要包含智能指针的头文件
vtkSmartPointer.h 。 vtkSmartPointer 是 一个模板类,所需的模板参数就是待创建的对象的类名, 如:
vtkSmartPointer < vtklmageData > image= vtkSmartPointer< vtklmageData >::NewO;
注意上面 一行代码等号右边写法,不能写为 :
vtkSmart.Pointer< vtklmageData >image= vtklmageData::NewO;
也就是说,不能把对象的原始指针赋给智能指针。上行代码编译时可以通过,但程序退 出时会有 内存泄涌,如图 2- 19 所 示,因为智能指针无法自动释放该对象的内存。
“红沁四Lealcsha$如“!”“心1 o." 、dlDan· 心 1 insunce$tIIla0心 Oa”."廿ointOata. 心 1 如ance still around. 01ss 飞晌f"matlon. mlImti111CestiIl arounc1 O巫飞灿f"mationlnt勺«如ntdVa心.心 l instance 如1 around.
Oa巧飞灿form,tlonln1勺心Va压飞心 l iRm心 stiltarOt.叩. °”$.WeO忒I嘈 凶 l Instance stilt eround. CIa$$ V心i函at.勹as 1 1叩nee stilt Mound,
二
图 2- 19 将对象的原始指针赋予智能指针会引起内存泄涌
如果没有给对象分配内存 , 仍然可以使用智能指针,比如 :
或者:
vtkSmartPointer<vtk.BMPRcader> reader = vtk.SmartPointer<vtk.BMPReader>::NewO; vtklmageDa记 imageData = reader->GetOutputO;
vtlcSmartPointer< vtklmageDa伐 > imageData = reader->GetOutputQ;
43


VTK 图形图像开发进阶
第一种情 况, 当 reader 超出 其 作 用 域 时 , 数据即 会被 删 除 ; 第 二 种情况 , 使用了智能指
针,所以 数据的引用计数 会自 动加 1 , 除非 reader 和 imageData 都超出它们的作用域,数据 才
会 被删除 。
智 能指针类型 同样 也 可 以作为 函数 的返 回 值 。正 确 的写法类似:
vtkSmartPointer<vtklmageData> MyFunctionQ {
}
vtkSmartPointer<vtklmageData> myObject =
vtkSmartPointer<vtklmageData>::NewO;
return myObject;
调用时则 是 :
vtkSmartPointer<vtk.ImageData> mylmageData = MyFunctionO;
函数 MyFunction()的 返回值是通过复 制的 方式,将数据赋予调用的变量 ,因此该数据的
引 用 计 数保待不变 ,而 且函数 MyFunction 里 的 myObject 对象也不会删除 。
下面 的 函数形式和 函数调用是错误 的, 应当引起注意 :
vtklmageData * MyFunctionO {
vtkSmartPointer< vtklmageData > myObject = vtkSmartPointer< vtklmageData > ::NewQ;
return myObject;
vtklmageData * mylmageData = MyFunctionO;
在函数 MyFunction() 里定 义的 是智能指针类型 的, 最后返回时转换成原始指针类型 , 当 函数调用结束时 , 智能指针的引用计数会减为 0, 即函数 MyFunction 里的 myObject 对象 会 被 删 除 , 也就是 说, MyFunction()返回的是悬 空 指针 , 这时再赋予 myImageData 变量就会出错 。 智能指针类型 也 可 以作 为类的成员变量 , 而且会使得类在析构时 更 加 容易 ,不用人为 去
做任何释放 内 存 的 事情 , 只要 把这些工作都交给智能指针来完成即可,例如 :
. class MyClass
{
vtk:SmartPointer<vtk:FloatArray> Distances;
};
然后在类 的 构造函数里进行初始 化:
MyClass: :MyClassO
{
Distances = vtkSmartPointer<vtkfloatArray>::NewO;
}
在类 的析构函数里不用调用 Delete()删 除任何 东西。
44


笫 2 章 VTK 的基本概念
但是智能指针有 一个让人困惑的地方,比如当创建一 个 智能指针类型 的对象,然后改变
它 的指向,这时引用计数就会 出错,例如:
vtkSmartPointer<vtk.ImageData> imageData = vtkSmartPointer<vtk.ImageData>::NewQ; imageData = reader->GetOutputO;
上面两行代码里,先创建一 个 血ageData , 并给它分配好 了内存,接着又把 imageData 指向 reader
的输出,而不是 一直指向所创建的内存 。 对千这种情况,只需简单地调用:
vtk.ImageData* imageData = reader->GetOutputQ;
这里没有必要使用智能指针,因为没有创建任何新的对象。
综上所述 ,可以 看出 ,引用计数和 智 能指针是息息相关的,它们 主 要都是用于内存管理。 使用智能指针可以免去很多手动删除变械的烦恼,所以本书从 一 开始都使用智能指针来 创建
VTK 对象 。 如果想了解更 多关千 引用计 数 和智能指针的内容,可以 参考 C++经 典著作《 More
Effective C++》。
2.5.3 运行时类型识别
在 C廿里 , 对象类型是通过 typeid (祔要包含头文件#include <type_info> )获取的 ; VTK
里在 vtkObjectBase 定 义 了获取对象类型的方法-GetClassName()lO IsA() 。 GetClassName() 返回的是该对象类名的字符串 C VTK 用 类名来 识别各个对 象) ,如:
vtk:SmartPointer<vtkBMPReader> reader = vtk:SmartPointer<vtkBMPReader>::NewQ; const char* type = reader->GetClassNameQ; II返回 “vtkBMPReader" 字符串
IsA()方法用于 测试某个对象是否为指定 字符串 的类型或其子类类型,比如 :
if(reader->IsA("vtklmageReader")) {. .....}; /I 这里 JsAO会返 回真。
类 比 C++里 的 操作 RTTJ ( Real-time type information) 操作符 , 除了 typeid 之外 ,还有 dynamic_cast, 主要用于基类向子类 的 类型 转换,称为向下转型 。 VTK 里同 样提供了类似的 方法 ,也 就是 vtkObject 里定义的 SafeDownCast(), 它是 vtkObject 里的静态 成员函数 , 意味 着它是屈于类 ,而不是属于对象 的 , 即可以用 vtkObject::SafeDownCast()直接调用 ,比如:
vtkSmartPointer<vtklmageReader> readerBase = vtkSmartPointer<vtklmageReader>::NewQ; vtkBMPReader* bmpReader = vtkBMPReader::SafeDownCast(readerBase);
与 dynamic_cast 类似, SafeDownCast 也是运行 时才转换 的, 这种转换只有当 bmpReader 的 类型确 实是 readerBase 的 派生类时才有效 , 否 则返回 空指针。 除了运行时类型识别, vtkObjectBase 还提供了用于调试的状态输出接口 PrintQ, 其调用 内 部 PrintSelfl() 、 PrintHeader() 、 PrintTrailer()等 函数实现 。 在调试 VTK 程序 时,如果 需要输 出某个对象 的状态信息时, 一般都是调用 Print() 函数,如 :
bmpReader->Print(std::cout);
45


VTK 图形图像开发进阶
2.6 本章小结
本章在第 1 章示例程序的基础上做了扩展 ,引入 了 VTK 的 一些基本概念,包括 Mapper 、
Actor、 RenderWindow 、 Renderer 和 RenderWindowlnteractor 等 。 紧接着介绍了计算机图形学
三维渲染的儿个基本概念 光照、相机和纹理映射等 。本章的第 3 节简单介绍了 VTK 的坐
标系统及其坐标变换 。 “ VTK 管线”和 “ VTK 智能指针”两节向读者阐释了学习和使用 VTK
时需要深入理解的概念,其中 VTK 可视化管线贯穿所有 VTK 应用程序,而 理解与掌握 VTK 智能指针的使用有利千写出更加高效的 VTK 应用程序 。 学习本章时,读者需要有 一 些基本的计算机图 形学的知识储备,因为 VTK 的 一 个主
要应用方向就是计算机图形学领域。同时,建议读者在学习本 章 内容的同时 复习 一 下 C++
基 础知识 。
46


绾 3 章 VTK 基本数据结构
第 2 章介绍了 VTK 的 一个重要概念 可视化管线,讲解了 VTK 数据的流动过程。 这就好比做 一 道菜,在做每 一 道菜之前 , 首先要掌握这道菜的做法 ,什么时候放盐什么时 候放酱油等调料,除了需要弄清楚做每 一 道菜 的流 程 ,还 需要了解所做 的 每一道菜 的原料, 只有掌握做菜的流程并了解原料的特点,最后做出来的菜才可口美味。如果说 VTK 可视 化管线是完成 VTK 应用程序这道菜的基本步骤 ,那么 VTK 的数据结构就是做每 一 道菜的 基本原料。针对 可视化领域的特点, VTK 定义了种类丰富的数据结构,这 一 章将重点 介 绍 VTK 的基本数据结构,了解这些数据结构,有助千读者写出更有针对性的 、更 高效 的
可视化应用程序。
3.1 可视化数据的基本特点
要实现数据可视化, 有必要了解可视化的数据特点。归纳 起来,可视化数据具有如下
特点。
(1) 离散性
为了让计算机能够获取、处理和分析数据,必须对无限、连续的空间体进行采样,生成 有限的采样数据点,这些数据 以 离散点 的形式存储,采样的过程是一个离散化的过程。 由 于可视 化数据的离散性特点,在某些离散点上有精确的值存在,但点与点之间的
值则是不可知的 , 要得到采样点之 外的 其 他点的值,只有通过插值 (Interpolation) 的方
法获取。常用的插值方法是线性插值,要得到更精 确的数值可以采用非线性插值,如 B
样条插值方法 。
( 2) 数据 具有规 则或不规则的 结构(结 构化与非结构化)
可视化 数据可以分为规则 ( Regular ) 和不规则 ( Irregular ) 或者说结构 化 ( Structured )
和非结构化 ( Unstructured) 。 规则结构数据点之间有固定的关联关系,可以通过这些关联确
定每个点的坐标,不规则结构数据之间没有固定的关联关系。
对于规则结构的数据,存储时不必存储所有数据点,只需存储起始点、相邻两点之间的
间隔以及点的总数就可以保存完整的数据信息。对千不规则结构的数据 , 虽然不可以像规 则 结构的数据那样存储,但它 也 有自身的优势, 即 在数据变化频繁的区域可以密集表示 ,而数 据变化不频繁的区域则稀疏表示 。 规则结构的数据可以在存储及计算时占优势,不规 则结构 的数据虽然在存储和计算时不能像规则结构那样高效 , 但它在数据表达方面相对而言更加自
由、细致、灵活 。
(3) 数据 具有维度
可视化数据的第三个特点是拓扑维度 (Topological Dimension ) 。可视化数据具有零维 、 一 维、 二 维、 三 维等任意维度,例如 , 零维数据表现 为 点 , 一 维数据表现为曲线, 二 维数据 表现 为曲面, 三 维数据表现为体等。数据的维度决定了数据可视 化的 方法,例 如,对 于 二 维
47


VTK 图形图像开发进阶
数据,可以将其存储到 一 个矩阵,然 后再采用针 对 二 维数据的可视化方法进行可视化 (如等
高图)。
3.2 数据对象和数据集
3.2.1 vtkDataObject
在 VTK 中 ,数据 一 般以数据对象 ( Data Object, 类 vtkDataObject ) 的形式表现,这是
VTK 里可视化数据最常用的表达形式。数据对象是数据的集合,数据对象表现的数据是可以
被可视化管线处理的数据,只有当数据对象被组织成 一 种结构后,才能被 VTK 提供的可视化 算法所处理。 图 3- 1 是 vtkDataObject 类的继承图, VTK 里的所有数据结构形式都 是从这个类派生出来
的,但在实际的 VTK 应用程序中,没有直接使用 vtkDataObject 来实例化数据对象,而是根
据具体的可视化数据选用其具体的子类实现可视化的 。
,,ikOpenQubeElectronicData vtk AbstractElectronic压ta vtk Programm 北 leElectron icData
vtkAnnotation Layers ,1k Hierarchical BoxDataSet
vtkCompositeDataSet vtk MultiBlock DataSet
,,ik MultiPieceDataSet
vtk TemporalDaiaSet
vtkGcner icDataSet
vtk lmagcStencilData
vtk BridgeDataSet vtk PiccewiseFunct1on
vtk DirectedG raph
vtkUndir 如 edGraph
图 3 - 1 vtkDataObject 类 的继承图
3.2.2 vtkDataSet
将数据对象组织成一种结构并且赋予 相应的属性值,就 形 成了数据集 ( Dataset ) 。 VTK
48


笫 3 章 VTK 基本数据结构
里 与数据集对应 的 类是 vtkDataSet, 该类从 vtkDataObject 直接派生 o vtkDataSet 由两个部 分 组成 , 即组织结 构 ( Organizing Structure ) 以及与组织结构相关联的属性数据 (Attribute Data ) ,图 3 -2 描述了 vtkDataSet 各结 构的详细构成 。 vtkDataSet 是 一个抽象基类,结构的
实 现及 表 达由其具体的子类来完 成 。 vtkDataSet 的 组织结 构由 拓 扑 结 构 ( Topology) 和几何结构 ( Geometry) 两部分组成。拓
扑 结构描述了对象的构成形式, 几 何结 构 描述 了 对象的 空 间位置关系 。 换言之,点数据 ( Point
Data ) 所定义 的 一 系 列 坐标 点 构成了 vtkDataSet 数据集 的几何结构;点数据的连接形成单元
数据 ( Cell Data ) ,由单元数据形 成 了数据集的 拓扑结构。
比如,想要在屏幕上显 示一个三 角形 , 首 先必 须定 义三角形三个点的坐标(即 Point Data,
记 三 个点为 Pl 、 P2 和 P3 ) , 然后将这三个 点 按照 一 定的顺序连接起来 (Pl-P2-P3, 或者是
P3 -P2-Pl 的顺序 ),这三个点定义了数据集 的几何 结 构,它们的连接就构成了数据集的拓扑
结 构, 亦 即 点 数据定义了数据 集 的 几何结构, 单元数据 定 义数据 集 的拓扑结构,要形成完整
的 数据 集 ,必 须 有几何和拓扑两种结构 。
组织结构 O rganizing Structure
二 拓扑 Topology
几何 G eometr y
屈性 数据 Attribute Data
三
点数据 : 单元 数据
标 鱼 : 向县:法向 昼 : 张批 : 纹理坐 标
图 3-2 vtkDataSet 的结构 组成
拓扑 结 构 具有儿何变换不变性 。 例 如, 说 一 个 多 边形是三 角形 ,即指其 拓扑结构,而给
定 的 每 个 点 的 坐标 ,则为 其 几何 结 构 。 几何 结 构 是 一种 空 间描述,与空间变换有紧密联系,
常 见的 变换 有旋 转 、 平移和放缩 。 属性数据是对拓 扑 结 构和几何结构信 息的补充,属性数据 可 以 是 某 个 空 间点 的 温度值 ,也 可 以 是某 个单元 的质 量等。 接下来通过示例 看看怎么把几 何结构和拓扑 结构加入到数据集 中去 。首先看一 下 只有儿 何 结 构没有拓 扑 结 构的 vtkDataSet (详 见随书代码 Examples/Chap03/3.2_ TrianglePoints.cpp) 。
int main(int argc, char *argv(])
{』
//创建点数据
vtkSmartPointer<vtkPoints> points = vtkSmartPointer<咄oints>::New(); points->InsertNextPoint (1.0, 0.0, 0.0); points->lnsertNextPoint (0.0, 0.0, 0.0); points->InsertNextPoint (0.0, 1.0, 0.0);
//创建 vtk:PolyData 类型的数据, vtkPolyData 派生 自 vtkPou:itSet //vtkPointSet 是 vtkDataSet 的子类 ,即 vtkPolyData. 是一种数据集
vtkSmartPointer<vtkPolyData> polydata =vtkSmart:Pointer<vtkPolyData>::N叩O;
//将创建 的 点数据加 入到 vtkPolyData 数据里 polydata->SetPoints ( points);
49


VTK 图形图像开发进阶
II将 vtkPolyData 类型的数据写 入到 一个 vtk 文件, 保存位置是工程当前目录
vtkSmartPointer< vtkPolyDataWriter > writer= vtkSmartPointer< vtkPolyDataWriter >::NewO; writer->SetFileName("triangle.vtk"); writer->Setlnput(polydata); writer->WriteQ;
return O;
3.2_TrianglePoints 示例中 ,先创 建了一个点数据(vtkPoints) ,里面含有三个点;紧接着创
建了 一个类型为 vtkPolyData 的数据, vtkPolyData 派生自 类 vtkPointSet, 而 vtkPointSet 又派
生自 vtkDataSet, 所以说 vtkPolyData 是 一 种具体的数据集;然后将创建的点数据加入数据集,
千是点数据就定义了该数据集的几何结构 ; 最后 把 vtkPolyData 的数据用 类 vtkPolyDataWriter
写入 triangle.vtk 文件,保存路径 是工程的当前目录。
可以利用 ParaView 软件 ( http://www.paraview.org ) 打开示例中保存的 triangle.vtk 文件。
使用 ParaView 软件打开该文件以 后,在渲染窗口中看不到任何东西 。 这是因为在数据集
vtkPolyData 的实例里,只定义了数据的几何结构 , 没有定义拓扑结构。如果想看看生成的
triangle.vtk 数据是怎样一种形式 , 可以调用 ParaView 的菜单 Filters- Common-Glyph (在点
数据的空间位置生成符号),可以看到在三 角形的 三 个顶点位置生成了 三 个同向的箭头(见图
3-3 ) , 也就说明了 示例中生成的 文件 triangle.vtk 里面确实存在数据 ,只不 过因为少了拓扑结
构,导致它 无法正常显示而已。
图 3-3 示例 3.2_TrianglePoints 生成的数据在 ParaView 软件经 Glyph 处理后 的 结 果
接下来在示例 3.2_TrianglePoints 的 基 础上 给数据 集 定义拓扑 结 构(详见随书代码
Examples/Chap03/3.2_TriangleVertices.cpp ) 。
int main(int argc, char •argv□)
50


{
//创建点的坐标
double X[3] = {l.O, 0.0, 0.0}; double Y[3] = {0.0, 0.0, 1.0}; double Z[3] = {0.0, 0.0, 0.0};
笫 3 章 VTK 基本数据结构
//创建点数据以及在每个点坐标上加入顶点(Vertex)类型的单元 1
vtk.SmartPointer<vtkPoints> points= vtkSmartPointer<vtkPoints>::New();
vtk.SmartPointer<vtkCellArray> vertices= vtkSmartPointer<vtkCellArray>::NewO;
for (unsigned inti= O; i < 3; ++i)
{
//定义用于存储点索引的中间变量, vtkld'fype 就相当千 int、 long 等类型 vtkldType pid[l];
II把每个点坐标加入 vtkPoints 中, InsertNextPointO返回加入的点的索引号 /吓面 需 要使用这个索引号来创建顶点类型的单元
pid[O] = points->lnsertNextPoint (X[i], Y[i], Z[i]);
//在每个坐标 点上分别创建一个顶点,顶点是单元(Cell)里的 一种类型 vertices->InsertNextCell (I,pid);
II创建 vtkPolyData 对象
vtk:SmartPointer<vtkPolyData> polydata = vtkSmartPointer<vtkPolyData>::NewO;
II指定数据集 的几何结构(由 points 指定)以及数据集的拓扑结构(由 vertices 指定) polydata->SetPoints (points); polydata->SetVerts (vertices);
//将生成的数据集写 到 TriangleVerts.vtk 文件里,保存在工程当前目录下
vtkSmartPointer<vtkPolyDataWriter> writer= vtkSmartPointer<vtkPolyDataWriter>::NewQ; writer->SetFileName ("TriangleVerts.vtk"); writer->Setlnput (polydata); writer->WriteQ;
return O;
3.2_TriangleVertices 示例中 实 例化了 一个 vtkCellArray 对象 , 其中点 数据 定义数据集 的几 何结构 , 单元数据定 义数据集 的拓扑 结构 。 由此可知, vtkCellArray 类型 的对象 vertices 就是 用 来指定数据集 polydata 的拓扑 结构,而 polydata 的 几何结构则 是 由 points 来定义的 。 3.2_Triang leVertices 示 例中定 义的数 据集 的 拓 扑 结 构 是零维 的 点 ,即 单元类型是 "Vertex" 。保存 的 VTK 文件 TriangleVerts.vtk 在 ParaView 里 的 显示结果 如 图 3-4 所示( 为 了便于观察三 角形 的三个顶点 , 图 3-4 显示 时把点 的 大 小设置成 5 个像素 ) 。
51


VTK 图形图像开发进阶
图 3 -4 3 .2_TriangleVertices 示例生成的 VTK 文件在 ParaView 中的 显示结果
继续在 3 .2_ TriangleVertices 示例的基础上做一 些更改 , 将零维的点拓扑结构改成一维的
线拓扑结构,代码如下所示(详见随书代码 Examples/Chap03/3.2_TriangleGeometryLines.cpp ) :
52
int main(int argc, char *argv□)
{
//创建三个坐标点
vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>: :NewQ; points->lnsertNextPoint (1.0, 0.0, 0.0); //返回第一个点的 ID : 0 points->InsertNe邓Point (0.0, 0.0, 1.0); //返回第二个点的 ID : I
points->InsertNextPoint (0.0, 0.0, 0.0); II返回第三个点的 ID: 2
//每两个坐标点之间分别创建一条线
IISetidO 的第一个参数是线段的端点 ID, 第二个参数是连接的点的 ID vtkSmartPointer<vtkLine> lineO = vtkSmartPointer<vtkLine>::NewQ; lineO->GetPointldsQ->Setld (0,0);
lineO->GetPointldsQ->Setld (1,1);
vtkSmartPointer<vtkLine> line! = vtkSmartPointer<vtkLine>::NewO; linel->GetPointldsQ->Setld (0,1); linel->GetPointldsQ->Setld ( 1,2);
vtkSmartPointer<vtkLine> line2 = vtkSmartPointer<vtkLine>::NewQ; line2->GetPointldsQ->Setld (0,2);
line2->GetPointldsQ->Setld (1 ,0);
//创建单元数组,用于存储以上创建的线段
vtkSmartPointer<vtkCeLIArray> Lines = vtkSmartPointer<vtkCellArray>::NewQ;
Lines->InsertNextCell (lineO); lines->InsertNextCeLI (lineI);


笫 3 章 VTK 基本数据结构
lines->InsertNextCell ( line2 );
vtkSmartPointer<vtkPolyData> polydata = vtkSmartPointer<vtkPolyData>::NewO;
//将点和线加入到数据集中 , 前者定义数据集 的几何 结构 , 后者定义拓扑 结构 polydata->SetPoints ( points ); polydata->SetLines (lines);
vtk:SmartPointer<vtk:PolyDataWriter> writer= vtk:SmartPointer<vtk:PolyDataWriter>::NewO; writer->SetFileName ("TriangleLines.vtk"); writer->Setlnput ( polydata ); writer->WriteQ;
return O;
示例 3 .2_ TriangleGeometryLines 生成的 VTK 文件在 ParaView 的显示结果如图 3-5 所示。 对千 VTK 的数据集而言,数据 集的 几何结构和拓 扑 结构是 必 不可少的两个部分 。
3 .2_ Tri anglePoints 示例只定义了数据集的 几何 结构 , 没有定 义 该数据集的 拓扑 结构 , 所以该 数据集不能直接显示; 3 .2_ Triang leVertices 和 3 .2_ TriangleGeometryLines 示例除 了 定义数据集 的几何结构(由 points 定义) , 还定义了相应的拓扑结构。其中示例 3.2_ TriangleVertices 定义的 是零维的点拓扑结构 ; 3.2_T riangleGeometryLines 定义的是 一 维的线拓 扑 结构 , 它 们 都保存在 由类 vtkCellArray 实 例化的 对象里 。 除了零维 的 点 、 一 维 的 线等类型的单元以 外 , VTK 还定 义了 其他类型的单元 。
图 3 -5 3.2_TriangleGeometryLines 示例 生成的 VTK 义件在 ParaView 中的显 示结果
3.3 单元类型
数据集由 一个或多个单元组成 , 图 3-6 和 3-7 列出了 VTK 支持的线性和非线性类型的单
53


VTK 图形图像开发进阶
元。 一 系列有序的点按指定类型连接所定义的结构就是单元(Cell) ,单元是 VTK 可视化系统
的基础。这些顺序连接的点定义了单元的拓扑结构,而点的坐标定义了单元的几何结构 。
.. 尸 。
. . . 产n
..
.. I
a) b) c) d)
。了2 昙
n
2
e) f) g)
II一 1 n - 2
3 2 .一 ,
口; `` 。
.
1. . - 
I
h) 1) j )
k)
yx
z」
卢
4
m)
9 8 10 9
。
78
n) o) p)
图 3-6 VTK 里定义的线性的 Cell 类型
a) Vertex b) Polyvertex c) Line d) Polyline(n lines) e) Triangle I) Triangle strip(n triangles) g) Quadrilateral h) Pixel
i) Polygon(n points) j) Tetrahedron k) Hexahedron 1) Voxel m) Wedge n) Pyramid o) Pentagonal Prism p) Hexagonal Prism
54


笫 3 章 VTK 基本数据结构
比如,图 3-8 是类型为六面体 (Hexahedron ) 的单元,顶 点列表(由点的索引号表示,
即 8-10-1-6-21-22-5-7, 每个 点通过索引号 可在顶点列表中检索到该 点的实际坐标值)定义了
六面体单元的拓扑结构 ,从 图 3-8 中可以 看 出,索引为 8 和 10 的点连接就构成 了六面体十二
条边中的 一 条,而 8- 10- 1-6 这四个 点连接就构成了六面体的 一 个面 。从这个 示例中,可以看
出单元是由单元的类型(如六面体)和构 成单元的顶点列表两 部分构成的。
2
0~\,。归'
a) b)
` 沪 。笘4
c) d) e)
3 4
f) g)
6
4
h) i)
J.)
II 5 II 5
,
皿` . 勹
l2n:: l2巨汀飞少
k) I) m)
图 3-7 VTK 里定义 的 非线性的 Cell 类型
a) Quadratic Edge b) Quadratic Triangle c) Quadratic Linera Quad d) Quadratic Quad e) Bi- Quadratic Quad f) Quadratic
Tetrahedron g) Quadratic Pyramid h) Quadratic Hexahedron i) Bi- Quadratic Hexahedron j) Tri- Quadratic Hexahedron
k) Quadratic Linear Wedge I) Quadratic Wedge m) Bi-Quadra阰 Wedge
55


VTK 图 形图像开发进阶
通常用数学符号 C,来表示单元,换言之 ,单元就是一个有顺序的点集 : C; ={P"P2,...,p;},
其中 P; EP'p 就是该有序的点集 。单元 的类型决定了点集里点的顺序 (或者说单元的拓扑);
而定义单元的点的个数就是该单元的大小 ( Size ) 。 单元的拓扑维度除了三维(见图 3 -8 ) 之外 ,还可以 _ Point Iisl
是零维、 一 维、 二 维等,如 零维 的顶点 (Vertex) 、 一 维
的线 (Line) 以及 二 维的三角形 ( Triangle ) 。单元可以 2 1
是基本类型或者基本类型 的组 合。基本类型是指不可再
分的单元,组合类型是由基本类型组合而成的。比如,
二
三 角形条带 (Triangle Strip) 是由多个三角形组成的 , 图 3-8 六而体 Cell
即 三 角形条带可以分解成多个 三角形 ,而 三角形是 二
维的基本单元类型。所以,对千单元的类型而 言 , 理论上由不同类型的单元可以组合成
无数种, VTK 应用程序需要用到哪些类型的单元应该根据具体的要求 。 总的来说, VTK
里的单元类型分为线性和非线性,如图 3 -6 和图 3 -7 所示,接下来的内容主要介绍 VTK
里定义的单元类型。
3.3.1 线性单元
单元类型的线性与非线性的划分主要是以插值函数为依据的,对千线性单元,采用的是
线性或者常量插值函数。另外 , 单元里的任意 一 条边都是由两个点连接定义的 。 VTK 里单元
的类型定义在 vtkCellType.h 文件里,线性的单元类型如下 。
I ) VTK_VERTEX 。 顶点,由 一个点定义,是零维 的基本类型 。
2 ) VTK_POLY_VERTEX 。多顶点,多 个顶点组合而成,是 零维的组合单元 , 其定义不
受顶点顺序的限制。 3 ) VTK_LINE 。直 线, 一 维的 基本类型 ,由 两个点定义,方向是从第 一 个点指向第 二 个
点。 4 ) VTK_POLY_LINE 。折线,由 一 个或 多 个 线段组合而成 , 一 维的类型 。 由 n+ I 个有序
的 点连接定义 的, n 表示 折 线的线段条数 , 每两个点 (l,计 l) 定义 一 条线段。 5 ) VTK_TRIANGLE 。三角形 , 二 维的基本类型,由 三个点按逆时针的方向连接定义 , 点的连接方向和表面法向量符合右手法 则,即 右手大拇指外的手指沿 着 点的方向弯曲 , 大拇
指所指向的方向就是表面法向 量。
6 ) VTK_TRIANGLE_STRIP 。三角形条带 ,由 一 个或多个 三 角形组合而成, 二 维类型 。 由 n+2 个 有序的点连接定义的 , n 表示三角形条带里三角形的个数,定义三角形条带的点不
需要共面。定义每个三角形的顶点顺序为 (i,计 l ,计2) , O ~ i~ n 。 7 ) VTK_QUAD 。 四边形, 二 维的基本类型,是由共面的四个点按逆时针的方向连 接定义的。四边形要求是非自交的凸多边形。利用右手法则可以得到该四边形的表面法
向量。 8 ) VTK_PIXEL 。二 维的基本类型,是由共面的四个点按 一 定的顺序连接定义的 。 该类 型的单元与四边形的区别在拓 扑 结构上, Pixel 类型要求相邻的两条边必须垂直,而且相对的 两条边要与坐标轴平行,因此 Pixel 的表面法向 量也与其中的 一条坐标轴平行。
56


笫 3 章 VTK 基本数据结构
定义 Pixel 的四个 顶点的顺序与四边形的 不同,如 图 3-6h 所示, Pixel 顶点的计数是先沿
着 X 轴的方向,然后是 Y 轴,最后是 Z 轴方向。 Pixel 是四边形类型的特殊形式,但要注意:
这里的 Pixel 是 一种单元类型,与图像像素 ( Pixel ) 的概念是不同的。 Pixel 具体表达什么意
思,需要根据上下文判断。
9 ) VTK_POLYGON 。多边形, 二 维的基本类型 , 是由共面的三个或三个以 上的点按逆
时针方向的顺序连接定义的。多边形表面法向量的方向通过右手法则确定。
该类型要求多 边 形 可以 是非凸 的,但是不能含有内部循环或者出现相交的边 。 多边形有 n 条边, n 就是组成多边形的点的个数 。
10 ) VTK_TETRA 。四面体 ,三维的基本类型,是由不共面的四个点两两连接定义的。
如图 3 -6j 所示 ,四面体有六条边和四 个面 。
11 ) VTK_HEXAHEDRON 。六 面体,三维的基本类型,包含六个四边形表面、 12 条边 和 8 个顶点 。其 中 8 个顶点的连接顺序如图 3-6k 所示,六面体要求必须是凸的 。
12 ) VTK_VOXEL 。三维 的基本类型,与六面体的拓扑 一样,但几何上有所区别。 Voxel
要求相邻的两个面 必 须垂直 , 点的连接顺序如图 3-61 所示。 Voxel 是六面体的特殊形式 。 与 Pixel 类似, Voxel 与 三 维图像体素 (Voxel) 的概念是不同的。
13 ) VTK_WEDGE 。 樑形, 三 维的基本类型 , 由三个四边形面 、 两个三角形面 、 九条边 和六个顶点构成 。 六个点的连接顺序如图 3 -6m 所示 。 要求面和边不能与其他的相交, 且挟 形必须是凸的 。
14 ) VTK_PYRAMID 。 角椎体, 三 维的基本类型,由 一 个四边形面 、 四个三角形面 、 八 条边和五个顶点构成 。 构成角椎体的点的连接顺序如图 3-6n 所示 。定 义四边形的四个点要求 是共面的 , 且四个点构 成的四边 形 必 须是凸 的,第 五个 点与其他 四个 点 不 在 一 个面上 。
15 ) VTK_PENTAGONAL_PRJSM 。 五棱柱, 三 维的基本类型 , 由五个四边形面、两个 五 边形面、 15 条边和 IO 顶点构成。点的连接顺序如图 3-60 所示 。 五棱柱的面和边不能与其 他的相交,且五棱柱必须是凸的 。
16 ) VTK_HEXAGONAL_PRJSM 。六 角柱, 三维的基本类型,由六个四边形面、两个六 边形面、 18 条边和 12 个顶点构成。点的连接顺序如图 3-6p 所示。六角柱的面和边不能与其 他的相交,且六角柱 必须是凸的 。
3.3.2 非线性单元
在数值分析领域里 , 为了更精准地表达数据 , 采用非线性单元作为数据的基本表达结构。 非线性单元可以提供更准确的插值函数,故可以获得更加理想的可视化效果。线性单元与非 线性单元的不同点是在渲染和数据 处 理方法方面 , 线性单元很容易转换成线性图元 , 用图形 库 处 理 ;而非线性单元不被图形库直接支持 ,必须先转换成线性单元以后,才能被图 形库支 待 。一般的策略如下 。
l ) 将非线性单元细分 成线性单元 ,再把细分的 结果当作线性单元来处 理。 2 ) 开发能够直接渲染或者可视化非线性单元的算法。 3 ) 程序自定 义 渲染图形库的操作。 在 VTK 中 , 主要采用第 1 种策略。因为 一 旦将非线性单元细分成线性单元 , 就可以用现 有 的处理线性单元的算法来处理非线性单元 。在对非线性单元做细分操作时 , VTK 是采取固
57


VTK 图形图像开发进阶
定细分的方法(见图 3-9) ,比如,对于一条只有一个拐点的 二 次曲线,在拐点处增加 一个点,
分别连接该点与曲线的两个端点,得到两条线段,用这两条线段可 逼近该二次曲线。
Quadratic Edge Two Lines
Quadratic Triangle Four Triangle
Quadratic Quadrilateral Four Quadrilaterals
图 3-9 VTK 用固 定细分 的方法将非线性单元细分成线性单元
V双 里非线性单元 的类型也是定义在 vtkCellType.h 文件中, 非线性单元的类型如下 。 1) VTK_QUADRATIC_EDGE 。 二 次曲线, 一 维的基本类型,由 三个点 定义 , 其中前两 个点分别对应 曲线的端点,第 三个点位 于 曲线的中间位置( 见图 3 -7a) ,曲 线的方向是由第 一
个 点指向第 二 个点。 2) VTK_QUADRATIC_TRIANGLE 。二次三角形 , 二维的基本类型之一 ,由 六个 点定 义, 其中前三个点对应三角形的三个顶点,另外三个点分别对应三条边的中 点 (见图 3-7b) 。 3) VTK_QUADRATIC_LINEAR_QUAD 。 二 次线性四边形, 二 维的基本类型之一 ,由六 个 点定义 , 其中前 四个点对应四边形顶点,另外两个点位 千第 一 和 第 三 条边的中点 处 (见图
3-7c) 。
4) VTK_QUADRATIC_QUAD 。 二 次四边形, 二 维的 基本类型之 一 ,由八个 点定义 , 其 中前四个点分别对应四个顶点,后四个点分别对应四条边的中点(见图 3 -7d ) 。 5) VTK_BIQUADRATIC_QUAD 。双二 次四边形, 二维的 基本类型之 一 ,由 九个点定义, 其 中前四个点分别对应四个顶点, 后 四个点分别对应四 条边的中 心, 最后 一 个点位 千该二 次
四边形的中心位置 (见图 3-7e) 。 6) VTK_QUADRATIC_TETRA 。 二 次四面体, 三 维的 基本类型之 一 , 由 10 个 点 定 义, 其 中前四个点分别对 应 四面体的四个顶点, 其 余六个点分别对 应 六 条边 的中 点(见图
3 -7f) 。
58


笫 3 章 VTK 基本数据结构
7 ) VTK_QUADRATIC_PYRAMID 。二次角锥 体,三维的基本类型之 一 ,由 13 个点
定 义,其中前五个点对应角锥体的五个顶点,其余八个点对应八条边的中点(见图 3-7g) 。
8 ) VTK_QUADRATIC_HEXAHEDRON 。二次六面体,三维的基本类型之一 ,由 20 个
点定义,其中前八个点对应六面体 的八个顶点,其余 12 个点分别对应 12 条边的中点 ( 见图
3-7h ) 。
9 ) VTK_BIQUADRATIC_QUADRATIC_HEX碑DRON 。双二次六面体, 三维的基 本
类型之一 ,由 24 个点定义,其中前八个点对应六面体的八个顶点,中间 12 个点分别对应 12
条边的 中点, 最后 四个点位 千前 四个面的中心位置(见图 3-7i) 。
10 ) VTK_TRIQUADRATIC_HEXAHEDRON 。 三 次六面体,三维的基本类型之一,由 27 个点 定 义, 其中 前八个点对应六面体的八个顶点,中间 12 个点分别对应 12 条边的中点,
另 外六个点位千六个面的中心位置,最后 一个点位于六面体的中心 (见图 3-7j ) 。
11 ) VTK_QUADRATIC_LINEAR_WEDGE 。 二 次线性樑形体, 三 维的 基本类型 之一,
由 12 个 点定义,其中前六个点对应樑形体的六个顶点, 其余六个 点分别对应组成上下两个面 的 三 角形边的中点(见图 3-7k) 。
12 ) VTK_QUADRATIC_WEDGE 。 二 次樑形体, 三 维的基本类型之 一 ,由 15 个点 定 义,其中前六个点对应樑形体的六个顶点,其余九个点分别对应九条边的中点(如图 3 -71 所示) 。
13 ) VTK--:BIQUADRATIC_QUADRATIC_WEDGE 。双二次樑形体 , 三维的基本类型之 一 ,由 18 个 点定 义, 其中 前六个点对应樑形体的六个顶点,九个点分别对应九条边的中点, 最后三个 点位千每个 二 次曲面的中 心位 置(见图 3-7m) 。
3.4 属性数据
属 性数据 ( Attribute Data) 是与 数据集 的组织结构相关联的 信息 (见图 3-2) 。 由前面的 内 容可知 , 组织结构包括几何结构及拓扑结构,几何结构由点数据定 义,拓扑 结构由单元数 据定义。因此,属性数据通常是与数据集的点数据或者单元数据相关联,但有时属性数据也 可能与组成单元的某些成分相关联 ,如 单元数据的某条边或者某个面等。此外 ,也 可 以 给 整个数据集指定某个属性数据 ,或者给数据集里 的某一组单元数据或点数据指定相应的属性 数据。
属性数据主要用千描述数据集 的属性特征,对数据集的可视化实质上就是对属性数据的 可视化,例如,根据压 力监测数据构建一 个压力场可视化数据集后 ,数据集中的每个数据 点 ( 几何数据)或单元都必须有对应的属性数据 , VTK 根据属性数据设置颜色表,用不同的颜 色表示不同 的 压力 , 通过颜色的变化情况 , 可 以 直观地分析出 压力的变化趋势。 根据数据的性质,属性数据可分为标量数据 、 矢量数据、张量数据等几大类(见图 3- 10 ) 。 属性数据可 以抽 象为 n 维的数组,比如 , 温度、压力等单值函数可 以看作 1 X 1 的数组,速度 等矢量数据可 以看作 3 X l 的数组(沿 X、 Y 和 Z 三个方 向的分量 )。相对而言 , 属性数据中 的标量数据 和 矢量数据应用比较广 泛。 在 VTK 中 , 用 vtkPointData 类和 vtkCellData 类表达数据集属性,它们是类 vtkDataSet Attributes ( vtkDataSetAttributes 派生自 vtkFieldData) 的 子类 ,构成数据 集 的每个点(或单元)
59


VTK 图形图像开发进阶
和属性数据之间存在 一对 一 的关系,如 一 个数据集由 N 个 点(或单元)构成,那么必须有 N
个 属性数据和 这 N 个点(或单元) 一 一对应,通过点的索引号就可以对该 点 的属性数据进行
访问,例如,在数据集 aDataSet 中访问索引号为 129 的点的标量值 时(假设标量数据已被定
义且不为 空)使用 如 下方法 : (nx, ny, n小
.
/ (11, V, lV} / ,.. n,.. n:)
lnl = I
标协Sca l ar) 矢址 ( V ector) 法向篮 (Normal) 单值数据 包含 方 向及幅度 三维方向
2D: (11, v) 3D: (11. v. w)
纹理坐标Tex tt1 re coordinate
r J
013023011
g022g
1
2
.1
aaa
,、
张屈 (Te n sor) n x n矩阵
图 3 - 10 属性数据
aDataSet->GetPointDataQ->GetScalarsQ->GetScalar(129) 。
3.4.1 标量数据
标 量 数据是数据集里的每个位置具有单值的数据,它只表 示数据 的大小,例如温度、压
力、密度、高度等。标 量 数据是最简单也是最普遍的可视化数据 。 示 例 3.4—VTKConceptScalars 演示了 VTK 里给点数据或者单元数据指定标量属性数据的
方法。
int main(int, char* □)
{
//创建点集数据 :包含两个坐标点
vtk:SmartPointer<vtk:Points> points= vtkSmartPointer<vtkPoints>::NewO;
points->InsertNextPoint(0,0,0); points->InsertNextPoint(1,0,0);
//创建多边形数据
vtkSmartPointer<vtkPolyData> polydata = vtkSmartPointer<vtkPolyData>::NewO;
polydata->SetPoints(poin岱);
II准备加入点数据 的标量值,两个标蜇值分别为 1 和 2
vtk:SmartPointer<vtk:DoubleArray> weights= vtkSmartPointer<vtk:DoubleArray>::NewO;
weights->SetNumberOtValues(2);
weights->SetValue(O, l);
weights->SetValue(l, 2);
60


笫 3 章 VfK. 基本数据结构
//先获取多边形数据的点数据指针,然后 设置该 点数据的标量属性值 polydata->GetPointDataQ->SetScalars(weights);
//输出索引号为 0 的点的标蜇值
double weight= vtk.DoubleA.rray::SafeDownCast( polydata->GetPointDataQ->GetScalarsO)->GetValue(O); std::cout << "double weight:" << weight << std::endl;
return O;
从 3.4_VfKConceptScalars 示例可 以 看出 ,要 给数据集里 的 点数据或者单元数据 设置标量 属性数据,只要 先获得该数据 集对应的点数据 或 者单元数据,然后设置相应的标量属性数据
即可,即
GetPointDataQ->SetScalarsQ;
3.4.2 矢量数据
与 物 理学的矢 量概念 一样 , VTK 的 矢 量数据也是指既有大小也有方向的 量 , 三 维方向上 用 三元组 ( Triple ) 表示 为 (u, v, w), 如速 度 、 应力 、 位移等。
除了矢 量 数据用 三 元组表示,颜色等标 量 数据也会用类似 三 元组 的 结 构 表示。 比如, 从 2 .2.3 节可知 , 颜色可以用 RGB 三 个分 量 表示 , RGB 分 量是 构成颜色标 量 数据的 三 个 组分 (Component ) ,尽管颜色 vtkColor 也 是 使用 vtkVector 容器 , 但它与矢益数据是有 本质区别的 。
标量数据在数据集 的几何变换过程中 具有不变性 。 比如,假设有 一个矢量数据存储在某 个 vtkDataSet 数据集里,当使用 vtkTransformFilter 对该数据集做变换时 , 希望的结果是该矢 量数据也随着数据集的变换而变换 ; 而对千 RGB 系统的颜色 , 假如把该颜色的 RGB 三个分 屋当 成矢痲方向 的三 个方向 , 对该数据集做变换时,颜色值也会 随着变化,对千某一 点的颜 色 , 显然需要的结果是变换前后它 的值应该保持不变。法 向 量是指大小 恒 为 1 的 方 向向 量 , 也 是 一种 常用 的 矢量数据,通常用 千计算投影 、光照等。当 对数据集做变换时 , 法向 量 是会 随之发生改变 的 。
3.4.3 纹理坐标
为了使物体看起 来更加真实 , 计 算机图 形学通常对显示 的三 维物体采用纹理映射。纹理 坐标可以将点从笛卡 儿坐标空间映射到 一维、 二 维或三维的纹理空间中。
3.4.4 张量数据
张握是矢量和 矩阵通过 复杂 的数学算法得到 的, 一个 K 阶的张量可 当 作一个 K 维的 表格 。 零 阶的张械是标量 ,一阶的张量是矢量 , 二 阶的张昼是纹理坐标 , 三阶的张量是一个三维阵 列, VTK 只 支持 3 X 3 的对称的张量 ,如 图 3 - 10 所 示 。
61


VTK 图形图像开发进阶
3.5 不同类型的数据集
由前述内容可知,数据集由组织结构和与之关联的属性数据组成, 组织结构包括拓 扑 结
构和几何结构 。数据集的类型由它的组织结构决定,同时数据集 的 类型决定 了 点和单元之间
的相互关系,图 3 - 11 列出了 常用的数据集类型,图 3-12 是对应的类的继承图 。
a) b) C)
. ...
••
•• \、
..
..
.
•••
.
.
)
··
d
..
••
.
.
.. :::.少
守国
少了三
D □仑
/歹勹
e) 。
图 3- 11 VTK 常用的数据集类型
a) 图像数据 b) 线性网格 c) 结构网格 d) 非结构点 e) 多边形数据 f) 非结构网格
vtkStructurcdPoints
vtkUnifom1Grid
vtk LabelHierarchy
|
vtk PolyData
vtkStructuredGrid
vtkUnstructure dGri d
图 3- 12 VTK 常用数据集的类继承图
3.5.1 vtklmageData
vtklmageData 类型 的数据是按规则排列 在矩形方格中的点和单元的集合,如图 3- 1 la 所
62


笫 3 章 VTK 基本数据结构
示,如果数据集的点和单元排列在平面(二维)上 ,则称此数据集为像素映射 ( Pixmap ) 、
位图或图像;如果排列在层叠面(三维)上,则称为体 o vtklmageData 是 由 一维的线、二维
的像素或三维的体素组成, vtklmageData 的几何结构及拓扑结构都是规则的,因此每个点的
位置可隐式地表达,只需要知道 vtklmageData 数据的维数、起始点的位置和相邻点之 间的间
隔,就可以计算出每个点的空间位置。数据维数用 一个三元组(nx, ny, nz)来表示 ,分别表示在 X 、 Y 和 Z 方向上点的个数 。 vtklmageData 数据集的点的个数一共是 nxXnyX nz, 单元的个数 一 共是(nx- 1) X (ny-1) X (nz-1) 。
vtklmageData 类型的数据集在图像处理和计算机图形学领域应用都非常广泛,而医学图 像则会较多使用体数据 , 如计算机断层成像 ( Computed Tomography, CT ) 和磁共振成像
( Magnetic Resonance Imaging , MRI ) 。 鉴千 vtk.ImageData 的重要性,第 5 章会详细介绍相关
的内容 。
3.5.2 vtkPolyData
多边形 数据集 vtkPolyData 由顶点 ( Vertex ) 、 多顶点 ( Polyvertex ) 、线 (Line) 、折线
( Polyline ) 和 三 角形条带 (Triangle Strip) 等单元构成,多边形数据是不规则结构的,并且多 边形数据集的单元在拓扑维度上有多种类型,如图 3-1 le 所示。多边形数据是数据、算法和 高速计算机图像学的桥梁 。 vtkPolyData 类型的数据同样是 VTK 中应用非常广泛的 一种数据 类型。 第 6 章会更深入地探讨相关的内容 。 顶点、线和多边形构成了用来表达 0 、 1 和 2 维几何图形的基本要素的最小集合,同时用 多顶点、折线和 三 角形条带单元来提高效 率和性能,特别是三角形条带,用 一个三 角形条带 表达 N 个三角形只 需要用 N+2 个点,但是用传统的表达方法需要用 3N 个 点,而且大多数图 形库渲 染三 角形 条 带的速度比 直接渲染三 角形要快很多。
3.5.3 vtkRectilinearGrid
vtkRectilinearGrid 类型 的数据 是排列在 矩形 方格中的点和单元的 集合,如图 3- 1 lb 所 示 , 线性网格的 拓 扑 结构 是规则的, 但其几何 结构只 有部分 是规则的,也就是说,它的 点是沿着 坐标轴排列的,但是两点间的间隔可能不同,和均匀栅格数据相似,线性网格是 由像素或体 素等单元组成的, 它 的拓扑结构通过指定 网格的维数来隐式地表达,几何结构通过一系列的 X, Y,Z 坐标来表达。
3.5.4 vtkStructuredGrid
vtkStructuredGrid 是结 构化网格数据, 具有规则的拓扑结构和不规则的几何 结构,但 是单 元没有重叠或交叉,如图 3- 1 le 所示。 结构化网格的单元是由四边形或六面体组成, 结构化 网格通常用 千有 限 元分析 。 典型的应用包括流体流动、热量传输和燃烧学等。
3.5.5 vtkUnstructuredGrid
vtkUnstructuredGrid 是非结 构化网格, 是最常 见的数据集类型 , 它 的拓扑 结 构 和 几何 结 构 都是非结构化的, 在此数据集 中 , 所有单元类型都可 以组成任意组合 ,所有单元 的 拓 扑 结 构 从 零维延伸 至 三 维,如图 3- 1 lf 所 示。
63


VTK 图 形图像 开 发进阶
在 VTK 中,任 一类型的数据集都可用非结构化网格来表达, vtkUnstructuredGrid 类型数
据的存储需要大 量 的空间,计算时需要消耗大量 的资源,除非迫不 得 已, 一 般较少使用此种
类型的数据集 。 非结构化网格主要用千有限元分析、计算 几何和图形表 示等领域。
3.5.6 vtkUnstructuredPoints
vtk.UnstructuredPoints 为非结构化点集,是指不规则地分布在空间的点 集。非结构 化 点集
具有不规则的几何结构,不具有拓扑结构,非结构化点 集用离散点来表达 , 如图 3- 1 l d 所 示 。
通常,这类数据没有固定的结构,是由 一 些可视化程序识别和创建的 。非结 构化点 集适
合表现非结构化数据,为了实现数据的可视化,可将这种数据形式转换成其 他 一 些结构化的
数据形式。
3.6 数据的存储与表达
3.6.1 vtkDataArray
VTK 中的 内存分配采用连续内存,可以快速地创建、删除和遍历,称之为数据数 组 ( Data
Array ) ,用类 vtkDataArray 实现。数组数据的访问是基千索引的,与 C++一 样,从零开
始计数。 以 vtkFloatArray 类来说明如何在 VTK 中 实现连续内存的数据数组。如图 3- 13 所示,变
量 Array 是 一 个指向浮点型数组的指针 ,数组的长度由变量 Size 指 定,由于数组的长度是动 态地增加的,所以当存储数据的数组长度超出指定的长度时,会自动触发 Resize()操作来调整 数组的长度,使数组的长度变成原来的两倍, Maxld 是 一 个整型的偏移 量 ,用来 定义最后 一 个被插入的数据的 索引。如果没有数据插入 , Maxld 等于- 1, 否则, Maxld 的值介千 0 和 Size
之间,即 o ::s; Maxld<Size 。
float :Array; I------|Number of Co mponents int Si 匹 int Max ld ;
int Numbe心 fComponents: - 1fo I Ji 1} I I f 2 | f , I
char *Name、[ Maxld
Size(n)
图 3 - 1 3 连续数组的实现
此外,许 多可视化数据 是由多个数据分量组成的,如 RGB 颜色数据由红、绿、蓝三 个分 量组成,为了在连续数组中表达这 一类数据 ,引入了 元组 ( Tuple ) 的概念。元组是数据数组 的子数组,用千存储数据类型相同的分量数据 , 图 3- 1 3 所示 的 NumberOfComponents, 表示 的就 是数据数组里元组的组分个数。元组的组分个数称为元组的大小,在给定后不会改变, 图 3- 14 所示的数据数组由 N 个元组组成,每个元组由 三个组分组成 。 vtkDataArray 及其子类是建立 VTK 数据对象的基础。以 vtkPolyData 为例,该类由几何 数据 ( vtkPoints ) 、拓扑数据 (vtkCellArray) 和属性数据 ( vtkPointData 、 vtkCellData 和
64


笫 3 章 VTK 基本数据结构
vtkF叫dData) 组成,而这些数据都是通过数据数组 (vtk:DataArray) 的形式存储 。 vtk:DataArray
可以存储标量数据,也可以存储向量数据。因此使用 vtk:DataArray 时需要指定元组的大小。
例如 ,点、矢量和法向 量等属 性数据,元组的大小是 3, 而张量属性数据的元组大小是 9 (即
3 X 3 的矩阵 ) ,标 量属 性数据对元组的大小则没有任何要求。对千处理标量属性数据的算法,
通常都是只处理标量每 一个元组数据的第 一 个组分。 VTK 提供了将多组分的数据数组分离成
单 一 组分的数据数组的类 vtkSplitField, 以 及将单一组分的数据数组合并成多组分的数据数组
的类 vtkMergeFields 。
下面通过 一些代码片段看看 VTK 是如何创建数据数组的:
vtkSmartPointer< vtkFloatArray >array= vtkSmartPointer< vtkF!oatArray >::NewQ; array->SetNumberOfComponents(1); array->SetNumberOtTup!es(lO); array->SetComponent(5, 0, 10.0); array->SetTuple1(6, 9.0); double b = array->GetComponent(5, O);
这段代码演示了如何创建固定长度的数据数组 , 首 先是设置元组的组分个数为 1 (参考图 3- 1 4) 以及总的
元组个数为 10 。方法 SetComponent()和 GetComponent() 分别用千设置及获取元组的值。
SetComponent(vtkldType i, int j , double c) :指 定第 i 个 元组 的第 j 个组分的值为 c 。
GetComponet(vtkidType i, int j) : 获取第 i 个元组 的
第 J 个 组分的值,由函数返回值返回 。 除了可以 创 建固定长度 的数据数组, vtkDataArray 也 提供了动态 创建数据数组 的 方法 ,代码如下所 示 :
00
ee
ll p u p
((
]]
Jtuplc /1-l
图 3- 1 4 数据数组结构,图中每个元组
的组分个数为 3
vtkSmartPointer< vtk.FloatArray > array = vtkSmartPointer< vtk.FloatArray >::NewO; array->SetNumbetO 忙omponents(I); array->lnsertNextTuplel(S); array->JnsertNextTuple1(IO); double b = array->GetComponent(l, O);
以上代码首先设置每个元组的组分个数为 1 , 方法 InsertNextTuple l ()用 于插入一个单组分 的元组,连续调用两次即为插入两个元组,其值分别为 5 和 10, 类似的方法还有
InsertNextTuple2(), InsertNextTuple3(), lnsertNextTuple4(), lnsertNextTuple9()等。
可视化数据有各种各样的类型,如简单的浮点型 、 整型 、 字节型和双精度型等 , 复杂的 特征字符串 和 多维标识符等。既然有这么多 种数据类型 ,那么 数据数组是如何操作和表达这 些数据 的呢? VTK 通过抽象数据对象 (Abstract Data Object) 提供运行时解决方案以及使用 C开编译 时动态绑定 的方法来解决这个问题 。 如图 3- 15 所示 , vtkDataArray 是 一个抽象基类 , 其子类实现特定类型 的数据数组及相关操作 。
65


VTK 图形图像开发进阶
vtk 心j立t
vtkAbstractArray
vtkUnsignedCharArray vtkCharArray vtkUnsignedShortArray vtkFloatArray
图 3- IS 数据数组对象 (只列出部分数据数组类)
抽象数据对象通过动态绑定的方式使用统 一 的接口来创建、操作和删除数据, C++ 中用
virtual 关键字来声明动态绑定方法。动态绑定允许通过操作抽 象父类的方法来调用具体子类
对象的实现 。 以 vtkDataArray 为例,调用该抽象父类的方法 GetTuple(l29)来 获取 ID 为 129
的点数据值。因为 GetTuple()方法是在抽象父类 vtkDataArray 中 定义的虚函数 , 且返回的数据
类型是 double, 所以每一个从 vtkDataArray 派 生的子类,都必须实现该方法,返回—个 double
型的数据。
3.6.2 数据对象的表达
VTK 里的数据对象是作为 vtkDataArray 的数组 ( 即数据数组的数组)实现的 。
vtkDataObject 是 一 种通用的可视化数据的 表达,可视化算法基本都没有直接处理
vtkDataObject 类型的数据,在处理某 一类数据时, 一 般都要求数据内部具有某种组织结构 。 vtkDataObject 内部封装了 与可视化管线的执行相关的变 量 和方法,包括表达数据 。在 vtkDataObject 内 部有 一个 vtkFieldData (场数据 )的实例 , 负责对数据的表达。如图 3- 16 所
示 ,场数据可以 看作数据数组的数组 ,数组 里的每 一 个元素都是一 个数组 , 数组的类型 、 长
度 、 元组的大 小和名称等都可 以各不相同 。 图 3 - 17 是类 vtkFieldData 的继承图,从 类的名字能够推断出 , vtkFieldData 存储的数 据 是与数据 对象的属性数据相关的。以 vtkPolyData 为例, vtkPolyData 内部 存储了 三 种类 型的数据,分别是 vtkPointData 、 vtkCel!Data 和 vtkFieldData 。 vtkPointData 是与每 一 个点 相关联的数据,如某点上的温度值; vtkCellData 是与每 一 个单 元相关联 的数据,如某个 三 角形单元的面积 ; 除点和单元数据以外的数据,应该使用 vtkFieldData, 如 vtkPolyData 模
型的质 心 等 。
Array 0 Array I Array 11- l
vtk DataArray
wk 压taSelAttributes
vlkFieldData: 数组的数组,每 一 个数组的元素类型可以是不同的类型 。
图 3 - 1 6 vtkDataObject 数据对象的表达 图 3- 1 7 vtkFieldData 类的继承图
66


笫 3 章 VTK 基本数据结构
3.7 本章小结
正如本章开头所说,光是了解每种原料的特点而没有掌握做菜的流程,依然做不出美味
可口的菜。就好比学习《数据结构》这门课程,在学习数据结构的同时,都会通过学习某些 算法来理解各种数据结构的用法。否则,即使掌握 了各种各样的数据结构,也不知道如何使
用它们。学习本章所介绍的数据结构的用法时 ,可以参考第 5 章和第 6 章相关的算法加以理
解。对千 VTK 中的某些概念性的东西,还是有必要掌握的。 本章主要介绍 了数据对象 ( vtkDataObject) 、数据数组 (vtkDataArray) 和场数据
( vtkFieldData ) 等内容。
(1) vtkDataObject
VTK 中的数据 一般是以数据对象的形式表现 的, vtkDataObject 是 VTK 可视化数据最常 用的表达形式,数据对象表现的数据可被可视化 管线所 处理,当数据对象组织成一种结构以
后,这些数据才能被 VTK 的可视化算法处理。
将数据对象组织成一种结构并且赋予相应的属性值时就形成数据集 (vtkDataSet) 。类 vtkDataSet 是从 vtkDataObject 派生的 (见图 3- 1), vtkDataSet 的组织结构由拓扑 结构和儿何 结构两部分组成(见图 3-2) 。
(2) vtkDataArray
数据数组 vtkDataArray 及其子类(继承关系如图 3- 15 所示)是建立 VTK 数据对象的基础。 不同类型的数据对象(如 vtkDataSet) 都含有几何结构和拓扑结构信息 ,而这些结构信息的存储 就是使用 vtkDataArray 及其子类,比如 vtkPolyData 里的 vtkCellArray 存储拓扑结构信息。
( 3 ) vtkFieldData
数据 集里的属性数据是对拓扑结构和 几何结构信息的补充,属性数据可以是某个空间点 的温度值,也可以是某个单元的质量等。与数据集的点数据相关联的属性数据用 vtkPointData 来表达,与单元数据相关联的属性数据用 vtkCellData 来 表达,从图 3-16 可以看出,类 vtkPointData 和 vtkCellData 都派生自 vtkDataSetAttributes, 而 vtkDataSetAttributes 派生自 vtkFieldData 。换言之 , 可以使用 vtkFieldData 来存储像颜色 、加速度、标号、名字、温度 、 质量等等这些属性数据 。一般的用法是:
dataset->GetPointDataO->AddArray(attributeArray);
除了以上内容,本章还列举了不同类型的线性与非线性单元的结构以及各种属性数据 。 对 于 这些内 容 ,建议通过查看 VTK 附带的示例程序或者相关参考资料来加深理解,单纯看某 一种数据 结构,总 是会让人觉得乏味,更不知如何使用,最好能结合某个可视化算法进行理 解, 具体请参考第 5 章和第 6 章等内容 。
67


第 4 玫 VTK 数据的读写
对千应用程序而言,都需要处理特定的数据, VTK 应用程序也不例外。通过前面 章节 的
学习可知 , VTK 应用程序所需的数据可以通过两种途径获取 : 第 一种是生成模型,然后处 理
这些模型数据 ( 如由类 vtkCylinderSource 生成的多边形数据) ;第二种是从外部存储介质里 导入相关的数据文件 ,然 后在应用程序中处理这些读入的数据(如 vtkBMPReader 读取 BMP
图像) 。 另 一方面, VTK 也可以将程序中处理完成的数据 写入单个文件中,或者将所渲染的
场景导出,以备后续操作的使用。从可视化管线的角度来看 , 一般 以数据的 读取(或由模型
创建数据 )开始,而 以 数据的写盘操作(或 Mapper ) 结束,这一章将重点学习与 VTK 可视
化 管线 两端相 关的类,包括数据读写 以及场 景的导入导出。
4.1 Reader 与 Writer 类
第 2 章中已经接触了 VTK 的 Reader 类,要将外部数据读入可视化管线,主要的步
骤如下。
l ) 实例化 Reader 对象。
2 ) 指定所要读取的文件名。
3 ) 调用 Update()方 法促使管线执行。当管线后续的 Fiter 有 Update()请求时 ,如调用
Render()方法.管线就会读取相应的图像文件 ,所以这一步有 时也可省略。
类 似地,使用 Writer 类的主要步骤 如下。
l) 实例 化 Writer 对象 。
2 ) 输入要写盘的数据以及指定待写盘的文件名。
3 ) 调用 Write()方法促使 Writer 类开始写盘操作。
VTK 提供了不同的 Reader/Writer 类读写各种文件 , 对于类的使用者而言,最重要的是根
据不同的文件类型选择合适的 Reader/Writer 类进行读写操作,不同的 Reader 类所输 出的数据
类型不相同 ,不 同的 Writer 类所要求输入的数据类型 也不同。在第 3 章中已经了解 了 主要的
数据集,包括 vtklmageData, vtkPolyData, vtkRectilinearGrid 等,下面根据不同的数据集类型
介绍常见的 Reader/Writer 类,并以 vtklmageData 类型的 Reader/Writer 为例,演示 VTK 进行
文件读写操作的方法。
4.1.1 vtklmageData 类型
图像数据在 VTK 中是用 vtklmageData 类表示的 ,对 于不同 的图像文件类型, VTK 提 供相对应的类对图像文件进行读写操作 。 比如,前面 章节中所提 的 vtkBMPReader 是用 千读 取 BMP 图像, vtkJPEGReader 用 于读 取 JPG 图像 。 VTK 除了支持 BMP 、 JPG 图像格式之外,
还支持其他多种图像格式的读写,表 4-] 列出了部分 VTK 支待的常见图像文件的
Reader/Writer 类。
68


笫 4 章 VTK 数据的读写
表 4-1 输出/输入类型为 vtklmageData 的 Reader/Writer 类
Reader/Writer 类 图像格式
vtkBMPReader BMP 图像 ( •.bmp )
vtkBMPWriter
vtkJPEGReader JPG 图像 ( ..jpg)
vtkJPEGWriter
vtkPNGReader PNG 图像 (•.png)
vtkPNGWriter
vtkPN邓eader PNM 图像 (•.pnm )
vtkPN叩nter
vtkT盯Reader TIFF 00 像 (*.tif)
vtkTIFFWriter
vtkMetalmageReader M趴 /M印)图像< •.mha I•.mhd)
vtkMetalmageWriter vtkDicomlmageReader DICOM 图像 (• .dcm )
vtkXMLlmageDataReader 基千 XML 的文件格式 (•.vti)
vtkXMLlmageDataWriter
vtklmageReader RAW 格式 (•.raw)
vtklmal!,eWriter
值得注意的是 vtkJmageReader/vtkJmageWriter 用千读写 RAW 格式的数据(即俗称的“裸
数据”) 。 该类型的图像没有文件信息,因此在读取此类图像时,需要指定图像各个维度的 大小、字节顺序(是大端字节序还是小端字节序)、存储像素值的类型等信息,只有指定这 些信息,类 vtkJmageReader 才能 正确读取图像。所以,在 一般情况下,很少使用这个类来读 取图像,如果要读取 RAW 格式的图像文件,可以用类 vtkMetalmageReader, 该类可以读扩展 名为 “*.mha" 和 “* .mhd" 的图像。 其实 这两种格式是一样 的,只不过 MHA 格式图像把图 像的信息头与实际的像素值等数据写入同 一 个文件中,而 M印)格式则图像信 息头与实际像 素值的存储分为两个文件(即*.mhd 与* .raw 或*.zraw 两个文件, 其中 *.zraw 是指有压缩)。 关于 mhd 格式的图像,可以看 一个 VTKData 附带的文件 Head.MRVolume.mhd (该图像 文件在下载的 vtkdata-5 . 10 . 1.zip 文件里,见第 1 章)。打开该文件有如下内容 :
NDims=3 DimSize = 48 62 42 ElementSize =4.000000e+OOO 4.000000e+OOO 4.000000e+OOO ElementSpacing =4.000000e+OOO 4.000000e+OOO 4.000000e+OOO ElementType = l'vIBT_UCH球 ElementByteOrderMSB =False ElementDataFile = HeadMRVolume.raw
这部分内容指明了这个图像文件的信息(即图像信息头),各标签的含义分别如下。 • NDims: 表示该图像的维数。 • DimSize: 表示该图像各维的大小 。 • ElementSize: 表示图像像素的大小。
• ElementSpacing: 表示像素间的间隔。
• ElementType: 表示存储图像像素值所用的数据类型,该例是用 unsigned char, 即 1 个 字节存储 l 个像素。
• ElementByteOrderMSB: 表示是按什么字节顺序存储数据的。 • ElementDataFile: 存储像素数据的文件位置。该例表明像素值是存储于文件名为
69


VTK 图形图像开发进阶
HeadMR.Volume.raw 的文件中,用 UltraEdit 等工具打开该 RAW 文件,可以看到该
RAW 文件的大小是 l 24992Byte, 即 124992 = 48 x62 x42 x I, 也 就是该图像 一 共有
48 x 62 x42 个像素,而存储每个像素是用 I Byte , 因此一共有 124992Byte 。另外 , 需要
注意 , ElementDataFile 标签里可以用带路径的文件名来指定 , 但一般很少这么做,常
见的都是 一个 M印)文 件跟一个同名的 RAW 文件在同 一 目录。
类 vtkDicomlmageReader 可用 千读取 DICOM 图像 , DICOM C*.dcm ) 图像是医学图像处理
中使用最广泛的格式但该类的功能很不完善。虽然 VTK 最初是因 医学图像可视化的应用而诞
生,但 VTK 对 DICOM 图像的读写操作却很不支持,比如该类不支持多帧 DICOM 图 像的读取 ,
而且 VTK 也没有实现对 DICOM 图像的写操作,即没有提供类 vtkDICOM加ageWriter 。
因 此,仅仅简 单地使用 VTK 现有的类 vtkDICOMimageReader 来读取,显然不能满足实际
的应用需求。对 DICOM 图像的读写支持较好的函数库主要有 GDCM 和 DCMTK 。 著名的 医 学
图像分割与配准工具包 ITK ( Insight Segmentation and Re伊stration Toolkit, 下载地址为
http://www.itk.org) 就是封装了 GDCM 函数库进行 DICOM 图像的读写 。而 DCMTK
(http://www.dcmtk.org ) 是目前对 DICOM 协议 ( http ://medical.nema.org ) 支持最全的工具包,
同时也是读写 DICOM 图像的专业函数库。所以 , 如果使用 VTK 进行医学图像可视化且 需 要
读写 DICOM 图像,可以考虑用 GDCM 、 DCMTK 等函数库 ,或者直接使用 ITK 进行 DICOM
图像的读写。 接下来通过几个示例,看看 VTK 是如何进行单个文件或 者多 个文件的读 写操作的 。
1. 读写单个图像文件 由前面的内容可知,单个图像文件的读写操作非常简单, 只要根据图像文件格式,选
取适 当 的 VTK 类 即可, 示例 4.1 _ ReadWriteSinglelmage 演示了 PNG 图像的读取,并将读
入的图像保存成*.jpg 格式的图像。
70
int mainO
{
//读取 PNG 图像
vtkSmartPointer<vtkPNGReader> reader = vtkSmartPointer<vtkPNGReader>::NewO; reader->SetFileName(". ./data/VTK-logo. png");
II显示读取的单幅 PNG 图像
vtkSmartPointer<vtklrnageViewer2> imageViewer = vtkSmartPointer<vtklmageViewer2>: :NewO; imageViewer->SetlnputConnection(reader->GetOutputPortO); vtkSmartPointer<vtkRenderWmdowlnteractor> renderWindowlnteractor = vtkSmartPointer<vtkRenderWmdowlnteractor>::NewQ; imageViewer->Setuplnteractor(renderWindowlnteractor); imageViewer->RenderO;
imageViewer->GetRendererO哑>ResetCameraO;
imageViewer->RenderO;
II保存成 JPG 图像
vtkSmartPointer<vtkJPEGWriter> writer = vtkSmartPointer<vtkJPEGWriter>::NewQ;
writer->SetFileName("VTK-logo.jpg");


笫 4 章 VTK 数据的读写
}
writer->SetlnputConnection(reader->GetOutputPortO); writer->WriteO;
renderWindowlnteractor->StartQ;
该 例先使用 vtkPNGReader 读入 PNG 图像,然后用 VTK 窗口显示读取的 PNG 图 像,最
后 使用类 vtkJPEGWriter 将读入的文件写成 JPG 图像。示例中使用 SetFileName()方法设置要
读写 的图像 名 , 在 写文件操作时要调用方法 Write()才会将内存中的数据写入到存储介质中。
此外,该 示 例 与 第 2 章 中介绍的 VTK 可视化管线有所不同,在显示图像时并没有用到
vtkRenderWindow 、 vtkRenderer 、 vtkActor 等类,而只是使用了 vtkimageViewer2 以及设置了
交互样 式 。其实 , VTK 可视化 管 线相关的几个类都已经封装在 vtklmageViewer2 里。
vtkimageViewer2 主 要是针对 二 维图像(特别是医学图像)显示设计的,实现了图像缩放、旋
转 、 平移 、 窗 宽窗位调节 等功能;除了可以用于单幅二维图像的显 示之 外,也可以显 示三 维
图像 的 某 个切片,还可以设 置 不同的显 示方 向 。
在读 取图像文件时,如果 无 法确 定 所读取的图像是什么格式,可以使用类
vtkimageReader2Factory 来读 取要导入的文件,该类会试着 寻找 一种最适合的类对图像做读取
操作, 这个 类 可以 读取大 部分标准格式的图像文件, 示例 4.1_ReadUnknowFormatlmage 演 示 了类 vtkimageReader2Factory 的用法:
vtkSmartPointer<vtklmageReader2Factory> readerFactory = vtkSmartPointer<vtklmageReader2Factory>::NewQ; vtklmageReader2 * reader= readerFactory->CreatelmageReader2("../data/VTK-logo"); reader->SetFileName("../data/VTK-logo"); reader->UpdateQ;
在示例 4.1_ReadUnknowFonnatlmage 中,根据待读取的文件名,用类 vtklmageReader2Factory 里 的 方法 CreatelmageReader2()创建一个 vtklmageReader2 的对象 , 类 vtk.ImageReader2 是 VTK 里图像读 取类的父类。示例中 待读取的文件 “VTK-logo" 实 际 就是 “VTK-logo.png" 文件, CreatelmageReader2()方法会 调用 vtk.ImageReader2 的 CanReadF业()方法 ,遍 历所有 图 像读取 类 ( Reader 类) ,如 果有某个类可 以 读取这个文件,就返回 true ; 否则, 返回 false 。 成功找 到某个适 当 的类读取文件时 , 返 回 将 vtk.ImageReader2 向下转型成 该子类对 象 , 并由该子类对 象 执行实际 的 读文件操作 (如果想深入理解 这种机制,可以 参考 设计模式里的 “ 工厂 模式”) 。 除非迫不得已 , 一 般不建议采用这种方法来读取图像,毕 竟它还 要去遍历所有图像读取类 , 读取速度 明 显 会受 到影 响 。
2. 读取序列图像文件
医学图像应用程序 中 常常会处理序列的图像文件,比如计算机断层成像或者磁共振成像所成的 图像一般都是由多个有顺序的二维 图像组成,应用程序需要一次性导入一个序列的二维图像。 VTK 没有提供专门 的类读取序列 图像文件, 但 VTK 的图像 Reader 类都有提供方法 SetFileNamesO来设 胃多个图像文件名 ,利用该方法可 以 实现序列图像的读取。 示例 4.1_ReadSerieslmages1 首先读取 -个 JPG 的序列 图像 Head, 该序列 图像包含 100 张大小为 256 X 256 像素的二维图像 , 由这 100 张二维图像组成一个三维数据体 (程序运行结果如图 4- ]所示 ) 。
71


VTK 图形图像开发进阶
intmainO {
//生成图像序列的文件名数组
vtkSmartPointer< vtkStringArray > fileArray = vtkSmartPointer< vtkStringArray >::NewO; c归 fileName[128];
for(int i = 1; i < 100; i++) {
sp血顷fileName, "../data/Head/head%03d.jpg", i); vtkstd::string fileStr(fileNarne); fileArray->InsertNextValue(fileStr);
//读取 JPG 序列图像
vtkSmartPointer<vtkJPEGReader> reader= vtkSmartPointer<vtkJPEGReader>::NewQ; reader->SetFileNames(fileA汀ay);
//显示读取的 JPG 图像
vtkSmartPoin比r<vtklmageViewer2> imageViewer= vtkSmartPointer<vtklmageViewer2>::NewQ; imageViewer->SetlnputConnection(reader->GetOutputPortQ); vtkSmartPointer<vtkRenderWindowlnteractor> renderWindowlnteractor = vtkSmartPointer<vtkRenderWindowlnteractor>::NewQ;
imageViewer->SetSlice(50);//默认显示第 50 个切片(即第 50 层) imageViewer->SetSliceOrientationToXYO; //imageViewer->SetSliceOrientationToYZQ; //imageViewer->SetSliceOrientationTo:XZQ; imageViewer->Setuplnteractor(renderWindowlnteractor); imageViewer->RenderQ;
renderWindowlnteractor->StartO; retumO;
、`
I勺} 4.1-R.必心如`印
I
图 4- 1 示例 4.1 _ReadSerieslmages I 运行结果
72


笫 4 章 VTK 数据的读写
示例中使用 vtkStringArray 生 成文件名列 表 ,然 后 调用 vtkJPEGReader 的方法 SetFileNames()设置待读取的序列图像的文件名 。 初始显示该序列图像 的第 50 个切片,显示的
方 向为 SetSliceOrientationToXY() 。
另外,还可 以 使用 Reader 类里的 SetFilePrefix()和 SetFilePattemO等方法读取序列图像, 示 例 4. l _ ReadSerieslmages2 演示了这两种方法 的使用 。
vtkSmartPointer<vtkJPEGReader>reader = vtkSmartPointer<vtkJPEGReader>::NewO;
reader->SetFilePrefix ("../data/Head/head");
reader->SetFilePattern("%s%03d.jpg"); reader ->SetDataExtent (0,255,0,255, 1, I00);
reader->UpdateO;
在调用 SetFilePrefix()和 SetFilePattern()等方法读取序列图像文件时,要求序列图像文件 的命名要有规律,比如示例 4.1 _ReadSerieslmages2 中读取的文件命名为: headOO l.jpg, head002.jpg, ..., head l 00.jpg, 在示例 中 ,先使用 SetFilePrefix()设置文件名相同的部分 ( 可 包含路径信息) , 再用 SetFilePatternQ设置图像文件名中的序号变化的部分。 除了以上两种方法之外 , 读取序列图像文件时 , 也可以先一张一张地读入,然后再合并 成 一 个 三维的数据体 , 示例 4. l _ ReadSeries1mages3 演示了这种用法。
vtkSmartPointer<vtklmageAppend >append= vtkSmartPointer<vtklmageAppend >::NewQ;
append->SetAppendAxis(2);
vtkSmartPointer<vtkJPEGReader>reader = vtkSmartPointer<vtkJPEGReader>::NewQ;
char fileName[l28]; for(int i = 1; i <21; i++)
{
sprintf(fileName,"../data/Head/head%03d.jpg", i); reader->SetFileName(fileName);
append->AddlnputConnection(reader->GetOutputPortO);
示例 4. I_ReadSerieslmages3 使 用类 vtklmageAppend 做数据的合并操作,其中 SetAppendAxis(2) 函数是指 定 Z 轴为 读入的 每层图像数据的堆叠方 向 。
4.1.2 vtkPolyData 类型
从 第 3 章 的学习中可以知道, vtkPolyData 是图形处理中使用非常广泛的一种数据集类 型,本书第 6 章 将重点介绍 vtkPolyData 类型数据的图形 处 理方法。 VTK 里输出 /输入类型
为 vtkPolyData 的 Reader/Writer 类(部分) 见 表 4-2 。
Reader/Writer 类
vtkPolyDataReader vtkPolyDalaWriter vtkXMLPolyDataReader vtkXMLPolyDataWri比r
表 4-2 输出/输入类型为 vtkPolyData 的 Reader/Writer 类
文件格式
VTK 文 件 ( • .vtk )
基千 XML 的 VTK 文件 ( • .vtp )
73


VTK 图 形图像开发进阶
Reader/Writer 类
vtk.XMLPPolyDataReader ~ a l aWriter vtkOBJReader vtkOBJWriter vtkPLYReader vtkPLYWriter vtkSTLReader vtkSTLWriter
文件格式
基千 XML 的井行分段的 VTK 文件 (•.pvtp )
OBJ 文件 (*.obj)
PLY 文件,斯坦福大 学开发的一种文件类型 ( *.ply )
STL (Stereo Lithography File) 文件,即 立体光刻文件。
4.1.3 vtkRectilinearGrid 类型
输出/输入类型为 vtkRectilinearGrid 类型的 Reader/Writer 类见表 4-3 。
表 4-3 输出 /输入类型为 vtkRectilinearGrid 的 Reader/Writer 类
Reader/Writer 类
vtkRectilinearGridReader vtkRectilinearGridWriter vtkXMLRectilinearGridReader vtkXMLRectilinearGridWriter vtkXMLPRectilinearGridDataReader vtkXMLPRectilinearGridDataWriter
4.1.4 vtkStructuredGrid 类型
文件格式
VTK 文件 (*.vtk )
基于 XML 的 VTR 文件 (•.vtr )
基于 XML 的井行分段的 VTR 文件 ( *.pvtr)
输出/输入类型为 vtkStructuredGrid 类型的 Reader/Writer 类见表 4-4 。
表 4-4 输出 /输入类型为 vtkStructuredGrid 的 Reader/Writer 类
Reader/Writer 类
vtkStructuredGridReader vtkStructuredGridWriter
vtkX皿 StructuredGridReader vtkXMLStructuredGridWriter vtkXMLPStructuredGridDataReader vtkXMLPStructuredGridDataWriter
vtkPLOT3DReader
4.1.5 vtkUnstructuredGrid 类型
文件格式
VTK 文件 (*.vtk)
基于 XML 的 VTS 文件 c• .vts)
基于 XML 的井行分段的 VTS 文件 (*.pvts)
PLOT3D 文件 C*.xyz )
输出/输入类型为 vtkUnstructuredGrid 类型的 Reader/Writer 类见 表 4-5 。
表 4-5 输出/输入类型为 vtkUnstructuredGrid 的 Reader/Writer 类
Reader/Writer 类
vtkUnstructuredGric!Reader vtkUnstructuredGridWriter vtkXMLUnstructuredGridReader vtkXMLUnstructuredGridWriter vtkXMLPUnstructuredGridDataReader vtkXMLPUnstructuredGridDataWriter
4.2 场景的导入与导出
文件格式
VTK 文件 (*.vtk)
基于 XML 的 VTU 文件 ( • .vtu )
基千 XML 的并行分段的 VTU 文件 ( *.pvtu)
(续)
场 景 的导入 (Import) 与导出 (Export) 是指将渲染场 景 中的对象,包括光照、相机、 Actor 、
74


笫 4 章 VTK 数据的读写
属性 、变换矩阵等信息写入文件中 ,或者从外部文件中将这些对象导入渲染场景中 , 一 般所
导入的文件含有多 个数据集 。 Import 类可 以 生成 vtkRenderWindow 和 vtkRenderer 实例 , 用户
也可以另外指定 vtkRenderWindow 和 vtkRenderer 对象。 VTK 中 一 般以关键字 Importer 和
Exporter 命名的 类是与 场 景 的导入与导出相关的 。 Importer 类可以导入由其他 3D 模型软件
( 如 3DSM心0 所生成的 模型文件 ; Exporter 则可以将 VTK 里的 场 景生成可被其他 3D 模型
软件所 处 理的文件。
VTK 支持 的 Import 类包括 vtk3DSimporter 和 vtkVRMLimporter; 而支持的 Exporter 类则
相对要多 一 些 , 主要有 vtkRIBExporter 、 vtkGL2PSExporter 、 vtkIVExporter 、 vtkOBJExporer 、
vtkOOGLExporter 、 vtkVRMLExporter 、 vtkPOVExporter 、 vtkX3D Exporter 等。
这部分内容相对 比 较简单 , 示例 4.2_ lmport3DS 演示了类 vtk3 DSimporter 的用法,其他 类 的使用 基本类似 。
II 3DS Import vtkSmartPointer<vtk3DSlmporter> importer = vtkSmartPointer<vtk3DSimporter>::NewQ; irnporter->SetFileName (filename.c_strQ); importer->ComputeNormalsOnQ; importer->ReadQ;
vtkSmartPointer<vtkRenderer> renderer= importer->GetRendererO; vtkSmartPointer<vtkRenderWindow> renderWindow = importer->GetRenderWindowO;
vtkSmartPointer<vtk.RenderWindowlnteractor> renderWmdowlnteractor = vtkSmartPointer<vtkRenderWmdowlnteractor>::NewO; renderWindowlnteractor->SetRenderWmdow(renderWindow);
示例 4.2_Import3DS 先用类 vtk3DSimporter 导入一 个扩展名为“* .3ds" 的模型文件,调 用 ComputerNormalsOn()方法打开法向拯 的计 算 功能( 关千法 向 量 的内容, 请参考本 书第 6 章 内容) , 然后分 别 生成从 vtk3DSimporter 的 实例中 获取的 vtkRenderWindow 和 vtkRenderer 的 实例 。 程序运行结果如图 4-2 所 示。
'.I•,..·
图 4-2 示例 4.2_Import3DS 运行结果
75


VTK 图形图像开发进阶
4.3 本章小结
本章主要介绍了处千 VTK 可视化 管线两端 的类,即 读操作和写操作相关的类 。 VTK 针
对不同的数据类型,提供了不同的读 写类 ,对千类的使用 者而言,最重要的是根据不同的文
件类型选择合适的 Reader/Writer 类进行读写操作。
另外, VTK 还可以导入由其他 3D 模型软件所生成的文件,也可将 VTK 里生成的数据写
成可被 其 他 3D 模型软件所处理的 模型文件,这样有利千 VTK 与其他主流的模型软 件 的
结合。
76


第 5 章 VTK 图像处理
数字图像是 一种重要的多媒体数据 , 广泛应用千工业生产 、 生物医学 、地质 、 气象等重 要领域。数字图像 处 理技术具有重要的应用价值。图像是 VTK 里非常重 要的 一种数据结构。
本章重点讲解 VTK 在数字图像处理应用方面 的 相关技术。
5.1 VTK 图像创建
5.1.1 VTK 图像数据结构
数字图像文件 内 容 由 两个部分组成 : 图像头信息和数据。 图 像头信息定 义 了图像的基本 信息,主要包括起点位置 ( Origin ) 、像素间隔 ( Space ) 和维数 ( Dimension ) 。通过这三个
参数即可确定图像空间位置和大小。图像可以看作空间中的一个规则的网格 , 网格中的每个
最小单元称为像素(二维)或者体素(三维),网格在每个方向上的像素或者体素个数即为
图像在该方向的维数 。 像素索引表示每个像素在图像网格中的位置,是图像内部的网格坐标。
在医学图像中,每个图像除了内部坐标外 , 还存在 一个世界坐标,这个世界坐标依赖千成像
设备。在医学图像中,起点位置、像素间隔和图像维数决定了世界坐标系。这样通过起点位
置、像素间隔和像素索引即可计算每个像素的世界坐标。
图 5- 1 表示一个 4x2心体素的图像 , 即图像的维数,每一个小球表示一个像素;而图像的原
点为(5. 1 , 1 0.0, 6.5) ,两个像素之间的间隔表示像素间隔,每个方向的像素间隔分别为 1.5 、 1.5 和 1.8 。
x
Y
)
zo
。 `。 `
』
(
8
5
(S. I , I0.0.6.S) 1.5
图 5- 1 图像结构和空间表示
图像数据即为图像像素的像素值,一般采用 一维数组来表示和存储。已知像素索引和图 像维数的情况下 , 即可计算每个像素对应的像素值。通常图像的像素值为 一个标量 ,例如灰 度图像;图像像素值也可以是一 个矢量 ,例如梯度图像 ; 另外,图像像素值还可以是张量 , 如弥散张蜇成像 ( Di ffusion Tensor Imaging, DTI ) 。医学图像处理中经常使用的是灰度 图像。 这里需要注意 : 灰度图像像素或者体素的数据类型在 一般的灰度图像处理中不需要考虑, 因为其范围默认为 0~255 ,可以采用 一 个 unsigned char 类 型来表示。但是在医学图像 处理中 , 256 灰度级远远不能满足要求 , 因此灰度范围往往大千 256 级。常见医学图像的像素数据类型
77


VTK 图 形 图 像 开发进阶
为 unsigned short, 灰度范 围 为 0 ~ 65536 。另 外 , 有 时为了 精度 的 考虑 , 也会使用 i nt 、 float
或者 double 类 型 , 因 此 需要格外注意。
由第 3 章 内 容可知 , VTK 中图像数据 结 构 由 vtklmageData 类表示 。 利 用 vtklmageData
可以 方便地创 建、读 写 和 访 问 图 像数据 。 下 面 以 VTK 图 像 创 建为起 点 , 一 步步走进 YTK 图
像处 理 的 世界 。
5.1.2 VTK 图像创建
1 .图像源 Source
VTK 中 内 置 了 多 个创 建图像的 Source 类 , 利用这些 Source 类可以快速创 建图像 。 这里
以 vtklmageCanvasSource2D 为代表 进行说明 。该 Source 类的功能是 创 建 一 个画布( 空白图像) ,
并提供了 多 种几何 图形 ( 点 、 线段、 圆 、 矩形 以 及 图 像等) 的 绘 制 填充功能 。
. 下述代码演示 了类 vtklmageCanvasSource2D 的使用方法(详 见随 书代码 Examples\Chap05\
5.1 _ ImageCanvasSource2D.cpp ) 。
vtk:SmartPointer<vtk.ImageCanvasSource2D> canvas = vtkSmartPointer<vtk.ImageCanvasSource2D>::NewO; canvas->SetScalarTypeToUnsignedCharO; canvas->SetNumberOfScalarComponents( 1); canvas->SetExtent(O, 100, 0, I00, 0, O); canvas->SetDrawColor(O, 0, 0, O); canvas->Fil!Box(O, 100,0, 100);
canvas->SetDrawColor(255, 0, 0, O); canvas->FillBox(20,40,20,40); canvas->UpdateQ;
上面的代码 片段中 , 先定 义 了 一 个 vtkJmageCanvasSource2D 对 象 , 然后设 置画布的像素 数据 类型 、 像素组 分 数 目和 画 布的 大 小; 然后 ,利 用画布 的 F仆 IBox()方法在画布中绘制两 个 矩形 , 并通过 画 布的 SetDrawColor()方法来设置两 个 矩形 的 颜色 。程序运行结果 如图 5-2 所 示 。
.一`` ~
工 5l如a9忒onvn,Source2D 匡烂 ,
i
JJ 结 果

, 『 .
绘图
D
}
2
9
e

urc

Sso
anva
}
C

ge

ma
kl
} vt
用
一.
一
. 2
. 
. 图5
_~
厂
,'ii'lllli'i1'
,I'I',I
'11ii
_
1,L
. ,
78


笫 5 章 VTK 图像处理
除了 vtkimageCanvasSource2D 外, VTK 还提供了其他类似的 Source 类来快速生成特定
的图像 , 例如 vtklmageEllipsoidSource, 该类根据指定的中 心以 及各个轴的半径来生成一个前
景为椭圆(球) 的 二值图像 ; vtkimageGaussianSource 类生成一幅像素值服从 高斯分布的图像;
vtkimageGridSource 用 于生 成网格线图 像 ; vtklmageNoiseSource 生成一 个像素值为随机数的噪 声图像 ; vtkimageSinusoidSource 生成的图像像素值由正弦函数决定。
2 . 直接创建图像
利用 上 述图像 Source 可以快速地 生 成特 定 的 图像 , 但是实际应用中它 们用到得较少 。 VTK 中可以手动生成图像,然后根据需要进行像素赋值 。 下述代码演示了手动创建图像的方法(详 见随书代码 Examples\ChapOS\5. l_CreateVTKimageData.cpp ) 。
vtkSmartPointer<vtklmageData> img = vtkSmartPointer<vtklmageData>::NewQ; img->SetDimensions(l 0, I0,IO); img->SetScalarTypeToUnsignedCharO; img->SetNumberOfScalarComponents(l); img->AllocateScalarsQ;
unsigned char *ptr = (unsigned char*)img->GetScalarPointerQ; for(int i=O; i<IO*JO*JO; i++)
*ptr ++=i%256;
先定义 vtklmageData 对象 , 然后指定图像的维数,而图像的原点和像素间隔则都是采用默 认值 , 因此不需要设置 。 SetScalarTypeToUnsignedChar()指定图像的像素数据类型为 unsigned char, SetNumberOfScalarComponents()则指定每个像素值 的组分数为 1, 即每个像素值为 1 个标 量值 。参数 设置完 毕 , 调用 AllocateScalars()分配内存,生成图像数据 。 图像生成后,默认所 有像素值为 0 。 可以通过访问图像数据数组来设置每个像素值, vtklmageData:: GetScalarPointerO 即返回图像的数据数组(图像数据数组采用 一维数组 , 参考本书 3.6 节的内容) , 然后根据图 像 的 大 小 ,访问每个像素并为其赋值 。 生成的图像结果如图 5-3 所示。
r 51`c,“'.”“....还妯山 一 匕竺
.__ __ __ __-一 ,
I
!
I
i『;
00 5- 3 1'f接创建 VTK 附像
79


VTK 图形图像开发进阶
5.2 VTK 图像显示
5.2.1 vtklmageViewer2
VTK 早期 的版本提供了 vtklmageViewer 类来显示图像 , 随 着 版本的发展,目前使 用
vtklmageViewer2 来代替 vtklmageViewer 实现图像的显示 o vtklmageViewer2 中封装了 VTK 图像
显示的可视化渲染引擎,包括 vtkActor 、 vtkRender 、 vtkRenderWindow 、 vtklnteractorStypelmage
等对象 ,可以 方便 地完成图 像显示和交互 。 该类提供的主要交互 操作有图像放缩、窗宽窗 位调节,并提供切片选择及切片方向设置接口,尤 其适合 三 维图像的切片显示 。下 述代码 说明了 使用 vtklmageViewer2 显示图像的方法(详 见 随书代码 Examples\Chap05\5 .2_
DisplaylmageExample.cpp) 。
vtk:SmartPointer<vtkMetalmageReader> reader = vtkSmartPointer<vtkMetalmageReader>::NewQ; reader->SetFileName (argv[l]); reader->UpdateQ;
vtkSmartPointer<vtklmageViewer2> imageViewer = vtkSmartPointer<vtklmageViewer2>: :NewQ; vtkSmartPointer<vtk:RenderWmdowlnteractor> renderWmdowlnteractor =
vtkSmartPointer<vtk:RenderWindowlnteractor>::NewQ;
imageViewer-> SetlnputConnection(reader->GetOutputPortO); imageViewer->Setuplnteractor(renderWmdowlnteractor); imageViewer-> SetColorLevel(500); imageViewer->SetColorWmdow(2000); imageViewer->SetSlice(40); imageViewer->SetSliceOrientationToXYO; imageViewer->RenderQ;
renderWindowlnteractor->StartQ;
这里为了更好地演示 vtklmageViewer2 的 功能,以 一幅三维医学图像为例进行说明。首先使 用 vtkMetalmageReader 读入一个*.mhd 格式的图像,然后定义 vtklmageViewer2 对象显示图像 。 为 了实现鼠标、键盘消息响应 , 定义 vtkRenderWindowlnteractor 对象 , 并通过 vtklmageViewer2:: SetlnteractorQ设置交互对象。最后设置了窗位 ( ColorLevel ) 、 窗宽 ( ColorWindow ) 、 切片索引 ( Slice) 和切片方 向 ( Orientation ) 等参数。 程序运行结果如图 5-4 所示。 在渲染窗 口 中 , 按下鼠标左键拖动鼠标 , 可以调节图像的窗宽窗位 , 从而 显示不同灰度 范围内 容 ; 按下鼠标右键拖动鼠标可 以 缩放图像。 当 然 , 这些交互操作可以由用户根据 需要 自己定 义 vtklnteractorStyle 子类 , 并 响应相应 的 操作。
1. 窗宽/窗位的概念 窗宽是图像显示 的灰度范围。 一般显示器的灰度范围为 256 级 , 而 医 学图像的灰度范围
80


笫 5 章 VTK 图像处理
则远远大千该范围,因此通过显示器显示时不能显示所有灰度级,需要使用窗宽来定义欲显 示 的灰度范围 。 当灰度值高千该范围 的最大值时,均以白影显示 :当低 于该范围时 ,均以 黑
色显 示。 若增大窗宽,则显示具有不同灰度值 的组织结构增多, 但是会降低组织之间的对比 度,若减 小窗 宽, 则可视的不同 灰度 组织结构会减少,同时增 大 组织结构的对比度。
窗位是窗宽 的中心位 置( 见图 5-5 ) 。窗宽 只是确定了 CT 图像灰度范围上的可视部分范
围,还需要窗位来确定可视灰度范围的具体位置。同样的窗宽 ,会根据窗位的位置变化来显
示不同的组织结构 。 比如, 窗宽 为 200, 当窗位为 100 时,可视灰度范围为 0~200: 当窗位
为 500 时,可视灰度范围为 400~600 。当窗宽窗位确定 以后, 显示时底层会将可视灰度范围
转换到 256 灰度级进行显 示。
1 D 又0,,凸i- 匕
i- }
:一 :
!I.!:
:--窗宽-
图 5-4 用 vtk.ImageViewer2 显 示三 维图像的某个切片 图 5 -5 医 学图像窗宽/窗位示意图
2. 医学图像二维视图
切片 ( Slice ) 或切面是三维图像比较常用的概念,尤其在医学图像中,不同方向的切面 都有特定的名 字( 见图 5-6) ,分别是 : 矢状面 ( Sagital Plane ) , 沿着身体前后径所做的与地 面垂 直 的切面 ; 冠状面 ( Coronal Plane ) ,沿着身体左右径所做的与地面垂直的切面 ; 横断面 ( Transverse/Axial Plane ) ,是指横断身体与 地面平行的切面 。设置切片的方向即是通过不同的 方向来观察人体内部组织结构 。
图 5-6 医 学图像二 维视图 示意 ( 图来自维基百科)
81


VTK 图形图像开发进阶
常见的 医学图像可视化软件通 常会提供 四 个视图用来显示图像 : 横断面视图 、 矢状面视
图、冠状面视图和 三 维视图,例如图 5 -7 所示 的视图是来 自德国癌症研究中 心的 MITK 3M3
医学图像处理软件 (http://www.mitk.org ) 。
尸__ 3M3 ll O 心o心一一一·,“',如·
白°""'口 2六”~ x~F~i o~ 0
Ii ____
D ....上“'
,m 口401....“m 心的心五乃峰已乃立 1
_.二
0edb - ~ 1一三 ... -a切 ;
.
53
.心追d 巨. l,..., lll619 2 沁 6只,心..>.:
I,.- - . "、
r·..~ 飞亡玉寸吐」
l”I'!嘈`才· ~`· ··'"
IiI
!1
鲁
2。四
C”
l1!i.丘 .
L
J
乙h
i100
L
...
...
133
·'.,.
I且
==n-i-9兰
uau
5 11 , 3 2`
“1 7i ..,(IO`)
图 5-7 德国癌症研究中 心 的 MJTK 3 M3 医学图像处理软件
类 vtklmageViewer2 提供了 SetSlice() 函数来设置 切片 索引 , SetSliceOrientationToXY()则 将切片的 方向 设 置为垂直 XY 平面方向。此外还可以设置为垂直 YZ 或者 XZ 平面方向,其对
应 函数分别为 SetSliceOrientationToYZ()和 SetSliceOrientationTo:XZ() 。 默认情况下切片方向为
垂直千 XY 平面 即沿着 Z 轴方 向,根据设詈的切片索引获取 Z 轴方向的具体切片进行显示。
5.2.2 vtklmageActor
vtklmageActor 是一个 三 维图像渲染 Actor , 通过纹理映射将图像映射到 一个多边 形上进 行显示。 使用 vtklmageActor 较 vtklmageViewer2 要复杂一些 , 需要建立完整的渲染管线 : 包
括 vtklmageActor 、 vtkRender 、 vtkRenderWindow 和 vtkRenderWindowlnteractor。 另 外, 作为 
维图像浏览器,不 需要在三 维空 间中进行旋转操作 , 因此还需要为 vtkRenderWindowlnteractor 定义一个 vtklnteractorStyleImage 对象。 下例中使用 vtklmageActor 建立图像渲染管线来显示图
像并实现交互功能(详见随书代码 Examples\Chap05\5.2_DisplayImageExample2.cpp ) 。
vtkSmartPointer<vtkBMPReader> reader = vtkSmartPointer<vtkBMPReader>::NewO; reader->SetFileName (argv[ I]); reader->UpdateO;
82


笫 5 章 VTK 图像处理
vtkSmartPointer<vtklmageActor> imgActor = vtkSmartPointer<vtklmageActor>::NewQ; imgActor->SetlnputConnection(reader->GetOutputPortQ);
vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::NewO; renderer->AddActor(imgActor); renderer->SetBackground(.4,.5, .6);
vtkSmartPointer<vtkRenderWindow> renderWmdow =
vtkSmartPointer<vtkRenderWindow>: :NewQ; renderWmdow->SetSize(SOO, 500); renderWmdow->AddRenderer(renderer);
vtkSmartPointer<vtkRenderWindowlnteractor> renderWindowlnteractor = vtkSmartPointer<vtkRenderWindowlnteractor>::NewO; vtkSmartPointer<vtklnteractorStylelmage> style= vtkSmartPointer<vtklnteractorStylelmage>::NewQ;
renderWmdowinteractor->SetlnteractorStyle(style); renderWindowlnteractor->SetRenderWindow(renderWindow); renderWindowlnteractor->Initial izeO;
renderWmdowlnteractor->StartQ;
该例中使用 vtkBMPReader 读入 图像后 ,依 次建立 vtklmageActor 、 vtkRender 、 vtkRender Window 和 vtkRenderWindowInteractor, 并组装为渲染管线。然后建立 vtklnteractorStylelrnage 对象,通过 renderWindowlnteractor->SetlnteractorStyle(style)设 置交互类型对象。需要注意的 是 , vtklmageActor 接收的图像数据 vtklmageData 像素类型必须为 unsigned char, 如果类型 不符合要求,在显示图像前需要先将图像数据类型转换为 unsigned char 。运行结果如图 5-8 所示 。
i}
l蠲霾霪.
-f
}
i 
____- J
图 5 -8 用类 vtk.lmagcActor 显示图像
83


VTK 图形图像开发进阶
5.2.3 图像融合
前面介 绍 的两种 显示 图 像 的 方法都是在窗口中显示一 幅图像 。 在实际应用中经常需要在
窗口中同时显 示多 幅图像,这就会用到 图像融合技术 。 图像融合是利 用 图 像的不透 明 度来合 成图像 。在 VTK 中 ,用类 vtklmageBlend 实现图像的融合 。
vtklmageBlend 可 以 接 收 多 个 图像输入, 其输 出为融合图像 。 输出图像的像素间隔、原点、 范围以及像素组分个数与第 一个图像一致 。该类提供了两种融合模式 。 第 一种是标准模式,也 是默认的融合方 式 。 其代码如 下:
output<- input[OJ foreach input i { foreach pixel px { r <- input[i](px)(alpha) * opacity[i]
f<-(255 -r) output(px) <- output(px) * f + ini,ut(px) * r
第 二种是混合模式 ( Compound ) 。 该模式下输出结果利用不透明度的和做归 一 化 。 当像
素 的不透明度 alpha*opacity 小于或等于阙值 threshold 时 , 该像素会被忽略 。 其代码 如 下 :
output <-0
foreach pixel px { sum <-0 foreach input i { r <- input[i}(px)(alpha) * opacity(i) sum <-sum + r
if r > threshold { output(px) <-output(px) + input(px) * r
output(px) <- output(p,x) / sum }
下例使用 vtklmageBlend 实现两个 图像 的 融合并显示(详见随书代码 Examples\ChapOS\
5.2_ lmageBlendExample.cpp ) 。
84
vtkSmartPointer<vtkJPEGReader> reader = vtkSmartPointer<vtkJPEGReader>::NewO; reader->SetFileName (argv[l]);
reader->UpdateO;
vtkSmartPointer<vtklmageCanvasSource2D> imageSource = vtk:SmartPointer<vtklmageCanvasSource2D>: :NewO; bnageSource->SetNumberOfScalarComponents(l);
imageSource-> SetScalarTypeToUnsignedCharQ;


imageSource->SetExtent(O, 512, 0, 512, 0, O); imageSource->SetDrawColor(O.O); imageSource->FillBox(O, 512, 0, 512); imageSource->SetDrawColor(255.0); imageSource->FillBox(l 00,400,100,400); imageSource->UpdateQ;
vtlcSmartPointer<vtklrnageBlend> imageBlend = vtlcSmartPointer<vtklrnageBlend>: :NewO; imageBlend->Setlnput(O, reader->GetOutputO); imageBlend->Setlnput(l, imageSource->GetOutputO); imageBlend->SetOpacity(O, 0.4); imageBlend->SetOpacity(l, 0.6); imageBlend->UpdateO;
笫 5 章 VTK 图像处理
该示例中先读入一 幅灰度图像,另外生成 一 个二值图像;然后定义了 vtklmageBlend 对象,
Setlnput()函 数设置两个图像作为输入。这里设置输入 图像时,由于可以输入多个图像,因此
需要给定图像的 id 号来设置输入。 SetOpacity()函数用 千设置对应 id 号的图像不透明度的大小, 当不透明度为 1.0 时,为 完全不透明。程序的运行结果如图 5-9 所示 。
图 5-9 用类 vtkimageBlend 融合图像
5.3 VTK 图像基本操作
图像处理离不开一些基本的图像数据操作 ,例如 获取和修改图像的基本信息 、 访问和修 改图像像素值、图像显示 、图 像类型转换等。熟练掌握这些基本操作有助千使用 VTK 进行图 像处理应用程序 的快速开发 。
5.3.1 图像信息的访问与修改
1. 利用 vtklmageData 的方法
vtklmageData 中提供了 多 个函数用 于访问或者获取图像的基本信息,这些函数通常以 Set
85


VTK 图形图像开发进阶
或者 Get 加上相应的信息名的形式进行命名,例如获取 图像维数的方法定 义为 GetDimensionsO 。
下面通过 一 个示例来说明怎样访问 图 像的 基 本信 息( 详见 随 书代 码 Examples\Chap05\5.3_
GetlmagelnformationExample.cpp ) 。
vtkSmartPointer<vtkBMPReader> reader = vtkSmartPointer<vtkBMPReader>::NewO; reader->SetFileName (argv[l]);
reader->UpdateO;
int dims[3]; reader->GetOutputQ->GetDimensions(dims);
std::cout<<“图像维数:“<<dirns[O]«" "«dims[l]«" "«dims[2]«std::endl;
double origin[3]; reader->GetOutputQ->GetOrigin(origin); std::cout<<“图像原点 :"<<origin[O]«" "« origin[1]« " "« origin[2]<<std::endl;
double spaceing[3]; reader->GetOutputO->GetSpacing(spaceing); std::cout<<“像素间隔:“ <<spaceing[O]<<" "<<spaceing[1]<<" "<<spaceing[2]<<std::endl;
该示例 主要获取了图像的 三个信息 ,即图 像维数 、图 像原点和像素间隔。 VTK 中无论是
二 维图像还 是三 维图像,都用 vtklmageData 表示 ,因此程序 中 定 义图 像维数为 dims[3] ,然后 利用 GetDimensions()函数获取 图 像的 维数 ; 图 像的 原点 和 像素 间 隔 都 是物理空间数值 , 其数 值类型 为 double 。 本例 读入 了 一 幅 二 维图像 , 图 5-10 为 显示获取 的 图像信息 。 从显 示结果中 可 以 看到 , 图 像维数为 512 X 512X 1, 其中 Z 方 向的 维数 为 l , 说明该图像 为 二 维图像 ; 而图
像 的 原点 为 (0,0,0) 点, 像素 间 隔 为 (1,1,1) 。
86
_ _ _ ___
图 5 - 10 图像信息的访 问 与修改
2 . 利用类 vtkChangelmageloformation vtklmageData 中提供了多 个 Set 函数用千设置图像的基本信息。在对 一 个图像 F ilter


笫 5 章 VTK 图像处理
的输出图像信息 进行 修 改 后 ,如果 Filter 重新 Update, 图像 信息 又会 恢 复回原来的值 。 而 vtkChangelmagelnformation 类可以作为 管 线中的一个 Filter 来修改图像 信 息 。利 用这 个
Filter 可以 修 改图像的原点、像素间隔以及范围,另外还可以 实 现图像 平 移缩放等操作 。
下例 演示 了 类 vtkChangelmagelnformation 的使用 ( 详见随书代码 Examples\Chap05\5.3_
ImageChangelnformationExample.cpp ) 。
vtkSmartPointer<vtkBMPReader> reader =
vtkSmartPointer<vtkBMPReader>: :NewO; reader->SetFileName (argv[1]); reader->UpdateO;
int dims[3); double origin[3]; double spaceing[3];
reader->GetOutput()->GetDimensions(dims); std::cout<<“原 图 像维数:“<<dims[O]<<" "<<dims[l)<<" "<<dims[2)<;<std::endl; reader->GetOutputQ->GetOrigin(origin); std: :cout<<“原 图像原点: “<<origin[O]«" "<<origin[!)«" "«origin[2]«std::endl;
reader->GetOutputQ->GetSpacing(spaceing); std::cout<<“原像素 间隔 "<<spaceing[O)<<" "
<<spaceing[l]« " "« spaceing[2]<<std::endl<<std::endl;
vtkSmartPointer<vtklmageChangelnformation> changer=
vtkSmartPointer<vtklmageChangelnformation>::NewQ; changer->Setlnput(reader->GetOutputO); changer->SetOutputOrigin(l 00, 100, O); changer->Set0utputSpacing(5,5, 1);
changer->SetCenterlmage(1); changer-> UpdateQ;
changer->GetOutputQ->GetDimensions(dims);
std: :cout<<“修改后图像维数:“<<dims[O]<<" "<<dims[l]<<" "<<dims[2]<<std::endl; changer->GetOutputO->GetOrigin(origin);
std: :cout<<“修改后图像原点 ” <<origin[OJ«" "<<origin[l]<<" "<<origin[2]«std::endl; chang er-> GetOutputO->GetSpacing(spaceing);
std: :cout<<“修改后像素间隔 " <<spaceing[O]<<" "<<spaceing[l]<<" "<<spaceing[2]<<std::endl;
该 示例先 读入图像 , 由 vtk:ImageData 提供的函数接口获取 图像 的维数、图 像原点和像素 间隔 。 然后 定 义 vtk:ImageChangelnformation 对象,并设置输出 图像原点为 C 100, 100, 0 ) , 输 出图像像素 间隔为 ( 5, 5, 1 ) ,然后调用 CenterImage() 函数将图 像 的 原点置于 图像的中 心 。程 序运行结 果 如图 5 - 11 所示 。
从 上 述结果可 以 看 出 , 操作后 的 结果使得图像的原点位于 (- 1277 . 5 , - 1275.5, 0 ) , SetOutputOrig in( 100, I 00, 0) 并没有起作用。这是 为什么 呢 ? 如果看看 CenterImage() 函数的注 释 , 可 以 发现 该 函数的作用 是将 ( 0, 0, 0 ) 点置 于 图像的中 心 。 当 CenterImage() 函数执行时会
87